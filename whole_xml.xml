<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.activerecord">
<title>Exploring ActiveRecord</title>
<p>Remember how we created a <ic>person</ic> object with the <ic>generate scaffold</ic> command, in <ref
linkend="ch.firstapp"/>?  Our scaffold generated a <class>Person</class> class. The <class>Person</class> class and its
corresponding <ic>people</ic> table is our model. The model represents a single row in the database table.</p>

<p>ActiveRecord, the <emph>model</emph> in the Rails Model-View-Controller pattern, lets us easily create, retrieve,
update and destroy database records with minimal effort. We skip writing mundane SQL statements, and if we follow
standard naming conventions, we can avoid configuration as well. We can focus on solving our application’s specific needs
rather than writing boilerplate code.</p>

<p>ActiveRecord uses naming conventions to map rows in our database tables to Ruby objects. 
In any language, we call these kinds of libraries &lquot;Object-Relational-Mappers&rquot; or ORMs, and we use them because they
let us write natural code in one language to create a corresponding effect in another.  In our case, we manipulate Ruby
objects to effect change in a SQL database.</p>
<p>With ActiveRecord we can: </p>
<ul>
  <li><p>work with Ruby Objects, instead of database tables and records</p></li>
  <li><p>write very concise code to fetch and store data</p></li>
  <li><p>easily write and maintain database independent code</p></li>
</ul>
<p>We’ll pick up just where we left off at the end of the last chapter.  We spent a whole chapter creating a web app,
but it was really just seven commands. Here they are all at once:</p>
<code language="session">
$ rails new class_app -T
$ cd class_app
# edit Gemfile to include rspec-rails
$ bundle
$ rails generate rspec:install
$ rails generate scaffold person given_name:string surname:string 
$ rake db:migrate
$ rails server
</code>
<p>In the terminal we can see the log output for our running app. We can interact with the default HTML user interface for viewing and
modifying our <ic>person</ic> objects at <url>http://localhost:3000/people</url>.</p>
<p>We can find the code for the person model that our scaffold generated in app/models/person.rb. Our model is a subclass of <class>ActiveRecord::Base</class> and does not declare the specific attributes that
are in its associated <ic>people</ic> table:  </p>
<code file="code/class_app_new/00_person_scaffold/app/models/person.rb"/>
<p>The class is declared but there isn’t any code in it. We were able to create
people records by entering names into our application’s web interface. How did we get a functional
web app with no code in the <class>Person</class> class?</p>
<p>ActiveRecord constructs attributes for us without any coding on our part.
Our <class>Person</class> class inherits behavior from <class>ActiveRecord::Base</class> that
dynamically determines what attributes it has by looking at the database structure at runtime. Later we’ll dive into how that database structure was created.  For now, let’s experiment with model objects and get a feel for how they work.</p>

<p>The Rails console is the perfect tool to begin our exploration of how ActiveRecord works. In this chapter, we'll access <class>Active
Record::Base</class> methods interactively through our <class>Person</class> class. Once we understand ActiveRecord,
we’ll learn to test-drive our model development in the next chapter.  With a firm foundation in the core ActiveRecord
APIs, we will have the confidence to test-drive our code’s unique behavior and not worry about
the built-in functionality, which is already tested by Rails itself.</p>

<sect1 id="sec.explore-active-record">
<title>Interacting with ActiveRecord in the Rails Console</title>
<p>The <commandname>rails console</commandname> command runs irb, which we explored while learning Ruby, and it also
loads our Rails application environment.  We will have access to the
same classes that are available in our Rails application code. In the last chapter, we used
<commandname>dbconsole</commandname> to evaluate
SQL and talk to the database directly.  The Rails console is a completely different command-line tool, which lets us interact with our database only indirectly by evaluating Ruby.  </p>
<p>Let’s launch the console by executing the following command inside the <ic>class app</ic> application main directory:  </p>
<code language="session">
$ rails console
</code>
<p>As a shortcut we can instead type:</p>
<code language="session">
$ rails c
</code>
<p>Our model class is available in the console without having to <ic>require</ic> the file. Here we can see that Rails
is Ruby and we can create a Person object, just like any Ruby class:</p>
<code language="irb">
> p = Person.new
=> #<Person id: nil, given_name: nil, surname: nil, created_at: nil,
updated_at: nil> 
</code>
<p>Let's take a look at the return value of <ic>Person.new</ic>.  It displays the attributes of our newly created person (id, given_name, surname, created_at, updated_at).  If we think back to when we were making new <class>Person</class> objects in <ref linkend="ch.ruby-intro"/>, We will remember that the return of <ic>Person.new</ic> did not include the object's attributes. So what changed?  The answer is that the Rails ActiveRecord::Base class
overrides the built-in <method>inspect</method> method to give us extra data about its attributes.</p>

<p>Now that we have an instance of our <class>Person</class> class to play with, we can see how ActiveRecord provides methods that write directly to the database without our needing to write any SQL:</p>
<code language="irb">
ruby-1.9.2-p0 > p = Person.new(:given_name => "Adele", :surname => "Goldstein")
 => #<Person id: nil, given_name: "Adele", surname: "Goldstein", created_at: 
 nil, updated_at: nil> 
ruby-1.9.2-p0 > p.save
</code>
<p>After calling <method>save</method> on our new <class>Person</class> object, we have
actually written data to our SQL database. We can browse to <url>http://localhost:3000/people</url> and see Adele Goldstein
in our list of people.</p>
<sect2>
<title>Understanding SQL Called by ActiveRecord</title>
</sect2>
<p>To better understand how ActiveRecord works and which methods talk to the database directly using SQL, we can look at
SQL queries as they are logged by Rails.  </p>
<p>
We’ll use built-in Rails logging as a diagnostic tool to allow us to see the SQL commands from the log interleaved
interactively with our Ruby code. This technique is very helpful when
  first getting a feel for how ActiveRecord works and sometimes for debugging. </p>
<p>If any part of
ActiveRecord has already been accessed this won’t work. We must do this at the very beginning of a <commandname>rails console</commandname> session. </p>
<code language="session">
$ rails c
Loading development environment (Rails 3.0.1)
>> ActiveRecord::Base.logger = Logger.new(STDOUT)
</code>
<p>
The ActiveRecord class <ic>logger</ic> attribute references another class for logging debug
info, errors and warnings.  The <class>Logger</class> class is part of Rails and when Rails starts up, by
default, it will create a logger and pass it a file named for the environment we’re running in the
<dir>log</dir> directory.  Since we’re running in development mode by default, you would normally look at the
log file with the command <ic>tail -f log/development.log</ic>; however, we’re going to use STDOUT which is a Ruby
constant referencing an output stream for the console or terminal where we are running Ruby.  This will echo all of
the log output right where we can see it.</p>
<p>Let’s start by creating another instance of the <class>Person</class> class:</p>
<code language="irb">
>> bret = Person.new
</code>
<p>This is just an in-memory representation of a <class>Person</class> object.
  All of the columns in the people database table are available as attributes of the instance, which is just shorthand
  for saying that there is a getter and a setter for each column in the database:</p>
<code language="irb">
>> bret.given_name = "Bret"
>> bret.surname = "Smith"
>> bret
=> #<Person id: nil, given_name: "Bret", surname: "Smith", present: nil, 
created_at: nil, updated_at: nil> 
</code>
<p>
If we try to access an attribute that is not defined in the people table, Ruby will raise a NoMethodError:</p>
<code language="irb">
>> bret.xxx
NoMethodError: undefined method `xxx' for #<Person:0x0000010290a5d0>
	from .../attribute_methods.rb:364:in `method_missing'
</code>
<p>We commonly use the Ruby hash syntax which we learned about in <ref linkend="ch.rspec-intro"/>. The
<class>ActiveRecord</class>
constructor allows us to supplying a hash of name-value pairs for each attribute
that we want to set:</p>
<code language="irb">
>> may = Person.new(:given_name => "May", :surname => "Fong") 
 => #<Person id: nil, given_name: "May", surname: "Fong", present: nil, 
created_at: nil, updated_at: nil> 
</code>
<p></p>
<p> We can see that
the id is <ic>nil</ic>, indicating an unsaved record for the object that we created. Setting attributes on the Ruby object doesn’t commit them to the database. We have just created objects that exist only in-memory. We can also call:</p>
<code language="irb">
>> may.new_record?
=> true
</code>
<p>
<class>ActiveRecord</class> keeps track of whether a model just exists in memory or has been committed to the
database. Let’s save the model now, but this time we are logging to <ic>STDOUT</ic> so we will see the SQL commands too:
</p>
<code language="irb">
>> may.save
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (11.9ms)  INSERT INTO "people" ("created_at", "given_name", "surname", 
  "present", "updated_at") VALUES ('2010-09-06 07:09:18.238744', 'May',
  'Fong', NULL, '2010-09-06 07:09:18.238744')
 => true 
bret.save
</code>

<p><class>ActiveRecord</class> makes the conceptually simple save operation, syntactically simple as well. <class>ActiveRecord</class> generates the
appropriate SQL <ic>INSERT</ic> statement for us.  The <method>save</method> method returns true if the record is successfully saved and false
if there is an error. Now we can see that <method>new_record?</method>  will return false and
  that our <ic>may</ic> object now has values for id, created_at, and updated_at, which were automatically assigned when
  the record was saved.  Of course, the <ic>bret</ic> record can also be saved.  Whether we create an instance of the <class>Person</class> class with attributes passed to the constructor or set them later, the instance will save the current value of that attribute.</p>
<code language="irb">
>> may.new_record?
=> false
>> may
=> #<Person id: 1, given_name: "May", surname: "Fong", present: nil, 
created_at: "2010-09-06 07:09:18", updated_at: "2010-09-06 07:09:18"> 
</code>
<p>
  ActiveRecord also tracks whether any attributes have been modified, so that if we call save again, it won’t actually
  call the database if we haven't modified anything. Since we’re logging to the console, we can see
  that nothing happens when we call save again without setting any attributes:</p>
<code language="irb">
>> may.save
 => true 
</code>

<p>
  We can look at individual attributes to see which ones have changed:</p>
<code language="irb">
>> may.surname 
 => "Fong" 
>> may.surname_changed?
 => false 
>> may.surname = "Woo"
 => "Woo" 
>> may.surname_changed?
 => true 
>> may.changed?
 => true 
>> may.save
  SQL (40.4ms)  UPDATE "people" SET "surname" = 'Woo', 
  "updated_at" = '2010-09-06 07:14:08.497625' WHERE ("people"."id" = 1)
 => true 
</code>

<p>
   When we modify attributes on an existing record and we save our record, <method>save</method> will call the database with an <ic>UPDATE</ic> instead of the <ic>INSERT</ic> that was triggered when we initially saved the new record.</p>
<p>In Rails, there is a shortcut that does both new and save in a single operation:</p>

<code language="irb">
>>john = Person.create(:given_name => "John", :surname => "Woo")
  SQL (0.4ms)  INSERT INTO "people" ("created_at", "given_name", "surname",
  "present", "updated_at") VALUES ('2010-09-06 20:46:13.660208', 'John', 
  'Woo', NULL, '2010-09-06 20:46:13.660208')
 => #<Person id: 3, given_name: "John", surname: "Woo", present: nil,
 created_at: "2010-09-06 20:46:13", updated_at: "2010-09-06 20:46:13"> 
</code>
<p>We can use the <method>create</method> method to set attributes and save the record in one step. Like
  <method>new</method>, it is a method on the class, rather than the instance.</p>

<sect2>
<title>Finding Information in the Database</title>
<p>As with creating, updating, and saving records, if we use the built-in
ActiveRecord methods for finding records, our code will be database independent. We can find records by id, and also
quickly find first, last or all records.  Each of these methods trigger a database SELECT every time they are called. </p>
<dl>
<dt>Person.all</dt>
<dd><p>SELECT * FROM people</p></dd>
<dt>Person.first</dt>
<dd><p>SELECT * FROM people limit 1</p></dd>
<dt>Person.last</dt>
<dd><p>SELECT * FROM ORDER BY id DESC limit 1</p></dd>
</dl>
<p>To get an array of <class>Person</class> objects for all of the data in the database we can call
<ic>Person.all</ic>, but the output in the rails console is a little hard to read:</p>
<code language="session">
>> Person.all
 => [#<Person id: 1, given_name: "May", surname: "Woo", created_at: 
 "2011-01-18 05:25:15", updated_at: "2011-01-18 05:25:15">, #<Person 
 id: 2, given_name: "Bret", surname: "Smith", created_at: 
 "2011-01-18 05:25:29", updated_at: "2011-01-18 05:25:29">, #<Person 
 id: 3, given_name: "John", surname: "Woo", created_at: 
 "2011-01-18 05:25:39", updated_at: "2011-01-18 05:25:39">] 
</code>
<p>To make the output easier to read, we can display it in YAML format by using the handy  <ic>y</ic>
command and passing it the array of <class>Person</class> objects resulting from the ActiveRecord call.  This not
only shows attributes that are generated from the database columns, but also other data for each object, such as the set
of <ic>changed_attributes</ic> and various flags for understanding the state of the object relative to the database:</p>

<code language="session">
>> y Person.all
--- 
- !ruby/object:Person 
  attributes: 
    id: 1
    given_name: May
    surname: Woo
    created_at: 2011-01-18 05:25:15.378022
    updated_at: 2011-01-18 05:25:15.378022
  attributes_cache: {}

  changed_attributes: {}

  destroyed: false
  marked_for_destruction: false
  new_record: false
  previously_changed: {}

  readonly: false
- !ruby/object:Person 
  attributes: 
    id: 2
    …
</code>
<p>Seeing objects as YAML gives all the data for them, which can be very useful for debugging.</p>
</sect2>
<sect2>
<title>Finding Something Specific</title>
<p> The simplest way to find something specific in the database is to call <ic>where</ic> with a hash of attributes to
match:</p>
<code language="session">
>> Person.where(:given_name => "Bret")
  SQL (0.4ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'
  Person Load (0.2ms)  SELECT "people".* FROM "people" 
  WHERE ("people"."given_name" = 'Bret')
 => [#<Person id: 2, given_name: "Bret", surname: 
 "Smith", created_at: "2011-01-18 05:25:29", updated_at: 
 "2011-01-18 05:25:29">] 
</code>
<p>Check out what happens when we look for something with a single quote in it:</p>
<code language="session">
>> Person.where(:surname => "O'Henry")
  Person Load (0.2ms)  SELECT "people".* FROM "people" WHERE
  ("people"."surname" = 'O''Henry')
 => [] 
</code>
<p>Rails automatically applies the appropriate escape characters so that the single quote doesn't cause a SQL
error.</p>
</sect2>
<sect2><title>Beware of SQL Injection Attacks</title>
<p>Improperly escaped user input can cause much more damage than a one-time SQL error: it could potentially wipe out our database. A SQL injection attack is when a malicious person enters text that could evaulate as SQL
commands. Here's an example that shows how the built-in escapting in Rails
protects us:</p>
<code language="session">
>> Person.where(:given_name => "Bret'; DROP TABLE PEOPLE; --")
  Person Load (0.2ms)  SELECT "people".* FROM "people" 
  WHERE ("people"."given_name" = 'Bret''; DROP TABLE PEOPLE; --')
 => []   
</code>
<p>When we specify two name-value pairs in the hash, this is interpreted as an AND operation because that is the most
common.</p>

<code language="session">
>> Person.where(:given_name => 'May', :surname => 'Woo')
  Person Load (0.3ms)  SELECT "people".* FROM "people"
  WHERE ("people"."given_name" = 'May') AND ("people"."surname" = 'Woo')
 => [#<Person id: 1, given_name: "May", surname: "Woo",
created_at: "2011-01-18 05:25:15", updated_at: "2011-01-18 05:25:15">] 
</code>
<p>If we need to do other kinds of operations we need to write a snippet of SQL that will be passed in as the
<ic>WHERE</ic> class of the <ic>SELECT</ic> statements. When writing SQL in our code, it is just as important to escape text
that may have come from an end user. To make our
code invulnerable from a SQL injection attack, we can include a &lquot;?&rquot; anywhere in the string, then pass the
variables to escape and insert as additional parameters:</p>
<code language="irb">
>> first = "May"
 => "May" 
>> last = "Woo"
 => "Woo" 
>> Person.where("given_name = ? AND surname = ?", first, last)
  Person Load (0.2ms)  SELECT "people".* FROM "people" 
  WHERE (given_name = 'May' AND surname = 'Woo')
 => [#<Person id: 1, given_name: "May", surname: "Woo", created_at: 
 "2011-01-18 05:25:15", updated_at: "2011-01-18 05:25:15">] 
</code>
<p>Also, when writing raw SQL, we need to be careful to avoid
database-specific SQL commands or be aware that we are introducing a dependency on our specific database. Most of the
time, we can just use the hash syntax and let Rails worry about the details of the database implementation.</p>
</sect2>
<sect2>
<title>Chaining Methods to Create Complex Queries</title>
<p>We’ve been looking at the results of <method>where</method> right away, but ActiveRecord allows us to defer
executing SQL, so we can build complex queries with multiple Ruby method calls. The
<method>where</method> method along with other modifiers (such as
order, limit, etc.) returns an <class>ActiveRecord::Relation</class>
object.  The SQL query is not actually performed until the result is required – typically when an enumerable method,
such as <method>each</method> is called on the result or when looking as a specific record in irb or by calling
<method>first</method>, <method>last</method>, and <method>all</method>. </p>
<p>For example, we could find everyone with the surname “Woo” and sort the records by “given_name.” Even though these
are two method calls, there will be only one SQL query:</p>
<code language="session">
  Person.where(:surname => "Woo").order(:given_name)
</code>
<p>In the next example we select just one record. A single SQL query which returns a single record from the database: </p>
<code language="session">
  Person.where(:surname => "Woo").order(:given_name).limit(1)
</code>
<p>Order may be called with a string or a symbol for the same result:</p>
<code language="session">
  Person.order("given_name")
</code>
<p>We may optionally specify ASC or DESC when calling order:</p>
<code language="session">
  Person.order("surname DESC").limit(2)
</code>
<p>The ActiveRecord query methods may be called in any sequence:</p>
<code language="session">
  Person.order("given_name").where(:surname => "Woo")
</code>
 
 <p>For more on detail on ActiveRecord queries, you should read the very good Rails
 Guide<footnote><p>http://guides.rubyonrails.org/active_record_querying.html</p></footnote>.</p>

<joeasks id="sb.sidebar.irb_queries">
<title>How can I experiment with combining SQL Queries in irb?</title>
<p>
The ActiveRecord query language returns an ActiveRecord::Relation object, but when we set the ActiveRecord
logger to STDOUT we can see that the query is executed in irb.</p>
<code language="irb">
>> result = Person.where(:given_name => "May")
  Person Load (0.3ms)  SELECT "people".* FROM "people" 
  WHERE ("people"."given_name" = 'May')
 => [#<Person id: 1, given_name: "May", surname: "Woo", present: nil, 
 created_at: "2010-09-06 07:09:18", updated_at: "2010-09-06 07:14:08">] 
</code>
<p>Irb always calls the <method>inspect</method> method on whatever is returned and then prints that to the console.  Inspect will trigger ActiveRelation to execute its SQL query so that it can report the results.  To see this, let’s try:</p>
<code language="irb">
>> result = Person.where(:given_name => "May"); nil
 => nil 
>> result.class
 => ActiveRecord::Relation 
>> result.limit(1)
  Person Load (0.3ms)  SELECT "people".* FROM "people" WHERE 
  ("people"."given_name" = 'May')
 => [#<Person id: 1, given_name: "May", surname: "Woo", present: nil, 
 created_at: "2010-09-06 07:09:18", updated_at: "2010-09-06 07:14:08">] 
</code>
<p>By adding <ic>; nil</ic> to the end of a line in irb, we avoid causing irb to call the <ic>inspect</ic> method on the
result. This keeps the <class>ActiveRecord::Relation</class> object from calling the database, and allows us to
call <method>limit</method> on the object before evaluating it, and therefore, causing a SQL command to be sent
to the database.</p>
</joeasks>
</sect2>
</sect1>


<sect1>
<title>Using ActiveRecord in Our Web App</title>
<p>
  Now that we have a better understanding of ActiveRecord, let’s look at our application again in the browser.  Start the web app:</p>
<code language="session">
$ rails server
</code>
<p>When we browse to <url>http://localhost:3000/people</url> we see a page like <ref linkend="fig.people_index_with_3_records" /></p>

<figure id="fig.people_index_with_3_records">
  <title>People Index Page</title>
  <imagedata fileref="images/class_app/people_index_with_3_records.png" />
</figure>


<p>
  All of the changes that we made in the database appear in the web application, whether we made changes in Rails console by calling methods on ActiveRecord using interactive Ruby or if we made changes using SQL in dbconsole.  These are just three different ways of looking at and interacting with the same database.</p><p>
  We can click &lquot;New Person&rquot;, not fill in anything, click &lquot;Create Person&rquot; and this default Rails
  application will happily create a completely blank record. However, we typically want to set up some checks to make
  sure people add good data.  Since this is such a common part of web applications, Rails makes this easy.</p>
</sect1>
<sect1 id="sec.validations">  
<title>Validations</title>
<p>ActiveRecord has a lot of built-in behavior around making sure data is what we want it to be. After all, this class
is all about data. Its sole purpose is to create a <emph>model</emph> in code that represents one single row in our
database. ActiveRecord includes a whole swath of validation methods solely devoted to making sure our data is what we want it to
be.</p>
<p>
  For example, we may want to make sure that the given name is provided and allow the surname to be optional.  To do
  this, we can make a simple change to the model.  Let’s open <filename>app/models/person.rb</filename>.  We see that
  the implementation is a simple subclass of <class>ActiveRecord::Base</class>.  All of the behavior that we’ve seen so
  far is built into ActiveRecord.  As we’ve seen the attributes are dynamically discovered from the structure of the
  corresponding database table.  If we want to require specific attributes to be present or in a specific format before
  saving, we add a validation to the model:</p>
<code file="code/class_app_new/01a_active_record/app/models/person.rb"/>
<p>With this change, if we attempt to save a blank record, it fails to save and the error will be reported in the web
interface, with a page like <ref linkend="fig.given_name_cant_be_blank" />.</p>
<figure id="fig.given_name_cant_be_blank">
  <title>Validation Error</title>
  <imagedata fileref="images/class_app/given_name_cant_be_blank.png"  />
</figure>

<p>
  Rails provides a lot of behavior in just one line of code.  To understand exactly what is going on, let’s go back to
  the console. Unlike when we are running Rails as a server, in the console our code doesn’t automatically
  reload.  If you had left the console open in another window, you’ll need to restart the console or use the
  <commandname>reload!</commandname> command to reload the Rails app.</p>
<code language="irb">
>> person = Person.new
 => #<Person id: nil, given_name: nil, surname: nil, present: nil, 
 created_at: nil, updated_at: nil> 
>> person.save
 => false 
</code>
<p>
  The <method>save</method> method now returns false.  We can inspect what failed by looking at the errors on the person object. </p>
<code language="irb">
>> person.errors
=>{:given_name=>["can't be blank"]}
</code>
   <p>We can also test for validation errors without attempting to save.  Calling <ic>valid?</ic> will also set errors if one or more validations fail.</p>
<code language="irb">
>> person.valid?
=> false 
</code>
 <p>
  If a validation fails, the <method>save</method> or <method>create</method> methods will return false.  To save the person object and throw an  exception if
  there is an error, we can call the alternate methods: <method> save!</method> or
  <method>create!</method>. An exclamation point, which most people call “bang,” as the last character of a
  method name is a convention in Rails where the method will raise an exception if it fails.</p>
<code language="irb">
> person.save!
ActiveRecord::RecordInvalid: Validation failed: given name can't be blank
...stack trace follows...
</code>
<p>We can see that the bang version of <method>save!</method> raised an error.</p>
</sect1>
<sect1>
<title>Conquering Our Data</title>
<p>We just learned how to create data, give it a home, and find it when we need it.  We now know about SQL injection and how to keep our data safe.  Validations have given us the tools we need to ensure that we are saving well formed data.</p> 

<p>Now that we have a solid base of ActiveRecord skills, we are ready to begin creating ActiveRecord models test first.</p>
</sect1>
</chapter>
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.activerecord-rspec">
<title>Test Driving Model Development</title>
<p>With a basic understanding of ActiveRecord and validations, let’s use a test-driven approach to
creating model behavior.  In test-driven development, we write the test first, detailing our requirements by example
with an executable specification before we write the code that implements the feature.  We’ll use RSpec, which we
learned about in <ref linkend="ch.rspec-intro"/> for test-driving Ruby code.  RSpec works well for testing Rails as well as Ruby. </p>
<p>When we generated our <class>Person</class> scaffold, the <ic>rspec-rails</ic> gem created a spec for each class that
was generated. In <ref linkend="sec.running-tests"/> we used <commandname>rake spec</commandname> for the first time to
run the generate test files. We deleted the failing and pending specs, so we could learn about testing from a good
starting point. If we run <commandname>rake spec</commandname> again, everything should pass:</p>
<code language="session">
$ rake spec
(in …/code/class_app_new_source)
…/bin/ruby -S bundle exec rspec ./spec/controllers/people_controller_spec.rb
./spec/requests/people_spec.rb ./spec/routing/people_routing_spec.rb ./spec/
views/people/edit.html.erb_spec.rb ./spec/views/people/new.html.erb_spec.rb 
./spec/views/people/show.html.erb_spec.rb
..........................

Finished in 0.34845 seconds
26 examples, 0 failures
</code>
<p>We’ll start by writing fresh specs to learn about test first development. Later we’ll review what RSpec generated, so
we can understand how to test-drive changes to code once we have a good foundation for the RSpec syntax and the test
first workflow.</p>
<sect1>
<title>Writing our First Model Spec</title>
<p>Let’s create a blank model spec using the generator. This will also  create a <dir>spec/models</dir>
directory if we didn’t have one already. Placing our tests in the same file hierarchy as our application files saves effort since
<commandname>rspec-rails</commandname> will automatically set up the correct load paths and make it so we don’t have to explicitly require the model source file.  </p>

<code language="session">
  $ rails generate rspec:model course
      create  spec/models/course_spec.rb  
</code>
<p>Just like when we were using RSpec with Ruby, All spec files end with “_spec.rb” and by convention begin with the lower-case name of the class that is being tested with
words separated by underscores.  So the spec for the <class>Course</class> class, is in the file <filename>course_spec.rb</filename></p>
<p>RSpec generates a file that looks like this:</p>
<code file="code/class_app_new/01a_active_record/spec/models/course_spec.rb"/> 
<p>On line <cref linkend="code.spec_helper"/>, the spec requires <filename>spec_helper</filename> which was created with
the <commandname>rspec:install</commandname> generator and provides Rails-specific configuration for RSpec and our Rails
testing. We can see, on line <cref linkend="code.course_describe"/>, that this spec will test our
<class>Course</class> class, using the same syntax we are familiar with from testing our
<class>Person</class> class in Ruby.</p>
<p>RSpec doesn’t generate actual test code for our model – it doesn’t presume
to know what we want our model to do. Instead it provides a <firstuse>pending</firstuse> note, 
which will remind us that we need to write examples for this spec when we run our test suite. </p>
<p>Let’s write our first example and see how it works. We want our <class>Course</class> to have a title and a description, so we’ll start
by writing an example that creates the model exactly as we expect it to work in its most normal case:</p>
<code file="code/class_app_new/01b_active_record/spec/models/course_spec.rb"/> 
<p>By calling <method>create!</method>, we know that ActiveRecord will raise an exception if it fails to create the
record in the database. As in all test frameworks, RSpec will report a failure if an exception is
raised that is not caught, so we know that if create doesn’t work our test will fail.</p>
<p>We’ve only got one spec, but let’s just use the <commandname>rake spec</commandname> command that runs them all:</p>
<sidebar>
<title>RSpec rake tasks</title>
<p>The rspec-rails gem provides a number of rake tasks.  They are all grouped together in the “spec” namespaces, so we
can easily list them:</p>
<code language="session">
$ rake -T spec
(in /Users/sarah/code/class_app_source)
rake spec              # Run all specs in spec directory (excluding plugin specs)
rake spec:controllers  # Run the code examples in spec/controllers
rake spec:helpers      # Run the code examples in spec/helpers
rake spec:lib          # Run the code examples in spec/lib
rake spec:mailers      # Run the code examples in spec/mailers
rake spec:models       # Run the code examples in spec/models
rake spec:rcov         # Run all specs with rcov
rake spec:requests     # Run the code examples in spec/requests
rake spec:routing      # Run the code examples in spec/routing
rake spec:views        # Run the code examples in spec/views
</code>
</sidebar>

<code language="session">
$ rake spec
(in /Users/sarah/code/class_app_source)
/Users/sarah/.rvm/rubies/ruby-1.9.2-p0/bin/ruby -S bundle exec rspec 
./spec/models/course_spec.rb
/Users/sarah/.rvm/gems/ruby-1.9.2-p0@book/gems/rspec-core-2.5.1/lib
/rspec/core/backward_compatibility.rb:20:in `const_missing': uninitialized 
constant Course (NameError)
	from /Users/sarah/src/tfr/svn/Book/code/class_app_new_source/spec/models
/course_spec.rb:3:in `<top (required)>'
	from /Users/sarah/.rvm/gems/ruby-1.9.2-p0@book/gems/rspec-core-2.5.1/lib
/rspec/core/configuration.rb:386:in `load'
	from /Users/sarah/.rvm/gems/ruby-1.9.2-p0@book/gems/rspec-core-2.5.1/lib
/rspec/core/configuration.rb:386:in `block in load_spec_files'
…long stack trace here…
rake aborted!
ruby -S bundle exec rspec ./spec/models/course_spec.rb failed

(See full trace by running task with --trace)

</code>
<p>Amidst this crazy stack trace, we can see <ic> uninitialized constant Course (NameError)</ic>.  We saw this same kind
of error when we were testing our <class>Person</class> class in <ref linkend="ch.rspec-intro"/>. We know from our
explorations of Ruby that classes are constants, so this error means we’re missing a
<class>Course</class> class. This is exactly what we expect since we haven’t written it yet!</p>
<p>We could just write the class from scratch in a new file, but we want to follow Rails conventions for creating not
only our model class, but also its corresponding database table. The easiest way to do that is with a generator. When we
created our <class>Person</class> model, we used <commandname>generate scaffold</commandname>. Scaffold is a great learning and
prototyping tool, but now that we understand the MVC pattern at a high-level and have a little experience with
<class>ActiveRecord</class>, we’ll follow a more typical workflow of building the model, controller and views step by
step. We’ll create our model with the model generator. By default, the rspec-rails gem will also create a model spec, but since we
are test-driving this code, we need to be sure not to overwrite the spec we just wrote when we generate the model:</p>
<code language="session">
$ rails generate model course title:string description:string
      invoke  active_record
      create    db/migrate/20110416135407_create_courses.rb
      create    app/models/course.rb
      invoke    rspec
    conflict      spec/models/course_spec.rb
    Overwrite …/spec/models/course_spec.rb? (enter "h" for help) [Ynaqdh] n
        skip      spec/models/course_spec.rb
</code>
<p>Now that we’ve created our model class, we believe we’ve resolved our <ic>Uninitialized Constant</ic> error. So let’s
run our spec again:</p>
<code language="session">
sarah:class_app_new_source(01b_active_record)$ rake spec
(in /Users/sarah/src/tfr/svn/Book/code/class_app_new_source)
You have 1 pending migrations:
  20110416135407 CreateCourses
Run "rake db:migrate" to update your database then try again.
</code>
<p>Cool. The <commandname>rake spec</commandname> command reminds us that we need to run our migration before running
our tests. In fact, it does a whole lot more than that.</p>
<sect2>
<title>Understanding <commandname>rake spec</commandname></title>
<p>There are a whole bunch of best practices rolled in this one
command. To see exactly what is going on, we can run <commandname>rake spec</commandname> with the <ic>--trace</ic>
option:</p>
<code language="session">
$ rake spec --trace
(in /Users/sarah/src/tfr/svn/Book/code/class_app_new_source)
** Invoke spec (first_time)
** Invoke db:test:prepare (first_time)
** Invoke db:abort_if_pending_migrations (first_time)
** Invoke environment (first_time)
** Execute environment
** Execute db:abort_if_pending_migrations
** Execute db:test:prepare
** Invoke db:test:load (first_time)
** Invoke db:test:purge (first_time)
** Invoke environment 
** Execute db:test:purge
** Execute db:test:load
** Invoke db:schema:load (first_time)
** Invoke environment 
** Execute db:schema:load
** Execute spec
</code>
<p>When it says <ic>invoke</ic> it is calling a particular rake task, but then it will call its dependencies. To really
see what is happening in what order, check out the <ic>execute</ic> commands. The commands
<commandname>db:test:prepare</commandname> and <commandname>db:test:load</commandname> don’t do
much themselves, aside from setting up the environment and executing another task or two.  We can see from the output that it is
actually executing the following steps:</p>
<ol>
<li><p>
Don’t run the specs if there are pending migrations in the development database:
<commandname>db:abort_if_pending_migrations</commandname>
</p></li>
<li><p>
Drop the test database: <commandname>db:test:purge</commandname>
</p></li>
<li><p>
Load the schema into the test database: <commandname>db:schema:load</commandname> in environment “test”
</p></li>
</ol>
<p>These steps make sure that we are always testing in a clean environment, so we know exactly what we’re testing when
we run our specs.</p>
</sect2>
<p>Now that we understand what’s going on. Let’s call <ic>rake db:migrate</ic> to set up our development database and
then call <ic>rake spec</ic> again:</p>
<code language="session">
$ rake db:migrate
(in …/code/class_app_new_source)
==  CreateCourses: migrating ==================================================
-- create_table(:courses)
   -> 0.0010s
==  CreateCourses: migrated (0.0011s) =========================================

$ rake spec
(in /Users/sarah/src/tfr/svn/Book/code/class_app_new_source)
/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby -S bundle…
...........................

Finished in 0.62362 seconds
27 examples, 0 failures
</code>
<p>Great! We’ve added one more spec to our test suite and they all pass. We’ve confirmed that we generated a model that
matches our expectations. Let’s can step into <ic>rails console</ic> for a quick
look interactively and double-check:</p>

<code language="session">
$ rails c
Loading development environment (Rails 3.0.3)
> c = Course.create!(:title => "Creative Writing",
>     :description => "Learn to write fiction!")
 => #<Course id: 1, title: "Creative Writing", description: "Learn to write..."
</code>

<p>Sometimes, when doing something particularly tricky or using an unfamiliar Ruby class or method, we still test
interactively to get a good feel for how the underlying code works; then, once we have an rspec example for that test
case, we know that we never have to check that behavior again. Also if we forget how some section of my code is supposed to
behave, we can just look at the spec.</p>
</sect1>
<sect1>
<title>Test Driving Validations</title>
<p>We want to make sure our <class>Course</class> model always has a title, just like we validated that our
<class>Person</class> model always had its <ic>given_name</ic> filled in. To write a test for that, we need to think
about what it would be like if our code was already working the way we want it to and then we testing for the correct
behavior. The trick is to do this <emph>before</emph> we’ve written any code to implement that behavior.</p>
<p>Let’s apply what we learned in
<ref linkend="sec.validations"/> when we experimented with our <class>Person</class> model in the console. We can set up
our model with invalid attributes, then call <ic>valid?</ic> and verify that it returns false. When we’re testing we are
always thinking about what effects our code should have and how would we know if it worked or didn’t work. We’re
defining our model API in a very precise way.</p>
<p>The way we would write these expectations in RSpec is:</p>
<code file="code/class_app_new/01c_active_record/spec/models/course_spec.rb" part="title_validation"/> 
<p>Any method that ends in
a “?” like <commandname>valid?</commandname> can be handled specially in RSpec. These methods, called <emph>predicates</emph>, can be used automatically with RSpec in a way that sounds a bit like English.  Above we see that <method>valid?</method> can be tested with <ic>p.should be_valid</ic>.</p>
<p>RSpec provides this for all predicates. If the matcher begins with &lquot;be_&rquot;, RSpec removes the &lquot;be_&rquot;, appends a &lquot;?&rquot;, and
sends the resulting message to the given object.  In fact, RSpec will do the same for <ic>be_a_</ic> or <ic>be_an_</ic> to support some
predicates where the example reads better with an article, such as <ic>should be_an_instance_of</ic> to call
<method>instance_of?</method> or <ic>should be_a_kind_of</ic> which will call <method>kind_of?</method>.</p>
<p>Let’s watch how this example fails by calling <ic>rake spec</ic> again after editing the
<filename>spec/models/course_spec.rb</filename> to include our new example:</p>
<code language="session">
................F...........

Failures:

  1) Course should not be valid if it has no title
     Failure/Error: c.should_not be_valid
       expected valid? to return false, got true
     # ./spec/models/course_spec.rb:11:in `block (2 levels) in <top (required)>'

Finished in 0.41685 seconds
28 examples, 1 failure
</code>
<p>RSpec tells us that we’re checking on the results of <ic>valid?</ic> when we call the <ic>be_valid</ic> Rspec method.
RSpec has a lot of helpful <firstuse>matchers</firstuse> which are special methods that provide more specific
output for verifying specific behavior.</p>
<p>We could have written our example like <ic>c.valid?.should == false</ic>, however that is a little weird to read with the
question mark followed by a dot, and, more importantly, by using more specific RSpec syntax we get a more specific error
when our test fails. If we call <ic>.should</ic> on the result of <ic>c.valid?</ic> then all RSpec knows is that we
expected <keyword>true</keyword> to be <keyword>false</keyword>. When we use more specific matchers, RSpec can tell us better information about the failure.</p>
<sect2>
<title>Adding Tests to Our Existing Person Model</title>
<p>Now that we understand how to use RSpec, we want to go back and add tests for our <class>Person</class> model. It’s
okay to write exploratory code without test-driving it – sometimes we need to do that to really understand what’s
possible; however, to keep our code maintainable and make sure the code matches our requirements we want to put some
specs in place.</p>
<p>To get started, we can generate a spec file:</p>
<code language="session">
$ rails g rspec:model person
      create  spec/models/person_spec.rb
</code>
<p>Edit the file <filename>spec/models/person_spec.rb</filename> so that it has the following contents:  </p>
<code file="code/class_app_new/01d_active_record/spec/models/person_spec.rb"/> 
<p>
We can focus on this one new spec by passing the filename as an option to <ic>rake spec</ic>:</p>

<code language="session">
$ rake spec SPEC="spec/models/person_spec.rb"
..

Finished in 0.04756 seconds
2 examples, 0 failures
</code>

<p>Even though the spec passes, it doesn’t give us confidence since we never saw it fail. In the strictest application
of TDD, we should delete our whole model class and migration, but for now, let’s focus on the additional model code
we’re learning to write. Let’s find our Person model
comment out the validator and see at least one example fail. We can find the source code for our model in
<filename>app/models/person.rb</filename> and comment out the validator:</p>
<code file="code/class_app_new/01e_active_record/app/models/person.rb"/> 
<p>Then when we run the spec, we can see that we get the error we expected:</p>
<code language="session">
$ rake spec SPEC="spec/models/person_spec.rb"
.F

Failures:

  1) Person should not save a record without a name
     Failure/Error: p.should_not be_valid
       expected valid? to return false, got true
     # ./spec/models/person_spec.rb:13:in `block (2 levels) in <top (required)>'

Finished in 0.04394 seconds
2 examples, 1 failure
</code>
<p>Now we can uncomment our validation in the Person model class to make the spec pass. The Rails reference documentation for
validations<footnote><p>http://ar.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html</p></footnote> is
quite good and worth reading to be familiar with the built-in validators.</p>
<p>Rails has a concise, declarative syntax that appears like configuration for validators, but with our knowledge of Ruby
we can see that these are just class method calls. Some people call this the Rails DSL, a <emph>Domain Specific
Language</emph> written in Ruby. Of course, that's just a fancy name for a library of classes with methods that are so
well-named and elegantly structured that they feel like a new language. </p>
</sect2>
</sect1>
<sect1>
<title>Creating Custom Model Behavior</title>
<p> We can add
any behavior that we want to our model class by adding class or instance methods with custom behavior.  Remember
that when we are developing a Rails application, we are writing Ruby code. All of the capabilities of the Ruby language
are available to us within our Rails application. Rails gives us a lot of built-in functionality common to web
applications, but we can use it in powerful and flexible ways because of Ruby.    Your model is just a Ruby class which may be extended in standard ways to have its own methods. It is considered a best practice to add logic to the model when possible, so that you can keep your views and controllers small.  </p><p>
Suppose we commonly refer to people with their full name
  (concatenating given and surname). We want this available elsewhere in the code, we can add a
  <method>full_name</method> method to our model just like we did with our plain old Ruby class when we were learning
  about Ruby. This may seem like a very simple example, but simple, useful methods added to our models can be very
  powerful in keeping our view code clean. Later if we decided to add a middle name, we could just change this one
  method in our model, rather than everywhere in our code. Let’s add this example to the spec for the <ic>Person</ic>
  model by editing spec/models/person_spec.rb:  </p>
<code file="code/class_app_new/01f_active_record/spec/models/person_spec.rb" part="fullname"/>
<p>Then run <ic>rake spec</ic> to see the following error.</p>
<code language="session">
1)
NoMethodError in 'Person should construct a full name'
undefined method `full_name' for #<Person:0x1036ff5f0>
.../lib/active_record/attribute_methods.rb:264:in `method_missing'
./spec/models/person_spec.rb:12:
</code>
<p>You can see that Ruby reports a <ic>NoMethodError</ic>, since we are sending a full_name message to
the person object “p” where there is no method definition (or corresponding table column for ActiveRecord to dynamically evaluate).  To make this example pass, we can simply define a method:</p>
<code file="code/class_app_new/01f_active_record/app/models/person.rb" part="method"/>


<p>
We’ve written specs for validations and a custom model method, only verifying the custom behavior we’ve added to our
model. We can rely on the tests of ActiveRecord in
Rails itself to ensure that the built-in functionality  works.  In our
spec, we focus on what is special in our own app. As much as we can, we want to put behavior in the model, since it is
easiest to isolate the model’s behavior and test it effectively, rather than testing that behavior as it ripple out to
various parts of the application. Understanding
the basics of models, the <emph>M</emph> in the MVC pattern, gives us a firm foundation as we continue to explore Rails.</p>
</sect1>
</chapter>
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.start">
  <title>Before You Start</title>
  
  <p>Before we start coding we want to be sure we have our development set up with all of the tools that we need.  This
  chapter explains what we need on our system to build applications in Ruby on Rails. If
  you have Ruby and Rails installed and want to dive right in, that’s cool. But before skipping this chapter,
  let’s first check that we have the right version of Rails and it is working, by typing <ic>rails -v</ic> on the command line.
  We should see the version printed afterwards.  Throughout this book, we’ll show you command-line output where the
  <ic>$</ic> is our command prompt with what we’re typing after a space on the same line. Then we’ll show you the output
  of the command, like this: <ed>I think you can kind of skip the "we" stuff here - it's ok to talk to the reader direectly - you did that a little bit in this paragraph. If you want them to check the version, that's fine, just tell them how to do it. We want to use "we" when we are actually working through things with our reader, like excercises. So it's not a hard and fast rule that you should always use "we". Clear as mud?</ed></p>
<code language="session">
$ rails -v
Rails 3.0.3
</code>
<p><ed>here too, you've got a mix of we and you. It's probably ok to stick with "you" here. </ed>To get the most out of this book, we should all be using the same version of Rails. Any version that starts with 3.0
is fine (like 3.0.1 or 3.0.3). If you don’t have the right
version or got an error when you tried to run the <commandname>rails</commandname> command, keep reading and we’ll help you
figure it out. Or if you just want to know a bit more about about what Rails sits on top of and nearby, read on! </p>
<sect1>
<title>Rails Dependencies</title> 
<p>In order to understand the various components and sub-systems that work and play with Rails, we’ve split them into a few
categories. First Rails has a few core dependencies -- if you don’t have these installed, Rails just won’t work at all: </p>
<ul>
<li><p>Ruby</p></li>
<li><p>Ruby gems</p></li>
<li><p>Rails</p></li>
</ul>
<p>Also there are a number of other tools and libraries that your application will
likely use and will be part of the book. These aren’t technically required for your Rails app to work, but are important
elements of our toolbox as Rails engineers:<ed>is it really worth talking about these now? How about "Along the way, we'll install other libraries as we work through the book" or something? </ed></p>
<ul>
<li><p>Database</p></li>
<li><p>Terminal or Command Prompt</p></li>
<li><p>Test Framework</p></li>
<li><p>Editor / IDE</p></li>
</ul>
<p>We’ll talk about each of the core dependencies and other components which we’ll need in our toolbox to begin, what
version of each we need to build the app in the book and a bit about what its for.</p>
</sect1>
<sect1>
<title>Core Dependencies</title>
<p>To be able to run the <commandname>rails</commandname> command and build the most minimal application, you will need Ruby and the Ruby Gems packaging manager, and, of course Rails. On Mac and
Linux, we highly recommend installing Ruby and Ruby Gems with
rvm<footnote><p><url>http://rvm.beginrescueend.com/</url></p></footnote>. <ed>windows installer talks about Git. What about git for mac?</ed> On Windows, we can install Ruby, Rails, and Git all at
once with RailsInstaller<footnote><p><url>http://railsinstaller.org/</url></p></footnote>.</p>
<sect2>
<title>Ruby</title>
<p>Great Rails developers are great Ruby developers. Rails is a framework written in the Ruby language.
  <ed>what's missing here? Why are we doing version checking? Is this sentence really needed? Have you said this previously?</ed></p>
<code language="session">
$ ruby -v
ruby 1.9.2p0 (2010-08-18 revision 29036) [x86_64-darwin10.4.0]
</code>
<p>Ruby 1.8.7 or higher is required for Rails 3.  Ruby 1.9.2 or higher is recommended.</p>
</sect2>
<sect2>
<title>Ruby Gems</title>
<p>A gem is a ruby library. Rubyists like to make up cute names for their creations. Jim Weirich was no exception when
he created Ruby Gems.  A gem is a precious bit of Ruby code that some developer has carved out for its usefulness. 
The name <emph>gem</emph> speaks to the Ruby aesthetic that our code should be beautiful and bring us delight as
well as having practical uses. Ruby Gems has a fabulous packaging system that supports having different versions installed
as well as installing native code extensions. We can also easily install libraries from local or remote sources.  To see
what version of Ruby Gems we have installed:
</p>
<code language="session">
$ gem -v
1.3.7
</code>
<p>To see the gems we have installed:</p>
<code language="session">
$ gem list
</code>
<p>To install a new gem</p>
<code language="session">
$ gem install <name>
</code>
<p>on Mac or Linux (without rvm), we need to preface the command with sudo (which will prompt us to enter our admininstrator password):</p>
<code language="session">
$ sudo gem install <name>
</code>
<p>When we’re developing in Rails, we often add gems that offer functionality that is common to many web applications.
Ruby engineers are exuberant in providing open source implementations of any code that is generally useful, creating an
ecosystem of tools that adds to our velocity as Rails engineers.</p>
</sect2>
</sect1>
<sect1>
<title>Gems We’ll Use Directly</title>
<p>Rails depends on a large collection of gems. In fact, Rails itself is split into many gems. Most of these we don’t
need to know anything about; however, there
are two gems that we will interact with directly on the command line: Bundler and Rake.  Bundler and Rake may each be
used with or without Rails and they are installed automatically as dependent gems when we install Rails.</p>
<sect2>
<title>Bundler</title>
<p>Bundler manages gem dependencies. During the development of Rails 3, Rails core team members, Yehuda Katz and Carl
Lerche created Bundler to solve challenges that many Rails development teams faced with previous systems for managing
gem dependencies.  Carl and Yehuda develop all of their code by pair programming, which
explains why we can find the Bundler source under a blend of their two names: <emph>carlhuda</emph> on
github<footnote><p><url>https://github.com/carlhuda/bundler</url></p></footnote>. With prior systems for managing dependencies that Bundler is required for Rails 3, but may be optionally used
by Rails 2 (or any Ruby project).</p>
<p>The <commandname>bundle</commandname> command will install all dependent gems specified in the
<filename>Gemfile</filename> which is kept the root of your app.</p> 
<p>To see a list of the bundler commands:</p>
<code language="session">
$ bundle --help
</code>
<p>Since bundler is a gem, <ed>can you go through and fix all these improper capitalization things like Gem, Ruby, etc? and is it Ruby Gems or RubyGems? I'm not going to mark any more of them up, so please just do a quick sweep of your book.</ed> we can see its version with:</p>
<code language="session">
$ gem list bundler

*** LOCAL GEMS ***

bundler (1.0.0)

</code>
<p>Rails 3 will not use any gem unless it is loaded by Bundler.  Prior versions of Rails would use any gem
installed on our system.  While the Rails 3 restriction might seem inconvenient at first, it is very helpful when we
inevitably deploy our application to a different machine.</p>
</sect2>
<sect2>
<title>Rake</title>
<p>Rake lets us run Ruby scripts with dependencies and manage sets of utility scripts. Created by the prolific Jim
Weirich, Rake is like the unix tool
<commandname>make</commandname> for Ruby. A <emph>rake task</emph> is some Ruby code with some additional annotations
that name the task and, optionally, specify dependencies.</p>
<p>Just like with all gems, we can see its version with:</p>
<code language="session">
$ gem list rake

*** LOCAL GEMS ***

rake (0.8.7)
</code>

<p> We
use many rake tasks routinely in our Rails development and often write our own. Where we might have used a <ic>bash</ic>
script in a Java environment for build automation or data import, with Rails we will typically write a Rake task. We’ll
learn how to write a Rake task in  <ref linkend="ch.rake"/>.<ed>are you going to be using bundle exec in this book?</ed></p>

</sect2>
</sect1>
<sect1>
<title>The Rest of our Toolbox</title>
<p>As Rails developers we will need more in our toolbox than just Rails and its core dependencies. We typically
interact with Rails on the command line, use an IDE or some kind of code editor, a database, source code control and,
since this is Ruby, and we want to make it easy on ourselves, we include one or more test frameworks.</p>
<sect2>
<title>Database</title>
<p>A databse is not strictly required for a web application built with Rails, but most web applications
provide a user interface on a relational database. In this book, we’ll use SQLite since it is easy to install and is
great for experimentation. The Rails code that we will develop will be database-independent, so we can use any of the
supported databases for deployment or continued development.</p>
  
<joeasks>
<title>When would we write a Rails application without a database?</title>
<p><ed>this doesn't read right. The question was "using without a database." not "without a relational database". Also, I don't think this adds much. The part about web services is stronger. But evene more, I'd lose the sentence in the previous section about "while a db is not required" and change the joeasks to "can I use Rails without a database" instead. What do you think?</ed>We can use Rails with a “noSQL” database, such as MongoDB or CouchDB, store our data elsewhere or not store data at all. A common use case for
using Rails without a database would be to connect to web services potentially storing data there or performing a
transaction such as making a purchase or other transaction using an external service.</p>
<p>Using name-value stores and other
non-relational approaches to storing data are increasingly popular for large scale data and cloud hosting. Sometimes,
such as with Google App Engine, we will store and retrieve our data using <class>DataMapper</class> instead of
<class>ActiveRecord</class>; however, many applications use “no SQL” data stores for high volume data that doesn’t require transactions and is not highly relational
in conjunction with a SQL database for core application data. In any case, it is valuable to first understand how to build web
applications that provide a user interface on a relational (SQL) database. </p>
</joeasks>
<sect3 id="sec.sql">
<title>Understanding SQL</title>
<p>We rarely write SQL directly in our Rails code, but to understand what our app is really doing in the
database, we’ll want to occasionally look at the SQL called by our app. If you don’t already know SQL, refer to <ref
linkend="fig.database-commands" /> for a quick cheat sheet of the basic commands.</p>
<figure id="fig.database-commands">
  <title>Database Commands</title>
  <imagedata fileref="images/database-commands.png" />
</figure>
</sect3>
<sect3 id="sec.dbconsole">
<title>The <commandname>dbconsole</commandname> command</title>
<p>One of the Rails commands <ic>rails dbconsole</ic> invokes our database console. Every database comes with a command
line tool which has a unique command to invoke it and sometimes different names for command line options to specify the user, password and database name. The dbconsole command simply calls the appropriate database console app. So for SQLite, rails dbconsole is the same as:</p>
<code language="session">
$ SQLite3 <my_development_database>
</code>
<p>and for MySql, it is the same as:</p>
<code language="session">
$mysql –u<name> –p<password> <my_development_database> 
</code>
<p>The <commandname>dbconsole</commandname> is a very useful tool for inspecting the contents of the database when we
are debugging or want to take a quick look at what tables and schema exist for our app.</p>
</sect3>
<sect3>
<title>Using a Different Database</title>
<p>If you want to use Rails with a different database, there are shortcuts for creating different configuration files for the most commonly used databases. For example, to generate a Rails application with a default configuration for MySql, you would use the following command:</p>
<code language="session">
$ rails new –d mysql app_name
</code>
<p>The contents of the <filename>database.yml</filename> file is the only difference in the generated app when calling “rails new” with the –d option. </p>
<p><ed>probably better if you use a definition list for this especially if it’s a sidebar.</ed></p>
<p>The following databases are supported:</p>
<table style="outerlines">
  <thead>
    <col><p>Database</p></col>
    <col><p>Configuration Option</p></col>
  </thead>
  <row> <col><p>SQLite</p></col><col><p>default</p></col> </row>
  <row> <col><p>MySQL</p></col><col><p>-d mysql</p></col> </row>
  <row> <col><p>PostgreSQL</p></col><col><p>-d postgresql</p></col> </row>
  <row> <col><p>Oracle</p></col><col><p>-d oracle</p></col> </row>
  <row> <col><p>DB2</p></col><col><p>-d ibm_db</p></col> </row>
  <row> <col><p>Frontbase</p></col><col><p>-d frontbase</p></col> </row>
  <row> <col><p>SQL Server</p></col><col><p>manual configuration required</p></col> </row>
  <row> <col><p>Sybase</p></col><col><p>manual configuration required</p></col> </row>
</table>

<p>When we use a different database, we need to install the database-specific driver so that our Ruby code can talk to
the database. Each of the supported databases requires a separate gem to connect to that database from Ruby.</p>
</sect3>
</sect2>
<sect2>
<title>Terminal or Command Prompt</title>
<p><ed>These tooling conventions don't feel right. This is really important stuff that might be better off in the preface. If I see I can skip this chapter, and then get confused cos I don't know what you're talking about with some of these unix commands, I might be lost. I'd move this, and maybe the section on text editors too. What do you think?</ed> Rails development relies heavily on command-line tools. On Mac or Linux, we run these in the <emph>terminal</emph>,
and on Windows, in the <emph>command prompt</emph>. We like running <emph>gitbash</emph> aka
<emph>msysgit</emph><footnote><p><url>http://code.google.com/p/msysgit/</url></p></footnote> on Windows, which is
distributed with git by the helpful folks who create git for Windows. Gitbash allows us to use the same Unix commands for
moving and copying files as we use on Mac and Linux.</p>
<p>Here’s a list of the Unix commands we find that we need to know while we we’re developing web apps: </p>
<dl>
<dt><commandname>cd</commandname></dt>
<dd><p>change directory</p></dd>
<dt><commandname>pwd</commandname></dt>
<dd><p>print working directory, displays the path of the current directory</p></dd>
<dt><commandname>cp</commandname></dt>
<dd><p>copy a file, use it like <ic>cp myfile newfile</ic></p></dd>
<dt><commandname>cp -r</commandname></dt>
<dd><p>copy a directory and all of its contents, use it like <ic>cp -r mydir newdir</ic></p></dd>
<dt><commandname>mv</commandname></dt>
<dd><p>move or rename a file or directory, use it like <ic>mv myfile newfile</ic></p></dd>
</dl>
</sect2>
<sect2>
<title>Editor or IDE</title>
<p>There are a lot of great IDEs that work well for Rails, such as RubyMine, Aptana’s RadRails, TextMate (for the Mac)
and Komodo. Every code editor we’ve tried lately has Ruby syntax highlighting, which is essential for spotting errors
when developing. Additionally, when developing, it is handy to have a project view to see the directory hierarchy, since
when we develop a Rails application, we often switch between files to follow the flow of control or see the test and the
tested code. We highly recommend finding a IDE you love and learning its ins and outs.</p>
</sect2>
<sect2>
<title>Test Frameworks</title>
<p>Ruby has a plethora of test frameworks. Test::Unit, the default option for Rails, was Ruby’s first test framework.
Originally written by Nathaniel Talbot, it is small, fast, and seems to have been largely influenced by JUnit, the unit
testing framework from the Java language. Test::Unit was bundled with Ruby 1.8; however, with 1.9, Ruby moved to
MiniTest.</p>
<p> In this book, we use RSpec, created by David Chelimsky. RSpec grew out of the behavior-driven development movement
and is focused on the idea that when we write our code test first, we are actually writing a specification of our code.
The key advantage of RSpec for both learning and in building production code is the clarity of its output.</p>


<p><ed>duplicate thought? you say this in the previous para. </ed>Throughout this book, we use RSpec, created by David Chelimsky. RSpec grew out of the behavior-driven development movement
and is focused on the idea that when we write our code test first, we are actually writing a specification of our code.
The key advantage of RSpec for both learning and in building production code is the clarity of its output. Like all of
the Ruby test frameworks, RSpec is distributed as a gem. Since we’re building a Rails application, we’ll use the
<commandname>rspec-rails</commandname> gem that includes RSpec and some additional helpers for Rails. Let’s install it now:</p>
<code language="session">
$ gem install rspec-rails
</code>
<p>We also use Capybara, which is also a gem, to install it:</p>
<code language="session">
$ gem install capybara
</code>
<p><ed>This needs some sort of transition to the next topic. Also, I know you think a lot of this stuff really needs to be here, but focus on your reader - how much of the content in this chapter do they really need to know about? Are you trying to pre-emptively handle any questions people might have? There are some things in here, like background information, that is actually very useful. But some other parts just don't seem absolutely essential. I'll leave it up to you, but I suggest you give it a read again and see what you think</ed></p>

</sect2>
</sect1>
</chapter>                                                                                                                    
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.controllers">
  <title>Exploring Routes and Controllers</title>

     <p>When we create a web application, we craft a unified experience from a series of web pages. 
  Sometimes a single interaction takes place across multiple HTTP requests. The Model-View-Controller pattern helps us wrangling these disjoint pages into manageable code.</p>
  <p>In <ref linkend="ch.firstapp"/>, we learned
  about views, how Embedded Ruby templates let us declare the visual part of our web user interface. Then we learned about the model, in  <ref linkend="ch.activerecord"/> and <ref
  linkend="ch.activerecord-rspec"/>.  Now we’ll learn about how routes and
  controllers string our views together, letting us specify the
  interactive part of our user interface.</p><p> As we did with ActiveRecord, we’ll start by exploring interactively,
  but now we can use the browser to see how our code responds. Let’s take another look at the pages
  that scaffold made for our <class>Person</class> model. Making sure we’re in our
  <dir>class_app</dir> directory, we
  type <commandname>rails s</commandname> to run the server. The index page shows a list of people:</p>
  <p><url>http://localhost:3000/people</url></p>
  <p>From there, we can click the “New Person” link to go to a web form to fill in data for a
  new person to add to our database:</p>
  <p><url>http://localhost:3000/people/new</url></p>
  <p>Then when we fill in the name fields and click “Create” to submit the form, which sends an HTTP POST to:
  <ic>http://localhost:3000/people</ic> and then redirects to:</p>  
  <p><url>http://localhost:3000/people/4</url></p>
  <p>The database record was created and then the browser was redirected to display a page that showed the details of
  the person. That’s four HTTP requests and three web pages, but it feels like a unified experience because we’re used
  to interacting with web applications in this way.</p>

    <p>In Rails, a <emph>route</emph> specifies how an incoming URL calls our code. Routes are like street signs that point to destinations.  When someone accesses a URL of a Rails web
    application, Rails uses the routes specified in <filename>config/routes.rb</filename>.  This file
    contains a mapping of each URL to our Ruby code which decides what to do. </p>
<p>When we created our app with <commandname>rails new</commandname> the <filename>routes.rb</filename> file was created with no
routes defined. The routes file looks almost like a configuration file — it is even kept in the config directory;
however, it is
executable Ruby code. At first glance the file seems lengthy because Rails includes some in-line documentation in the
form of comments that show different example routes, but there is really just a single method call with a
configuration block. When we ran the scaffold generator, it modified this file to add
just one <ic>resources</ic> declaration: </p>
<code file="code/class_app_new/00_controllers/config/routes.rb"/>
<p>From that one line, we defined 7 routes which we explored interactively in <ref
linkend="sec.scaffold-rest-mvc"/>.
The <ic>resources</ic> method provides a nice shortcut for defining all of the standard REST routes; however, to use Rails effectively we need to understand what’s really going on. We’ll build a similar set of routes and corresponding controller behavior for our
<class>Course</class> model one step at a time.</p>
<sect1>
<title>Responding to a URL Request</title> 
 
  <p>When we go to <url>http://localhost:3000/people</url>, the browser sends the HTTP
  request <ic>GET /people</ic> to the server running at <ic>localhost</ic> (listening on port 3000). If the server were a plain old web server, it
  would just respond with the contents of the default file in the
  <dir>people</dir> directory, usually
  <filename>index.html</filename>. Our Rails app dynamically
  determines what page to send back to the browser.</p>
<p>We’ll follow an HTTP request from typing an URL into the browser
through a route to learn about the code we need to write to make it work, starting with a page to display a single
<class>Course</class> model. Let’s start by browsing to the URL we haven’t
built yet and see what happens. Let’s point our browser to a new, arbitrary url:
<url>http://localhost:3000/my_course</url>. We see the routing
error shown in <ref linkend="fig.routing-error" />. Go ahead and try it. </p>
<figure id="fig.routing-error">
  <title>We Have Not Yet Specified Where the URL Goes</title>
  <imagedata fileref="images/controllers/routing-error.png"  />
</figure>
<p>This error tells us that the URL <ic>/my_course</ic> is not hooked up to anything. There is no <emph>route</emph> into the app
that matches that string.</p>
<sect2>
<title>Let’s Create a Route</title>
<p>A route maps an external URL to internal code, so the route has two parts. The first is the path section of the URL, the part after the hostname and port, in our example
it’ll just be <ic>my_course</ic>. The second part references what code it calls, which is usually a method of a controller class.
We’ll hook up <url>http://localhost:3000/my_course</url> to the <method>show</method> method of our not yet written
<class>CoursesController</class> class. We’re using the standard Rails naming convention for the controller action that
displays a single record. Later we’ll learn how to implement the standard URL name with a parameter, but we’ll focus first on how a very simple
route works.
Let’s comment out the <ic>resources</ic> line so we can focus on our new
route:</p>
<code file="code/class_app_new/01_controllers/config/routes.rb"/>
<joeasks>
<title>How does the Match Method Work?</title>
<p>Let’s learn a little more Ruby to understand how the match method works.</p>
<code language="irb">
$ rails c
> result = "courses#show".split('#')                        
 => ["courses", "show"] 
> controller_name = result[0].camelize + "Controller"
 => "CoursesController" 
</code>
<p>First we call <method>split</method>, which is a Ruby <class>String</class> method, to get the two components. Then
we took the first component and call <method>camelize</method> which is a <emph>Rails</emph> <class>String</class> method. Rails
adds a lot of useful methods to the core Ruby classes. </p>
</joeasks>

<p>The routes syntax is chock full of shortcuts, so it looks more like a config file than source code. Remembering our Ruby syntax, we can see that it is actually calling the <ic>match</ic> method
and passing it a <ic>Hash</ic> parameter that has a single key-value pair with <ic>"my_course"</ic> as the key and
<ic>"courses#show"</ic> as the value.</p>
<p>Rails applies a
naming convention that many programmers already know — the Rails routing
syntax of “class#method” is also used in Ruby’s RDoc and ri documentation tools, as well as
Javadocs and documentation tools for other languages.  So, <ic>courses#show</ic> means
that we’ll be creating a <class>CoursesController</class> with a <method>show</method> method to be called when someone browses to
<ic>/my_course</ic>.</p>
<sect3>
<title>Routes Automatically Define Methods</title>
<p>In addition to defining as entry point for our app and referring to a controller method,  we automatically get methods that we can call from our
controller or views based on the names in the path. Let’s run <commandname>rake routes</commandname> to interactively inspect how our route is set up:</p>
<code language="session">
$ rake routes
my_course  /my_course(.:format) {:action=>"show", :controller=>"courses"}
</code>
<p>This little diagnostic script<footnote><p><commandname>rake routes</commandname> was added to Rails in 2007 by Josh Susser, inspired by Rick
Olson’s routing navigator plugin which was turned in a rake task by Chris Wanstrath, founder of github.com.
<url>http://blog.hasmanythrough.com/2007/7/3/check-out-your-routes</url>. If you find yourself wanting a debugging tool,
you might consider experimenting in Ruby, making something useful and adding it to Rails yourself.</p></footnote> originally shows some of the built-in features along with the controller and
action names that we specified explicitly. As part of the URL, we can see the <ic>:format</ic> option.
By default, a request will be assumed to be of <ic>html</ic> format, but this request will respond to <ic>/my_course.html</ic>
explicity or an alternate format like <ic>/my_course.xml</ic> or <ic>/my_course.txt</ic>. Our controller action can provide alternate behavior,
based on the format of the request.</p>
<p>At the beginning of the line is an internal method name that has been defined for us — actually it’s just part
of a method name. The command <commandname>rake routes</commandname> prints <ic>my_course</ic>,
but there are actually two methods <ic>my_course_path</ic> and <ic>my_course_url</ic>. Let’s hop into <commandname>rails
console</commandname>
and check that out:</p>
<code language="irb">
$ rails c
Loading development environment (Rails 3.0.1)
>> app.my_course_path
 => "/my_course" 
>> app.my_course_url
 => "http://www.example.com/my_course" 
</code>
<p> In <commandname>rails console</commandname> we use the <ic>app</ic> object to call these helper methods
interactively, but we can call them directly in our views and controllers.</p>
</sect3>
<p>We can change the name of the method by annotating the route. In our case, we’re using a non-standard name for the
route to our show page, so let’s annotate it with the standard path “course” which is just the model name:</p>
<code file="code/class_app_new/02_controllers/config/routes.rb"/>
<p>We can see the change when we call <commandname>rake routes</commandname>:</p>
<code language="session">
$ rake routes
course  /my_course(.:format) {:action=>"show", :controller=>"courses"}
</code>
<p>By using a standard name, we can now use another Rails URL helper that is built to help us
manage a <emph>resource</emph>, which just means that we can think about and interact with a model rather than
remembering the specific URLs that we’ve set up for it.  Check this out:</p>
<code language="irb">
$ rails c
Loading development environment (Rails 3.0.3)
>> c = Course.first
 => #<Course id: 1, title: "Creative Writing", description: "Learn to write…
>> app.url_for(c)
 => "http://www.example.com/my_course.1" 
</code>
<p>We can call <ic>app.url_for</ic> with a model and it automatically plucks the id from the model and creates a path
from the route that maps to the name of the model. We haven’t yet told it how we want to accept the id as a parameter,
so it just tacks it on the end. When we learn more about where routes lead to and to work with parameters,
we’ll come back and fix up our route.</p>

<figure id="fig.missing-courses-controller">
  <title>We Have a Route but no Controller</title>
  <imagedata fileref="images/controllers/missing-courses-controller.png" />
</figure>

<p>When we refresh our browser, we see the error shown
in <ref linkend="fig.missing-courses-controller"/>: <ic>uninitialized constant CoursesController</ic>. We know that
classes are constants in Ruby, so when the <class>CoursesController</class> can’t be found, we
get a general error that the <emph>constant</emph> is not initialized. Ruby is actually telling us that we have not yet defined
a <class>CoursesController</class> class.</p>
</sect2>
</sect1>
<sect1>
<title>Creating our First Controller</title>
  <p> We put code that connects one web page to the next in the controller, defining the flow of our application. The controller is like a policeman directing traffic across an intersection.  It receives HTTP requests and decides
  what to do with them. People in the right turn lane should be waved right.  Those in the left turn lane should be
  waved left.  The cop knows where to wave the cars based on which lane they arrive in, but also might make exceptions
  to direct trucks to the larger street or cars to the side in the case of an emergency.</p>
  <p>If we think about what we created with scaffold, we have a <class>PeopleController</class> class with a <method>create</method> method
  which redirects to the <method>show</method> page if the <class>Person</class> was successfully
  created, but renders the <ic>new</ic> view if validation failed and the data in
  the form needs to be corrected and re-submmitted. That small amount of direction is at the heart of a controller
  action – one destination for success and a
  different destination for failure. Many controller actions aren’t even that complex and just handle setting up data
  to render a single page.</p>
  <p>Our first controller method for the <ic>show</ic> action will be a simple one with no conditional logic that
  renders a single page. We’ll be displaying a single course by applying what learned about ActiveRecord along with our
  Ruby coding skills to fetch our model and then display its data.  We’ll start with the basics by rendering a dynamic view.</p>
<p>First to fix our latest error, we’ll use the <commandname>rails generate</commandname> script to create a controller. We use the short form of the
controller name, <ic>courses</ic>, to
create our <class>CoursesController</class> class:</p>
<code language="session">
$ rails generate controller courses
      create  app/controllers/courses_controller.rb
      invoke  erb
      create    app/views/courses
      invoke  rspec
      create    spec/controllers/courses_controller_spec.rb
      invoke  helper
      create    app/helpers/courses_helper.rb
      invoke    rspec
      create      spec/helpers/courses_helper_spec.rb
</code>
<p>The generator creates a controller and a <emph>helper</emph> along with a directory for the views and corresponding
tests.  Rails generates not only the controller, but the other files and directories we will usually need: a directory
for our views and a helper module where we keep code shared by our controller and views. Our focus right now is on the
  controller, since the error we needed to resolve is about a missing <class>CoursesController</class>. By
  defining the controller class in <filename>app/controllers/courses_controller.rb</filename>, we have addressed the
  error.</p>
  <p>When we refresh the browser at
<url>http://localhost:3000/my_course</url>, we see an “Unknown Action” error shown in <ref linkend="fig.unknown-action" />.
The error reports that “the action ‘show’ could not be found.”</p>
<figure id="fig.unknown-action">
  <title>We need to define a Controller action</title>
  <imagedata fileref="images/controllers/unknown-action.png" />
</figure>

</sect1>

<sect1>
<title>What’s a Controller Action?</title>
<p>A controller action may take several forms:</p>
<ul>
<li><p>a view template, implemented with EmbeddedRuBy (ERB)</p></li>
<li><p>a controller method that sets up instance variables for a default view template</p></li>
<li><p>a controller method that explicitly calls <method>render</method> or <method>redirect</method></p></li>
</ul>
<p>We’ll start with the simplest controller action by creating a view template with no additional code in our
controller class.</p> 
</sect1>
<sect1>
<title>Creating a View Template</title>
<p>Rails expects view templates for
the <class>CoursesController</class> to be found in the <dir>/app/views/courses</dir> directory. 
This directory was created when we generated the <class>CoursesController</class>. The views are visual
presentation of the human interface to our application, and like URLs, are kept separate from the code in our controller
which will determine the interaction that happens when someone clicks a link or a button.</p>
<p>When Rails matches a route, it will look
for a file with name of the action and “.html.erb” appended.  For the route <ic>courses#show</ic> we’ll create a file
  <filename>/app/views/courses/show.html.erb</filename> with some basic html, such as:</p>
<code file="code/class_app_new/01_controllers/app/views/courses/show.html.erb"/>
<p>Now when we point our browser to: <url>http://localhost:3000/my_course</url> we see &lquot;Here I am!&rquot; in large text as shown in <ref linkend="fig.here-i-am" />. 
</p>
<figure id="fig.here-i-am">
  <title>A simple view</title>
  <imagedata fileref="images/controllers/here-i-am.png"  />
</figure>
<p>Let’s take another look at the Rails log, which is output in the terminal window where we are running <ic>rails
server</ic>. We can now understand what is happening in the text that is spewed out for every request:</p>
<code language="session">
Started GET "/my_course" for 127.0.0.1 at 2011-05-01 15:12:40 -0700
  Processing by CoursesController#show as HTML
Rendered courses/show.html.erb within layouts/application (59.7ms)
Completed 200 OK in 100ms (Views: 99.3ms | ActiveRecord: 0.0ms)
</code>

<p>The server received a <ic>GET</ic> request for <ic>/my_course</ic> which was then processed by the
<class>CoursesController</class> <ic>show</ic> action rendering <ic>courses/show.html.erb</ic> as HTML. When
starting with a new framework, it is easy to let our eyes glaze over as pages of unfamiliar text scroll by, but if we
pay close attention to what the log output looks like normally, it helps us track down what is going on the first time
that our app starts doing something unexpected.</p>
<p>Whew! We wrote a <emph>route</emph> and created a <emph>controller</emph> and saw how Rails automatically called a
<emph>view template</emph> with the same name as the controller action without our needing to write any code in the
controller. That’s pretty cool, but at the moment we have nothing more exciting than we would have with a plain old web page
hosted on a plain old web site. But wait! We have everything in place to write some code for some dynamic content. The
file we made isn’t just a plain old html file, it’s called a view template because we  can add <emph>embedded
Ruby</emph> code to create a different presentation depending on circumstance.</p>
<sect2>
<title>Accepting Parameters in Our View</title>
<p>Let’s look at the parameters that are already built into Rails. These parameters are available to us in a <class>Hash</class> called <ic>params</ic>, which is
accessible from our view or our controller. We usually don’t access parameters directly in our view, but sometimes doing
so is handy for debugging. For now, let’s explore by displaying them in html. We’ll use Ruby in our view to iterate over
the <ic>params Hash</ic> and display each key-value pair:</p>
<code file="code/class_app_new/02_controllers/app/views/courses/show.html.erb"/>
<p>We can see in <ref linkend="fig.params" /> that the controller and action names are passed as parameters. URL query
arguments are passed the same way. In HTTP we can pass name-value pairs as part of the URL like
<url>http://localhost:3000/my_course.html?id=4</url>. These are parsed by Rails and turned into a
<class>Hash</class>, which we can see in the log:</p>
<code language="session">
Started GET "/my_course.html?id=4" for 127.0.0.1 at 2011-05-01 17:52:43 -0700
  Processing by CoursesController#show as HTML
  Parameters: {"id"=>"4"}
Rendered courses/show.html.erb within layouts/application (1.7ms)
Completed 200 OK in 5ms (Views: 5.0ms | ActiveRecord: 0.0ms)
</code>
<p>The log only shows the parameters that come from the browser. Any query argument we add to the URL will be added to
the <ic>params Hash</ic> along with the internal parameters of controller and action name. Try
it. <ref linkend="fig.params-query" /> shows an example with the query arguments <ic>foo=bar&amp;num=1</ic> but they
could, of course, be anything.</p>
<figure id="fig.params">
  <title>Default parameters</title>
  <imagedata fileref="images/controllers/params.png"  />
</figure>
<figure id="fig.params-query">
  <title>Query arguments foo=bar&amp;num=1</title>
  <imagedata fileref="images/controllers/params-query.png"  />
</figure>

</sect2>
<sect2>
<title>Parsing View Parameters from the URL String</title>
<p>These days it is common to use part of the URL to parameterize the view, largely because search engines will ignore
everything after the <ic>?</ic> in a URL and only index a single page, but also because plain URLs are easier to read
when people bookmark them. Rails gives us tremendous flexibility with how we define URLs and map them to our code. This is easy to do in Rails. We just specify
a symbol as part of the URL pattern in our routes and that is automatically parsed and assigned a value in the <ic>params
Hash</ic>. In fact we’ve already seen this with the format extension, as shown in <ref linkend="fig.params-with-format" /></p>
<figure id="fig.params-with-format">
  <title>Default parameters with format in URL</title>
  <imagedata fileref="images/controllers/params-with-format.png"  />
</figure>
<p>Now that we understand how URL parameters work, as well as custom routes, let’s change our route to use the standard
naming convention for a show page. The URL would be <ic>/courses/4</ic> to display the detailed data of a <class>Course</class>
with id 4. We can just make up any name we want, preface it with a colon (:), put it in the route and it will be added
to the <ic>params Hash</ic>. We’ll just use the name “id” because that’s what it is, and unsurprisingly, it matches the
Rails the naming convention.</p>
<code file="code/class_app_new/03_controllers/config/routes.rb"/>
<p>In <commandname>rake routes</commandname>, we can see that the invisible default format param is still there, even if
we specify other params in the URL:</p>
<code language="session">
$ rake routes
course  /courses/:id(.:format) {:controller=>"courses", :action=>"show"}
</code>
<p>We can look in <commandname>rails console</commandname> to see that <ic>url_for</ic> will now return a standard URL:</p>
<code language="irb">
$ rails c
Loading development environment (Rails 3.0.3)
>> c = Course.first
 => #<Course id: 1, title: "Creative Writing", description: "Learn to write…
>> app.url_for(c)
 => "http://www.example.com/courses/1" 
</code>
<p>Later we’ll use <ic>url_for</ic> in our views to link to pages without embedding literal strings which makes our code
harder to maintain.</p>
<p>We’ve learned about routes and how they pass information to views and controllers through the <ic>params Hash</ic> using old fashioned query arguments
as well as new-fangled parameterized URLs. We created a controller, which was
required to route a URL to a view, but we haven’t written any code for a controller yet. We’re now using standard naming
for our <class>Course</class> “show” page, but we have not yet implemented the standard behavior of displaying the model
  data in the show page. We want to keep our view code lean and focused on pure visual layout as much as possible, so
  we’ll put the next bit of code into a controller method.</p>
</sect2>
<sect2>
<title>How do Controller Methods fit in?</title>
<p>Now that we understand routes fairly well, let’s take a look at our controller in <filename>app/controllers/messages_controller.rb</filename>:</p>
<code file="code/class_app_new/03_controllers/app/controllers/courses_controller.rb"/>
<p>We can see there is no code in our subclass of ApplicationController.  So far we’ve been relying on the built-in
Rails behavior where the controller will render the html template with the same name as our action. To see how it works,
let’s use the Rails logger to make an instance method of the same name that just prints out
something we can easily see:</p>
<code file="code/class_app_new/05_controllers/app/controllers/courses_controller.rb"/>
<p>and also add some output when the view is rendered, and we can remove the displaying of params now:</p>
<code file="code/class_app_new/05_controllers/app/views/courses/show.html.erb"/>
<p>Then when we browse to <url>http://localhost:3000/courses/4</url>, we can see the output of <ic>Rails.logger</ic> in
our terminal window. <ic>Rails.logger</ic> does not affect the HTML that is rendered in the view.</p>
<sidebar>
<title>Why use Rails.logger instead of puts?</title>
<p>When we first experimented with Ruby code, we sometimes used <method>puts</method> to see what was going on outside
our program. Let’s see what happens to the output if we use <method>puts</method> instead of <ic>Rails.logger</ic>:</p>
<code language="session">
==================> show method
------------------------> show view


Started GET "/courses/4" for 127.0.0.1 at 2011-05-01 19:15:42 -0700
  Processing by CoursesController#show as HTML
  Parameters: {"id"=>"4"}
Rendered courses/show.html.erb within layouts/application (1.8ms)
Completed 200 OK in 8ms (Views: 6.6ms | ActiveRecord: 0.0ms)
</code>
<p>The server log looks out of sequence here.  The output of the show method happens before the view, but it
appears that the <ic>GET</ic> request started <emph>after</emph> the method and view were called. How could this be? This happens because the Rails
logger saves up its data and writes it once when it completes the HTTP response. Both the <method>puts</method>
method and the Rails logger are printing to the terminal window.</p>
<p>The controller method is called first and then the view is rendered and our statements are
interspersed in the sequence we expect with the built-in logger info. There are various logger methods which correspond
to level <emph>levels</emph>. The output
methods in order of level are: <ic>debug</ic>, <ic>info</ic>, <ic>warn</ic>, <ic>error</ic>, and <ic>fatal</ic>.</p>
<p> By default, Rails will log all levels in every environment except production, where
<ic>info</ic> and higher is logged.  We can set the log level in the environment-specific config files.  Usually we’ll
just leave the log levels as the defaults. In
<dir>app/environments/production.rb</dir>, Rails provides a handy comment <ic>config.log_level = :debug</ic>
which we occasionally turn on in the rare case that we need to debug an issue in production.</p>
</sidebar>
<p>The controller <method>show</method> happens before the view is rendered:</p>
<code language="session">
Started GET "/courses/4" for 127.0.0.1 at 2011-05-01 19:20:56 -0700
  Processing by CoursesController#show as HTML
  Parameters: {"id"=>"4"}
==================> show method!
------------------------> show view!
Rendered courses/show.html.erb within layouts/application (1.6ms)
Completed 200 OK in 5ms (Views: 5.1ms | ActiveRecord: 0.0ms)
</code>
<p>Our controller method gets called before our view is rendered, letting us handle the interaction logic of
what to show to the person using our web app.</p>
</sect2>
</sect1>
<sect1>
<title>Writing a Controller Method</title>
<p>Our controller method decides what to do in response to an HTTP request, usually it renders a view, but it can respond
with an HTTP redirect which will cause the browser to request another URL and the cycle will start all over again.  If a
controller method does not explicitly render a view or redirect, then the implicit behavior, as we saw with
<method>show</method>, is for the
Controller to render a view of the same name. Our controller method is the right place to set up data for our
view. Let’s experiment a bit in Rails console to get a better feel for the Ruby code we’ll need to write.</p>

<p>If our <ic>show</ic> method is called from <ic>/courses/1</ic>, then we’ll want to display the data for the record
with id 1:</p>
<code language="irb">
$ rails c
Loading development environment (Rails 3.0.1)
>> Course.find(1)
 => #<Course id: 1, title: "Creative Writing", description: "Learn to write…
</code>
<p>The id arrives inside our controller as <ic>params</ic>. We saw before that <ic>params</ic> is a <class>Hash</class>.
Is is actually a special subclass of <class>Hash</class>, called <class>HashWithIndifferentAccess</class> that allows us
to treat hash keys the same whether they are a string or a symbol. This is helpful since they key-value pairs of HTTP
query arguments are always strings, yet it is more efficient in Ruby to use symbols. In <ic>rails console</ic>, we can
see this in action:</p>
<code language="irb">
$ rails c
Loading development environment (Rails 3.0.1)
>> params = {}
 => {} 
>> params["id"] = "4"
 => "4" 
>> params[:id]
 => nil 
>> params = HashWithIndifferentAccess.new
 => {} 
>> params["id"] = "4"
 => "4"  
>> params[:id]
 => "4" 
</code>
<p>Now we know that we’ll be able to find the data we want using the <class>ActiveRecord</class> method
<method>find</method> and pass it the id from the query args:</p>
<code language="irb">
>> Course.find(params[:id])
 => #<Course id: 1, title: "Creative Writing", description: "Learn to write…
</code>
<p>To allow us to pass data to the view, Rails sets up another shortcut: whatever instance variables we set in the
controller are then available to us in the view.</p>
<code file="code/class_app_new/06_controllers/app/controllers/courses_controller.rb"/>
<p>The return value of the method is ignored. We’re not seeing exactly how views are created because Rails does that
internally. Part of the strength of the MVC pattern is to keep separate parts of our implementation in separate classes.
When the view is rendered we’re in a completely different context, so we need to specify which data we want sent to the
view and Rails implements this data passing with instance variables that we define in our controller method and can
later access in our view.</p>
<code file="code/class_app_new/06_controllers/app/views/courses/show.html.erb"/>
<p>After our <method>show</method> controller method executes, the
<class>ActionController</class> superclass looks through its own instance variables to see which ones have been added. It then
copies them into a <class>Hash</class> which the view uses to set its own instance variables.  This temporary
storage is called <ic>assigns</ic>, which we’ll use when we’re testing.</p>

<joeasks>
<title>Aren’t instance variables private?</title>
<p>The way that Rails passes data via instance variables between controller and a view is concise, but makes it seem
like instance variables aren’t really private. The view, which exists in the context of an entirely
different class <class>ActionView</class>, seems to have access
to the private instance variables of the controller. However, in reality, the view doesn’t directly access to the controller
instance variables. Whew, isn’t that a relief?  </p>
<p>In Ruby, instance variables <emph>are private</emph> to an instance of a class. This is no different inside of Rails.
However, in Ruby we can get a list of our instance variables and see what they are. Check this out inside of irb:</p>
<code language="irb">
$ irb
>> instance_variables
 => [:@prompt] 
>> old = instance_variables
 => [:@prompt] 
>> @foo = 1
 => 1 
>> @bar = "something"
 => "something" 
>> instance_variables
 => [:@prompt, :@foo, :@bar] 
>> new = instance_variables - old
 => [:@foo, :@bar] 
</code>
<p>With the model and view, Rails appears to mix together two separate
concern, but it is merely an unusual message passing convention.</p>
</joeasks>

<p>Through exploration in the browser and Rails console, we have worked through the creation of a route, controller
method and a corresponding view. We’ve learned a few variations on the <method>match</method> for declaring routes. We
built a controller action, both with just a view and by setting up data for the view with a controller method.
Later in the book, we’ll learn more ways to declare routes and understand more about the <method>resources</method> method, which was
originally added to our routes with scaffold for our <class>PeopleController</class>.  In the next chapter, we will test drive more of our <class>CourseController</class> development using the REST pattern and Rails
conventions.</p>



</sect1>

</chapter>
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.controllers">
  <title>Routes and Controllers</title>
  <p><ed>Ok, this chapter really feels like it's nearly twice as long as it needs to be, and I don;t think that's because of the concepts or the content as much as the way the content is presented. I've left lots of comments about that throughout. I like where this is going and it's obvious you spent a lot of time working on it. There are two major issues I'd like you to think about with this chapter:</ed></p>
  <p><ed>First, this is a very long chapter. In your book proposal, you mentioned how each chapter would do some experimentation in the console and IRB but then do the hands-on stuff with tests first. We don't get to the hands-on stuff till pretty far in, and I wonder if some of the experimentation stuff we do could be better expressed with tests. To be clear, I don't think that the chapter would end up much shorter, but I question how much time we need to spend going over things only to go over them again in tests. Perhaps the part where you parse params out of the route can go, because you never use it later - we don't do a show or update. </ed></p>
  <p><ed>The other thing is a bit of a tone issue - it feels like you're trying too hard to be conversational - you've over-corrected a bit in a few places and towards the end of the chapter it becomes very noticeable and a bit tiring. </ed></p>
  
  <p><ed>Content-wise, it's pretty good. It hits all the good points.</ed></p>

     <p>When we create a web application, we craft a unified experience from a series of web pages. 
  Sometimes a single interaction takes place across multiple HTTP requests.</p><p>Let’s take another look at the pages
  that scaffold made for our <class>person</class> model. Making sure we’re in our
  <dir>class_app</dir> directory, we
  type <commandname>rails s</commandname> to run the server. The index page shows a list of people:</p>
  <p><url>http://localhost:3000/people</url></p>
  <p>From there, we can click the “New Person” link to go to a web form to fill in data for a
  new person to add to our database:</p>
  <p><url>http://localhost:3000/people/new</url></p>
  <p>Then when we fill in the name fields and click “Create” to submit the form, which sends an HTTP POST to:
  <ic>http://localhost:3000/people</ic> and then redirects to:</p>  
  <p><url>http://localhost:3000/people/4</url></p>
  <p>The database record was created and then the browser was redirected to display a page that showed the details of
  the person. That’s four HTTP requests and three web pages, but it feels like a unified experience because we’re used
  to interacting with web applications in this way.</p>
  <p> Wrangling these disjoint pages into
  manageable code was challenging in the 1990’s when everyone was first creating web apps, but people recognized a
  Model-View-Controller pattern that made it easier. In <ref linkend="ch.firstapp"/>, we learned about views, how the visual part of our web user interface, are made with
  Embedded Ruby templates in Rails. Then we learned about the model, in  <ref linkend="ch.activerecord"/> and <ref
  linkend="ch.activerecord-rspec"/>.  Next we’ll learn about how <firstuse>routes</firstuse> and
  <firstuse>controllers</firstuse> glue the views together and let us specify the
  interaction part of our user interface. These core Rails components help us focus on supporting effective human interface design with a small amount of maintainable code.</p>
    <p>In Rails, a <emph>route</emph> specifies how an incoming URL calls our code. Routes are like street signs that point to destinations.  When someone accesses a URL of a Rails web
    application, Rails uses the routes specified in <filename>config/routes.rb</filename><ed> filename tag, not ic</ed> to figure out what to do.  This file
    contains a mapping of each URL to our Ruby code which decides what to do. </p>
<p>When we created our app with <commandname>rails new</commandname> the <filename>routes.rb</filename> file was created with no
routes defined. However, it is a deceptively lengthy file because Rails includes a kind of in-line documentation with
many comments that show different example route syntax. When we ran the scaffold generator, it modified this file to add
just one <ic>resources</ic> declaration: </p>
<code file="code/class_app_new/00_controllers/config/routes.rb"/>
<p>From that one line, we defined 7 routes which we explored interactively in <ref
linkend="sec.scaffold-rest-mvc"/>.
The <ic>resources</ic> method provides a nice shortcut for defining all of the standard REST routes; however, to use Rails effectively we need to understand what’s really going on. We’ll build a similar set of routes and corresponding controller behavior for our
<class>Course</class> model one step at a time.</p>
<sect1>
<title>Responding to a URL Request</title>
 
  <p><ed>I liked where you referred us back to the previous app in your intro. Should you maybe walk through that app
  instead of having us do a new one? A diagram here might be helpful too. Help us think in terms of what we've built. If
  you're going to have us build that first Rails app, you might as well use it throughout this first part as the
  example.</ed> When we go to <url>http://localhost:3000/people</url>, the browser sends the HTTP
  request <ic>GET /people</ic> to the server running at <ic>localhost</ic> (listening on port 3000). If the server were a plain old web server, it
  would just respond with the contents of the default file in the
  <dir>people</dir><ed>dirname?</ed><author>Sarah:ok</author> directory, usually
  <filename>index.html</filename>. But our Rails app dynamically
  determines what page to send back to the browser.</p>
<p>To understand how these dynamic web pages work in Rails, we’ll follow an HTTP request from typing an URL into the browser
through a route to learn about the code we need to write to make it work.</p>
<p> We’re going to make a page that shows a welcome message like “hello” or “good morning.” <ed>I get where you're going, but this and the previous paragraph kind of say the same thing. Can you shorten it up? Maybe just lose the next sentence?</ed>  But to understand exactly
how routes work, we’ll just go to some URL we haven’t built yet and see what happens. When we point our browser to
<url>http://localhost:3000/hello</url>, we see the routing
error shown in <ref linkend="fig.routing-error" />. Go ahead and try it. </p>
<figure id="fig.routing-error">
  <title>We Have Not Yet Specified Where the URL Goes</title>
  <imagedata fileref="images/controllers/routing-error.png"  />
</figure>
<p>This error tells us that the URL /hello is not hooked up to anything. There is no <emph>route</emph> into the app
that matches that string.</p>
<sect2>
<title>Let’s Create a Route</title>
<p>Our routes are defined <ed>no, we haven't defined them. How about "We define routes in...."</ed> in <filename>config/routes.rb</filename>. When this file is generated by <ic>rails new</ic> it
includes a lot of comments in it, which can remind you of the syntax later. We’ll be starting with a simple routes, so let’s delete the
comments to more easily see what’s going on.  Writing our first route will make the file look like this: <ed>That feels awkward... and I think you need to explain what we're writing first in this case - how would I know what to write?</ed></p>
<code file="code/message_app0/config/routes.rb"/>
<p>The routes file looks almost like a configuration file — it is even kept in the config directory; however it is
executable Ruby code. <ed>I wonder if that last sentence belongs next to the one about all the comments. </ed>Remembering our Ruby syntax, we can see that it is actually calling the <ic>match</ic> method
and passing it a <ic>Hash</ic> parameter that has a single key-value pair with <ic>"hello"</ic> as the key and
<ic>"messages#greeting"</ic> as the value.</p>
</sect2>
<sect2>
<title>What does that route do?</title>
<p><ed>I think this is too far away from the definition of the route. And why is it a subsection?</ed> The route maps an external URL string to internal code. It let’s <ed>do you mean "lets"?</ed> us separate the human experience of our application
from the internals. After we build our application, we can easily edit this file if inspiration strikes us with better
names. This adds to our development velocity. We don’t need to design everything up front or have a meeting to figure
out the best names, since we can easily change it later.<author>Liah: this is reiterating the point made earlier about being able to easily change routes.  I think it is an interesting point, but I'm not sure it fits in either of the current locations</author></p>
<p><author>Liah: by the time I got down here I'd gotten off track of the code in the last section...I think the next two sentences belong next to the route code above.  Then this section could be more about routing internals and how rails parses the code we put in routes.rb</author>Specifically, in this route, we’ve hooked up the URL “/hello”<author>Liah: should use the html entities</author><ed>I agree with Liah, and  the tangent about developer velocity and meetings to discuss names seems off. I would much rather see this discussion about routes here than in the previous location though.</ed> to a class called
<class>MessagesController</class>. When Rails receives a request for "/hello" it will now call the
<class>MessagesController</class> and invoke the  <method>greeting</method> action. <ed>I think you have made this point a few times, and if you haven't, I think you want to say this well before we define the first route.</ed> Rails applies a
naming convention that many programmers already know — the Rails routing
syntax of class#method is also used in Ruby’s RDoc and ri documentation tools, as well as
Javadocs and other languages. The <method>match</method> method takes the first
part of the route destination, “messages,” capitalizes it, concatenates it with "Controller" and looks for
a class of that name. In this case, <class>MessagesController</class>.  So, <ic>messages#greeting</ic> means
that we’ll be creating a <class>MessagesController</class> with a <method>greeting</method> method to be called when someone browses to
<ic>/hello</ic>.</p>
<figure id="fig.missing-messages-controller">
  <title>We Have a Route but no Controller</title>
  <imagedata fileref="images/controllers/missing-messages-controller.png" />
</figure>

<p>We haven’t finished yet, but let’s explore what we have so far by refreshing our browser. This time we see the error
in <ref linkend="fig.missing-messages-controller"/>: <ic>uninitialized constant MessagesController</ic>. We know that, in Ruby, classes are constants, so when the <class>MessagesController</class> can’t be found, we
get a general error that the <emph>constant</emph> is not initialized. Ruby is actually telling us that we have not yet defined
a <class>MessagesController</class> class.</p>
</sect2>
</sect1>
<sect1>
<title>Creating our First Controller</title>
<p>We’ll use the <commandname>rails generate</commandname> script to create a controller. We use the short form of the
controller name, <commandname>messages</commandname>, to
create our <class>MessagesController</class>:</p>
<code language="session">
$ rails generate controller messages
      create  app/controllers/messages_controller.rb
      invoke  erb
      create    app/views/messages
      invoke  test_unit
      create    test/functional/messages_controller_test.rb
      invoke  helper
      create    app/helpers/messages_helper.rb
      invoke    test_unit
      create      test/unit/helpers/messages_helper_test.rb
</code>
<p>The generator creates a controller and a <emph>helper</emph> along with a directory for the views and corresponding
tests.  Rails generates not only the controller, but the other files and directories we will usually need: a directory
for our views and a helper module where we keep code shared by our controller and views. Our focus right now is on the
  controller, since the error we needed to resolve is about a missing <class>MessagesController</class>. By
  defining the controller class in <filename>app/controllers/messages_controller.rb</filename>, we have addressed the
  error.</p>
  <p>Let’s see what happens next. <ed>I don't think you need any of these "let's see what happens next" bits you're adding. They're becoming very repetitive.</ed> When we refresh the browser at
<url>http://localhost:3000/hello</url>, we see an “Unknown Action” error shown in <ref linkend="fig.unknown-action" />.
The error reports that “the action ‘greeting’ could not be found.”</p>
<figure id="fig.unknown-action">
  <title>We need to define a Controller action</title>
  <imagedata fileref="images/controllers/unknown-action.png" />
</figure>

</sect1>

<sect1>
<title>What’s a Controller Action?</title>
<p>A controller action may take several forms:</p>
<ul>
<li><p>a view template, implemented with EmbeddedRuBy (ERB)</p></li>
<li><p>a controller method that sets up instance variables for a default view template</p></li>
<li><p>a controller method that explicitly calls <method>render</method> or <method>redirect</method></p></li>
</ul>
<p>Let’s start with the simplest controller action by creating a view template with no additional code in our
controller class.</p>  
<sect2>
<title>Creating a View Template</title>
<p>Rails expects view templates for
the <class>MessagesController</class> to be found in the <dir>/app/views/messages</dir> directory. 
This directory was created when we generated the <class>MessagesController</class>. The views are visual
presentaion of the human interface to our application, and like URLs, are kept separate from the code in our controller
which will determine the interaction that happens when someone clicks a link or a button.</p>
<p>When Rails matches a routes, it will look
for a file with name of the action and “.html.erb” appended.  For the route <ic>messages#greeting</ic> we’ll create a file
  <filename>/app/views/messages/greeting.html.erb</filename> with some basic html, such as:</p>
<code file="code/message_app0/app/views/messages/greeting.html.erb"/>
<p>Now when we point our browser to: <url>http://localhost:3000/hello</url> we see &lquot;Here I am!&rquot; in large text as shown in <ref linkend="fig.here-i-am" />. 
</p>
<figure id="fig.here-i-am">
  <title>A simple view</title>
  <imagedata fileref="images/controllers/here-i-am.png"  />
</figure>
<p>Let’s take another look at the Rails log, which is output in the terminal window where we are running <ic>rails
server. We can now understand what is happening in the text that is spewed out for every request:</ic>:</p>
<code language="session">
Started GET "/hello" for 127.0.0.1 at 2011-01-02 12:34:07 -0800
  Processing by MessagesController#greeting as HTML
Rendered messages/greeting.html.erb within layouts/application (40.5ms)
Completed 200 OK in 76ms (Views: 75.1ms | ActiveRecord: 0.0ms)
</code>

<p>The server received a <ic>GET</ic> request for the "/hello" URL which was then processed by the
<class>MessagesController</class> <ic>greeting</ic> action rendering "messages/greeting.html.erb" as HTML. When
starting with a new framework, it is easy to let our eyes glaze over as pages of unfamiliar text scroll by, but if we
pay close attention to what the log output looks like normally, it helps us track down what is going on the first time
that our app starts doing something unexpected.<author>Liah: this sentence is weird</author><author>Sarah: better?</author></p>
<p>Whew! We wrote a <emph>route</emph> and created a <emph>controller</emph> and saw how Rails automatically called a
<emph>view template</emph> with the same name as the controller action without our needing to write any code in the
controller. That’s pretty cool, but at the moment we have nothing more exciting than we would have with a plain old web page
hosted on a plain old web site. But wait! We have everything in place to write some code for some dynamic content. The
file we made isn’t just a plain old html file, it’s called a view template because you <ed>we</ed>  can add <emph>embedded
Ruby</emph> code to create a different presentation depending on circumstance.<author>Liah: I like this paragraph</author></p>
</sect2>
<sect2>
<title>Looking at our Routes</title>
<p>Rails comes with a handy rake task <ed>does Rake need to be capitalized?</ed> that lets us look at the routes that are defined in our application.  Try this:</p>
<code language="session">
$ rake routes
hello  /hello(.:format) {:action=>"greeting", :controller=>"messages"}
</code>
<p>The first thing that is printed out is an internal method name that has been defined for us — actually it’s just part
of a method name.
<commandname>rake routes</commandname> prints <ic>hello</ic>,
but there are actually two methods <ic>hello_path</ic> and <ic>hello_url</ic>. Let’s hop into <ic>rails console</ic>
and check that out:</p>
<code language="irb">
$ rails c
Loading development environment (Rails 3.0.1)
>> app.hello_path
=> "/hello" 
>> app.hello_url
=> "http://www.example.com/hello"
</code>
<p><ed>very cool way to show those urls.</ed> When we define a route using <commandname>match</commandname>, we automatically get methods that we can call from our
controller or views based on the names in the path. It’s awkward to get into the context of our controller and views in
irb, so rails console has an <ic>app</ic> object that we can use to call these helper methods interactively. If we
wanted to change this internal name, we could modify our route, like:</p>
<code file="code/message_app1/config/routes.rb"/>
<p>When we specify <ic>:as</ic> that only affects the names of the internal methods that are dynamically generated for
your routes. These internal names are important because they let us separate what the human bookmarks and
search engines see from what’s going on inside our well ordered code. Let’s see that change in <ic>rake routes</ic>:</p>
<code language="session">
$ rake routes
greeting  /hello(.:format) {:action=>"greeting", :controller=>"messages"}
</code>
<p>Now we could use <ic>greeting_path</ic> and <ic>greeting_url</ic> in our code. The next component in the output of
<ic>rake routes</ic> is the URL path that will match the
route <ic>/hello</ic>, and then what the URL is hooked up to, in this case the <ic>greeting</ic> action of the
<ic>MessagesController</ic>.  The one additional piece of information provided here is the optional <ic>:format</ic>.
By default, a request will be assumed to be of <ic>html</ic> format, but this request will respond to /hello.html
explicity or an alternate format like /hello.xml or /hello.txt. Our controller action could provide alternate behavior,
based on the format of the request.</p>
</sect2>
<sect2>
<title>Accepting Parameters in Our View</title>
<p>We started this adventure seeking to create a greeting at the URL <ic>/hello</ic>. Let’s look at how we would
customize our view to accept a parameter. In HTTP we can pass name-value pairs as part of the URL like
<url>http://localhost:3000/hello?name=emma</url>.  These are parsed by Rails and turned into a
<class>Hash</class>, which we can see in the log:</p>
<code language="session">
Started GET "/hello?name=emma" for 127.0.0.1 at 2011-02-05 19:24:06 -0800
  Processing by MessagesController#greeting as HTML
  Parameters: {"name"=>"emma"}
Rendered messages/greeting.html.erb within layouts/application (2.9ms)
Completed 200 OK in 7ms (Views: 6.8ms | ActiveRecord: 0.0ms)
</code>
<p>In our controller and view we have access to these as <ic>params</ic>, so if we wanted to say “Hello Emma!” when we
pass <ic>name=emma</ic> as a query arg, we could change the view to include embedded Ruby that accesses the paramter:</p>
<code file="code/message_app1/app/views/messages/greeting.html.erb" part="one"/>
<figure id="fig.hello-emma">
  <title>View with a Parameter from a Query Arg</title>
  <imagedata fileref="images/controllers/hello-emma.png"  />
</figure>
<p>When we go to <url>http://localhost:3000/hello?name=emma</url>, we can see in <ref linkend="fig.hello-emma" /> that
the view faithfully reproduced the name as written in the query arg with a lowercase “e”.</p>
<p>We could fix this by writing a bunch of Ruby code in the view, but that would quickly lead to our stuffing most of
our application code into the view, which is hard to work with after a while.</p>
<p>The <ic>params</ic> Hash is accessible in the view, but we don’t access it
directly there except occasionally for debugging. Instead we  like to keep very little code in the view so that it is easy to focus on the implementation of the visual design when we’re editing the view template. We use a controller action to set up data for the view. This is the
<emph>VC</emph> part of the MVC pattern.</p>
</sect2>
<sect2>
<title>View Parameters as Part of the URL</title>
<p>These days it is common to use part of the URL to parameterize the view. This is easy to do in Rails. We just specify
a symbol as part of the URL pattern in our routes and that is automatically parsed and assigned a value in the params
Hash:</p>
<code file="code/message_app2-0/config/routes.rb"/>
<p>Now we can go to <ic>http://localhost:3000/hello/emma</ic> and params[:name] will be assigned the value “emma” which
will cause “Hello emma” to appear in our view.  If we want to make the name optional, we can include it as part of the
route in parenthesis:</p>
<code file="code/message_app2-1/config/routes.rb"/>
<p>Rails gives us tremendous flexibility with how we define URLs and map them to our code.</p>
</sect2>
<sect2>
<title>Writing a Controller Method</title>
<p>Let’s take a look at our controller in <filename>app/controllers/messages_controller.rb</filename>:</p>
<code file="code/message_app0/app/controllers/messages_controller.rb"/>
<p>We can see there is no code in our subclass of ApplicationController.  So far we’ve been relying on the built-in
Rails behavior where the controller will render the html template named in the second part of our route
<ic>messages#greeting</ic>. To see how it works, let’s make an instance method of the same name that just prints out
something we can easily see:</p>
<code file="code/message_app1/app/controllers/messages_controller.rb"/>

<p>and also add some output when the view is rendered:</p>
<code file="code/message_app1/app/views/messages/greeting.html.erb" part="two"/>

<p>The Ruby method <method>puts</method> prints text to <emph>standard out</emph> which is the terminal window
where we’re running the server. It does not affect the HTML that is rendered in the view.</p>
<code language="session">
=> Booting WEBrick
=> Rails 3.0.1 application starting in development on http://0.0.0.0:3000
=> Call with -d to detach
=> Ctrl-C to shutdown server
[2011-02-06 10:08:04] INFO  WEBrick 1.3.1
[2011-02-06 10:08:04] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2011-02-06 10:08:04] INFO  WEBrick::HTTPServer#start: pid=21220 port=3000
==================> greeting method
------------------------> greeting view

Started GET "/hello" for 127.0.0.1 at 2011-02-06 10:08:18 -0800
  Processing by MessagesController#greeting as HTML
Rendered messages/greeting.html.erb within layouts/application (2.3ms)
Completed 200 OK in 22ms (Views: 21.6ms | ActiveRecord: 0.0ms)
</code>
<p>The server log looks out of sequence here.  We can see that the greeting method is called before the view, but it
shows the <ic>GET</ic> request started <emph>after</emph> the method and view were called. How could this be? This happens because the Rails
logger saves up its data and writes it once when it completes the HTTP response. Both the <method>puts</method>
method and the Rails logger are printing to the terminal window.</p>
</sect2>
<sect2>
<title>Using the Rails Logger</title>
<p>Let’s see what happens when we use
<ic>logger.info</ic> instead of <ic>puts</ic>:</p>
<code file="code/message_app2/app/controllers/messages_controller.rb"/>

<code file="code/message_app2/app/views/messages/greeting.html.erb" part="two"/>
<p>We can see that the <ed>I think you can start here without the "we can see that"</ed> output is printed in the sequence that we would expect:</p>
<code language="session">
=> Booting WEBrick
=> Rails 3.0.1 application starting in development on http://0.0.0.0:3000
=> Call with -d to detach
=> Ctrl-C to shutdown server
[2011-02-06 10:24:00] INFO  WEBrick 1.3.1
[2011-02-06 10:24:00] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2011-02-06 10:24:00] INFO  WEBrick::HTTPServer#start: pid=21455 port=3000

Started GET "/hello" for 127.0.0.1 at 2011-02-06 10:24:03 -0800
  Processing by MessagesController#greeting as HTML
==================> greeting method!
------------------------> greeting view!
Rendered messages/greeting.html.erb within layouts/application (1.9ms)
Completed 200 OK in 8ms (Views: 7.5ms | ActiveRecord: 0.0ms)
</code>
<p>We can see that <ed>again here... no "we can see that" </ed> the controller method is called first and then the view is rendered and our statements are
interspersed in the sequence we expect with the built-in logger info. There are various logger methods which correspond
to level <emph>levels</emph>. The output
methods in order of level are: <ic>debug</ic>, <ic>info</ic>, <ic>warn</ic>, <ic>error</ic>, and <ic>fatal</ic>.</p>
<p> By default, Rails will log all levels in every environment except production, where
<ic>info</ic> and higher is logged.  We can set the log level in the environment-specific config files.  Usually we’ll
just leave the log levels as the defaults. In
<dir>app/environments/production.rb</dir>, Rails provides a handy comment <ic>config.log_level = :debug</ic>
which we occasionally turn on in the rare case that we need to debug an issue in production.</p>
</sect2>
<sect2>
<title>Writing Custom Controller Methods</title>
<p>Now we understand that our controller method is called before the view is rendered.  In fact, it is the job of
the controller method to render a view and if it does not render a view, then the implicit behavior is for the
Controller class to render a view of the same name.  So, our previous version of the <method>greeting</method>
method that had no content could also have been written like this to create the exact same behavior:</p>
<code file="code/message_app2-1/app/controllers/messages_controller.rb"/>
<p>By default Rails will assume the <ic>.html.erb</ic> extension, but we could have explicitly written <ic>render 'greeting.html.erb'</ic> and if we had wanted to be even more explicit we could write <ic>render
:template => 'messages/greeting.html.erb'</ic></p>

<p><ed>This feels like you're throwing everything you know about controllers in here. "We can do this.. and we can do this..." but there's not any application. You need to explain the "why" and it can't just be "cos we can."</ed></p>


<p>Let’s dig into some more implicit behavior to understand how we usually
set up data for the view template in the controller:</p>
<code file="code/message_app3/app/controllers/messages_controller.rb"/>
<code file="code/message_app3/app/views/messages/greeting.html.erb"/>
<p>Whatever instance variables we set in the controller are then available to us in the view. Hold on there, partner…
what’s up with that?</p>
<p>We’re not seeing exactly how views are created because Rails does that internally, but MVC is
supposed to keep separate parts of our app in separate classes. If the view is in a separate class from the controller,
how could it be that instance variables are shared? In Ruby, instance variables are private to an instance of a class. Could Rails
somehow be different from the Ruby language and create a situation where instance variables are public? Not at all, but Rails does use some dynamic
language tricks to share data between controllers and their views. The syntax is nice because it is concise, but can be confusing to experienced
object-oriented programmers and Ruby novices until we know what is really going on.<author>Liah: I think this paragraph break is
splitting up an idea.  Also, the word disturbing disturbs me. It doesn't describe what the actual problem is and feels
like hyperbole.  I think you could rework the ideas here to be more engaging and clear.</author><author>Sarah: re-wrote
that bit</author><ed>This sounds like a joeasks and doesn't feel right here.</ed></p>
<p>In Rails, the relationship between the controller
and view seems to subvert the whole object-oriented paradigm. The view, which exists in the context of an entirely
different class <class>ActionView</class>, seems to have access
to the private instance variables of the controller. However, in reality, the view doesn’t directly access to the controller
instance variables. Whew, isn’t that a relief?  <ed>why is this concept important for us to know right now? Do you get people complaining about this when you teach them, or is this something that *you* feel is a problem with Rails? How does knowing this benefit the reader? I think that's lost. We're not dealing with this concept right now, so we're not going to know why we should care. (hint: see next comment!)</ed> After our <method>greeting</method> controller method executes, the
<class>Controller</class> looks through its own instance variables to see which ones have been added. It then
copies them into a <class>Hash</class> which the view uses to set its own instance variables.  This temporary
storage is called <ic>assigns</ic>, which we’ll use when we’re testing. <ed>This is important. Can you replace all that stuff above with this nice, brief explanation?</ed></p>
<p>Mostly Rails implements shortcuts which fit easily into a clear conceptual model of how a web application works.
Often Rails follows best practices of object-oriented design — not so in this case. Rails fails us by mixing together two separate
concerns. We can only speculate as to what possessed David Hansson to rummage through the private instance variables of
one object in order to pass a message to another class. It sure is nice to only have to type one extra character to
indicate that a variable is destined for a view, but couldn’t he have chosen ‘_’ or maybe ‘v’? It is unfortunate that we need to understand
the Rails internals in order to effectively use this communication between controllers and their views and not get
confused about how the Ruby language works in general. But now that we know, we can move on and effectively use this
weird message passing convention.<ed>We talked about adding your opinions, but this rhetorical style here isn't a good fit. I think you can make the point without the "speculation" part. Personally, I agree with you, but I've never once bothered to point this out, and it's only experienced Rails developers who notice. So I wonder if you might just phrase this as just a couple of sentences like "When Rails renders a view, it takes all of the instance variables and sends them along to the view without your intervention While this is a clear violation of accepted object-oriented practices, it does let us reach our goal faster. However, we have to understand how it works in order to properly test it." and you can talk about the assigns hash in there somewhere. This is another reason why I think getting to the TDD stuff early could be beneficial-you could talk about assigns and how it works and then talk about how it's a compromise between good code practices and ease-of-use.</ed></p>

<p><ed>Ok, here we are some ways into the chapter and we've not talked about testing. I understand that your approach is to show it one way and then show it again but with tests, but I really think that you need to get to the testing stuff a lot earlier in these chapters. A lot of what you discussed can be taken care of a little quicker. You're calling this book "test first rails" and the chapters I've seen have us doing testing later. At what point do we actually get to "testing first"? Suggestion: Can the "your first Rails app" chapter cover all of this "how routes work, how controllers and views and stuff work" so we can get a lot of that out of the way all at once? Some of the other details, like adding the route, etc, can be covered by looking at the output of failing tests instead of looking at the output in the console or in the browser. </ed></p>


</sect2>
</sect1>
<sect1>
<title>Understanding Controllers through Testing</title>
<p>In the most common controller tests, we use the <ic>assigns Hash</ic> to verify that a
controller method has correctly set up data for the view and we check that the correct template is rendered. Let’s write a controller for the <class>Person</class>
model in our class app using a test first
approach. <ed>why? What are we really building? A user interface to manage people? Or something different?</ed> We can use an RSpec generator to create our people controller spec file. Remember the
<class>Controller</class> works with multiple <class>Person</class> models, so it is plural:</p>
<code language="session">
  $ rails generate rspec:controller people
</code>
<p>Let’s first make sure that when we browse to the <ic>people/index</ic> page the
<class>PeopleController</class> renders the <ic>index</ic> template: <ed>is that really what you want to test? You told us that Rails will do that. I think you want to test that there's a template to render. Or that the URL works.</ed></p>
<code file="code/class_app/1_controller/spec/controllers/people_controller_spec.rb"/>
<p>When we’re testing controllers, we’ll use a <emph>nested describe</emph> to group each request. In this spec, we’ve got
an overall context for the <class>PeopleController</class> on line <cref linkend="code.people_controller_context"/> and
within that another context for <ic>"GET index"</ic> on line <cref linkend="code.people_index_context"/>  which is
just a string that tells us which request we’re testing.</p>
<p>Now that we’ve set up the example, we’re on to the interesting part! On line <cref linkend="code.get_index"/> we’re calling the
<method>index</method> method of the controller as if it came from a <ic>GET</ic> request. We’re not 
really performing an <ic>HTTP GET</ic> — we’re calling the controller using some testing
helpers which call into Rails the same way the web server will. Those same testing helpers create a <ic>response</ic> object to store the result. We then verify on line <cref linkend="code.should_render"/> that the
controller method rendered the template <filename>index.html.erb</filename>. </p>
<p>Whew! At first glance, it seems
like we’re learning a lot of extra stuff just for testing. But as we dig in, we find out that this extra stuff is just part
of how controllers work. By learning to test controllers, we understand them.<ed>and this is why I think this should be all the chapter should be about. And this feels more like a conclusion to the chapter than something that belongs right here.</ed></p>
<p>So, let’s run the spec!</p>
<code language="session">
$ rake spec
(in /Users/sarah/class_app)
/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby -S bundle exec 
rspec ./spec/controllers/people_controller_spec.rb ./spec/models/assignment_spec.rb 
./spec/models/person_spec.rb
/Library/Ruby/Gems/1.8/gems/rspec-core-2.5.1/lib/rspec/core/backward_compatibility
.rb:20:in `const_missing': uninitialized constant PeopleController (NameError)
	from /Users/sarah/class_app/spec/controllers/people_controller_spec.rb:5
  …
  …long stack trace here…
  …
rake aborted!
ruby -S bundle exec rspec ./spec/controllers/people_controller_spec.rb 
./spec/models/assignment_spec.rb ./spec/models/person_spec.rb failed
</code>
<p><ed>how much of that stack trace do you need to show to effectively show the error?</ed></p>
<p>Here’s our old friend, the <ic>uninitialized constant</ic> error, telling us that we have not yet
defined our <class>PeopleController</class> class. We’ll generate one, being careful not to overwrite our spec
when prompted:<ed>wait, why would we end up overwriting our spec? Should you explain that? and isn't there an option to skip spec generation?</ed> </p>
<code language="session">
$ rails generate controller people
      create  app/controllers/people_controller.rb
      invoke  erb
      create    app/views/people
      invoke  rspec
    conflict    spec/controllers/people_controller_spec.rb
  Overwrite /Users/sarah/class_appplt 
  (enter "h" for help) [Ynaqdh] n
        skip    spec/controllers/people_controller_spec.rb
      invoke  helper
      create    app/helpers/people_helper.rb
      invoke    rspec
      create      spec/helpers/people_helper_spec.rb    
</code>
<p>Defining the <class>PeopleController</class> class in <filename>app/controller/people_controller.rb</filename>
should address our first spec error. We don’t expect to be done yet, but we still run the spec again to see that our test
fails in the way we expect:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
(in /Users/sarah/src/satfr/Book/code/message_app)
F
Failures:

  1) PeopleController GET index renders
     Failure/Error: get :index      
     ActionController::RoutingError:
       No route matches {:controller=>"people"}
     # ./spec/controllers/people_controller_spec.rb:8:in `block (3 levels)
     in <top (required)>'

Finished in 0.10692 seconds
1 example, 1 failure
</code>
<p>We’re seeing the same kinds of errors we saw interactively when we were experimenting with the web app, so we know we
are on the right track.  This error is similar to the one we saw in <ref linkend="fig.routing-error" /> except we’re
looking at it from the other direction. Instead of a URL that has no route connecting it to a controller action, we have
a controller action with no route leading to it.</p>
<p>Of course, to fix this we need to a add route. Looking in <filename>config/routes.rb</filename>, we see a lot of
comments generated as inline documentation for Rails. Let’s just delete those and add a simple route that matches our
people index page to our people index action:</p>
<code file="code/class_app/1_controller/config/routes.rb"/>
<p>That looks a little redundant, but for now let’s do <emph>the simplest thing that could possibly work</emph>. We’ll
worry about code prettiness later, because we know we’re still not done. Let’s run the spec again and expect to watch it fail:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
F

Failures:

  1) PeopleController GET index renders
     Failure/Error: get :index       
     AbstractController::ActionNotFound:
       The action 'index' could not be found for PeopleController
     # ./spec/controllers/people_controller_spec.rb:8:in `block (3 levels) 
     in <top (required)>'

Finished in 0.0427 seconds
1 example, 1 failure
</code>
<p>Now the failure points to a missing action <ic>index</ic> for our <class>PeopleController</class>. We have
multiple options for how to create a controller action: write a controller method, create a view template or both. Let’s
do the simplest thing:</p>
<code language="session">
$ touch app/views/people/index.html.erb
</code>
<p>Um… huh? <ed>that doesn't work for me.</ed> We just used the Unix command <commandname>touch</commandname> which will create an empty file if it doesn’t
already exist <ed>which does not work on windows. have to  use echo instead, or use Ruby to create the file.</ed> In our controller spec, we’re verifying that the response is set up to render a specific template, but
we’re not yet checking to see if the view has anything interesting in it. We’re just making sure it is all hooked up. Let’s run the spec and see how that works:
</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
.

Finished in 0.07397 seconds
1 example, 0 failures
</code>
<p>Woo hoo! Our spec passes!</p>
<p>Time for a beer? Not yet! It is now time for us to reflect on our code and make it better if we see room for
improvement. This is the third step of TDD’s red-green-refactor mantra. Let’s take a look at the route we created, from
two angles. Here’s the declaration:</p>
<code file="code/class_app/1_controller/config/routes.rb"/>
<p>The other way we can look at our routes is with <commandname>rake routes</commandname>:</p>
<code language="session">
$ rake routes
people_index  /people/index(.:format) {:controller=>"people", :action=>"index"}
</code>
<p>Now there are are two things that aren’t lovely about this route. First we’re using a non-standard name for the
route — usually we simply call the route the main people page <ic>people_path</ic> rather than
<ic>people_index_path</ic>. The second bit is actually the cause of this. We can specify the index page more concisely
since that is the default page for any route:</p>
<code file="code/class_app/1a_controller/config/routes.rb"/>
<p>Now when we look at our routes, we see:</p>
<code language="session">
$ rake routes
people  /people(.:format) {:action=>"index", :controller=>"people"}
</code>
<p>Ah. Lovely. Go grab yourself a beverage!</p>
<sect2>
<title>Testing More Controller Action</title>
<p>Controller tests are all about the details of the <emph>controller</emph> — we’re not testing the contents of
the view. Still we are going to want our “people/index” page to show a list of people and the controller is where we
fetch models and lay the foundation for the view. We want to have an array of all of the people models which we can send
to the view by referencing it with an instance variable. <ed>can probably end here. You're getting a little *too* conversational and it's starting to feel awkward.</ed> Yep, that’s just how it is.</p>
<p>We’ll write the test first and check the <ic>assigns Hash</ic> to make sure our controller method set up the data
correctly, but first we need some fake data to test. There are a lot of fancy gems to help us create fake data for
tests, but we’ll start by simply creating some sample data with an ActiveRecord method we already know and love: <ed>do you think there's a need to even mention the gems or other options at this point?</ed>
<ic>Person.create!</ic>. We like to use <ic>!</ic> methods in our tests because if for some unexpected reason the
creation of the object were to fail, the method would raise an exception and any uncaught exception will cause our test
to fail.</p>
<p>At the beginning of our <class>PeopleController</class> spec, we’ll add this:</p>
<code file="code/class_app/1a_controller/spec/controllers/people_controller_spec.rb" part="create_people"/>
<p>At the beginning of each test we’ll create records for three of our favorite Nobel laureates to our test database.
This is why rspec tests are called <emph>examples</emph>.  We’re testing just one example case at a time. For this one,
we’ll write our example like this:</p>
<code file="code/class_app/1a_controller/spec/controllers/people_controller_spec.rb" part="setup"/>
<p>We first <ic>get</ic> the index page, then we test the <ic>assigns Hash</ic>, checking the value at <ic>:people</ic>
to see if it contains an Array of the three specific records we added to the database. We’re just making up the fact that we expect our controller method to set the instance variable <ic>@people</ic>.  It’s
a good design though — we’re following the Rails conventions on naming since we want to display a whole list of Person
objects, we name our variable with the plural noun, people.</p>
<p>Now let’s run the spec and see how it fails</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb 
.F

Failures:

  1) PeopleController GET index sets up the whole list of people
     Failure/Error: assigns[:people].should == [@emmy, @marie, @lise]
       expected: [#<Person id: 1, first_name: "Emmy", last_name: "Noether", 
       created_at: "2011-02-27 22:39:59", updated_at: "2011-02-27 22:39:59">, 
       #<Person id: 2, first_name: "Marie", last_name: "Curie", created_at: 
       "2011-02-27 22:39:59", updated_at: "2011-02-27 22:39:59">, #<Person 
       id: 3, first_name: "Lise", last_name: "Meitner", created_at: 
       "2011-02-27 22:39:59", updated_at: "2011-02-27 22:39:59">]
            got: nil (using ==)
     # ./spec/controllers/people_controller_spec.rb:21:in `block (3 levels) 
     in <top (required)>'

Finished in 0.22362 seconds
2 examples, 1 failure
</code>
<p>We can see that the new example fails because <ic>assigns[:people]</ic> has a value of nil, which is exactly how we
would expect it to fail since we haven’t written any code to give it a value.</p>
<p>To make the example pass, we need to modify our controller to have an index method that sets the value of its
<ic>@people</ic> instance variable to all of the people records:</p>
<code file="code/class_app/1b_controller/app/controllers/people_controller.rb"/>
<p>Behind the scenes, the Rails Controller superclass will take the contents of the <ic>@people</ic> instance variable
and stuff it into <ic>assigns[:people]</ic>. Just like that! Now we can watch the whole spec pass:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
..

Finished in 0.18329 seconds
2 examples, 0 failures
</code>
<p>Are done yet?<ed>missing word?</ed> Nope. Time to reflect upon our code. Now it is hard to imagine something simpler than our 5 line
<class>PeopleController</class> class, but that’s not everything we’ve done. We also need to look at our specs.
Now is a good time to refactor tests as well as production code. There’s just one change we might make: </p>
<code file="code/class_app/1b_controller/spec/controllers/people_controller_spec.rb"/>
<p>We’ve moved the repeated code <ic>get :index</ic> into a <ic>before</ic> block. This reads a little clearer, even
though arguably we’ve replaced two lines of code with three – they are shorter lines and they don’t repeat themselves.
The code is fresh, airy and light.</p>
</sect2>
<sect2>
<title>Let’s Make a Person!</title>
<p>Controller actions aren’t just for displaying data in views, we can also use them to create objects. Following the
REST convention, HTTP POST requests are used for object creation. Following Rails convention, we POST to <ic>/people</ic> to create a
<class>Person</class> object.  Let’s write the test to show how a RESTful
controller expects to be called to create a new <class>Person</class> object. In a web application, an HTTP POST
typically <emph>redirects</emph> to another URL, which means that the web application will return a 302 status code and
the browser is responsible for making an HTTP GET request to the URL given in the Location field of the HTTP Header.  In
a RESTful web application, when an object is created, the address of that object is returned.  In Rails, we call the
page that displays the object the <firstuse>show</firstuse> page and the URL is something like
<ic>/people/1</ic>.</p>
<p>Let’s start by making our HTTP POST to <ic>/people</ic> do a redirect to an action that we’ve already defined, instead of the default
render</p>
<code file="code/class_app/1c_controller/spec/controllers/people_controller_spec.rb" part="post_create"/>
<p>
The parameters to a create action are conventionally given as a nested hash. There are Rails helpers to create forms
that generate POSTs just this way. <ed>I find it interesting that you are jumping into taking in parameters through testing rather than exploration through the view layer. I actually think this is great but it also validates my earlier opinion that this entire chapter should be test-driven.</ed> For now our focus is on the controller.  Let’s see how our example fails:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
..F

Failures:

  1) PeopleController POST create redirects
     Failure/Error: post :create, :person => {:first_name => "Barbara", 
                                              :last_name => "Liskov"}
     ActionController::RoutingError:
       No route matches {:person=>{:first_name=>"Barbara", :last_name=>"Liskov"}, 
       :controller=>"people", :action=>"create"}
     # ./spec/controllers/people_controller_spec.rb:27:in `block (3 levels) 
     in <top (required)>'

Finished in 0.21168 seconds
3 examples, 1 failure
</code>
<p>Hmmm… we’re missing a route.  We’ve got one that connects to <ic>/people</ic> to the <ic>index</ic> action, but we
need that to only happen for a GET request and we need the POST to go somewhere else. Well, as it turns out, the
<method>match</method> method will match any kind of
request that comes in for that URL which can be convenient for implementing certain kinds of APIs, but it’s not a good
fit for what we want to do here.</p>
<p>Let’s change our routes so the two HTTP actions map to two different controller actions:</p>
<code file="code/class_app/1d_controller/config/routes.rb"/>
<p>Now let’s check out our routes:</p>
<code language="session">
$ rake routes
people GET  /people(.:format) {:action=>"index", :controller=>"people"}
       POST /people(.:format) {:action=>"create", :controller=>"people"}
</code>
<p>If we run our spec again, we see…</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
..F

Failures:

  1) PeopleController POST create redirects
     Failure/Error: post :create, :person => {:first_name => "Barbara", 
                                              :last_name => "Liskov"}
     AbstractController::ActionNotFound:
       The action 'create' could not be found for PeopleController
     # ./spec/controllers/people_controller_spec.rb:27:in `block (3 levels) 
     in <top (required)>'

Finished in 0.22273 seconds
3 examples, 1 failure
</code>
<p>Now our example is failing since we don’t yet have a <method>create</method> action in our
<class>PeopleController</class>.  We’ll start by fixing just this error:</p>
<code file="code/class_app/1d_controller/app/controllers/people_controller.rb" />
<p>Then let’s run the spec again.  We still expect it to fail, but we want to make sure it fails the way we expect:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
..F

Failures:

  1) PeopleController POST create redirects
     Failure/Error: post :create, :person => {:first_name => "Barbara", 
                                              :last_name => "Liskov"}
     ActionView::MissingTemplate:
       Missing template people/create with {:handlers=>[:erb, :rjs, :builder, 
       :rhtml, :rxml], :formats=>[:html], :locale=>[:en, :en]} in view paths 
       "#<RSpec::Rails::ViewRendering::PathSetDelegatorResolver:0x0000010111ae20>"
     # ./spec/controllers/people_controller_spec.rb:27:in `block (3 levels) 
     in <top (required)>'
</code>
<p>Well, we’re not even getting to our check for redirect before the <ic>post</ic> to the <ic>create</ic> action fails.
Our empty create method is doing a render by default and then finding that it has no template – to fix that, let’s add
in the redirect: <ed>is this the first time we've seen redirect in a controller? Or is there a place you've explained this already?</ed></p>
<code file="code/class_app/1e_controller/app/controllers/people_controller.rb"/>
<p>Now we expect our example to pass:</p>
<code language="session">
$rspec spec/controllers/people_controller_spec.rb
...

Finished in 0.13336 seconds
3 examples, 0 failures
</code>
<p>and it does pass.  Good stuff, but we’re not done yet.<ed>this phrase shows up a lot.</ed> Our create action successfully redirects, but it doesn’t yet
create a record in the database.  Let’s add another example for that:</p>
<code file="code/class_app/1e_controller/spec/controllers/people_controller_spec.rb" part="post_create"/>
<p>and watch it fail:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
...F

Failures:

  1) PeopleController POST create creates a person record
     Failure/Error: Person.where(:first_name => "Barbara", 
                                  :last_name => "Liskov").should_not be_empty
       expected empty? to return false, got true
     # ./spec/controllers/people_controller_spec.rb:35:in `block (3 levels) 
     in <top (required)>'

Finished in 0.46923 seconds
4 examples, 1 failure
</code>
<p>We need to actually create the <class>Person</class> object from the given attributes from the nested Hash
that we called with the <ic>post</ic> action:</p>
<code file="code/class_app/1f_controller/app/controllers/people_controller.rb" />
<p>When we run the spec again, it passes:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
....

Finished in 0.22511 seconds
4 examples, 0 failures
</code>
<p>Are we done yet? <ed>I bet we're not!</ed> With a passing spec, it is once again time for reflection.  Our code is nice and concise. Our tests
are readable, but we’re not testing all of the cases we want the code to handle. In <ref linkend="ch.activerecord"/>
we added validations, so we know that we could provide an empty first or last name and the record will fail to save, but
what will happen with our code? Let’s write an example for that and find out.</p>
<code file="code/class_app/1g_controller/spec/controllers/people_controller_spec.rb" part="post_create" />
<p>We put the first set of examples into their own context for “valid data” and then put our new examples into a context
for “invalid data.” Now when we run the specs:</p>
<code language="session">
rspec spec/controllers/people_controller_spec.rb
.....F

Failures:

  1) PeopleController with invalid data should render new template
     Failure/Error: response.should render_template(:new)
       expecting <"new"> but rendering with <"">.
       Expected block to return true value.
     # ./spec/controllers/people_controller_spec.rb:49:in `block (3 levels) 
     in <top (required)>'

Finished in 0.2994 seconds
6 examples, 1 failure
</code>  
<p>Our invalid person object is not saved, because of the model validation, but it is still redirecting to the people
index page instead of re-rendering the “new” form.  To fix that, we can use <ic>Person.new</ic> and the
<method>save</method> method so that we can check if the save was successful or not:</p>
<code file="code/class_app/1g_controller/app/controllers/people_controller.rb" part="create" />
<p>Now when we run the spec:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
....FF

Failures:

  1) PeopleController with invalid data does not create a person
     Failure/Error: post :create, :person => {:first_name => "Barbara"}
     ActionView::MissingTemplate:
       Missing template people/new with {:handlers=>[:erb, :rjs, :builder, 
       :rhtml, :rxml], :formats=>[:html], :locale=>[:en, :en]} in view paths 
       "#<RSpec::Rails::ViewRendering::PathSetDelegatorResolver:0x000001013011a8>"
     # ./app/controllers/people_controller.rb:11:in `create'
     # ./spec/controllers/people_controller_spec.rb:43:in `block (3 levels) 
     in <top (required)>'

  2) PeopleController with invalid data should render new template
     Failure/Error: post :create, :person => {:first_name => "Barbara"}
     ActionView::MissingTemplate:
       Missing template people/new with {:handlers=>[:erb, :rjs, :builder, 
       :rhtml, :rxml], :formats=>[:html], :locale=>[:en, :en]} in view paths 
       "#<RSpec::Rails::ViewRendering::PathSetDelegatorResolver:0x000001011faf98>"
     # ./app/controllers/people_controller.rb:11:in `create'
     # ./spec/controllers/people_controller_spec.rb:43:in `block (3 levels) 
     in <top (required)>'

Finished in 0.31349 seconds
6 examples, 2 failures
</code>
<p>We can see that both “invalid data” examples fail because we’re missing the new template. Let’s do the simplest thing
that could possibly work: <ed>you used this phrase last time - how about just explain what you're doing?</ed></p>
<code language="session">
$ touch app/views/people/new.html.erb
$ rspec spec/controllers/people_controller_spec.rb
......

Finished in 0.31042 seconds
6 examples, 0 failures
</code>
<p>Now we understand the basics of controllers, how they act as traffic directors for the web interface. Each controller
action either renders a view or re-directs. If a view is rendered, information may be passed to the view by assigning
instance variables. For very simple controller actions, we’ll often rely on integration tests rather than testing
controller actions in isolation. However, in understanding how to test controllers, we understand exactly how they work
and can make good decisions about where to apply testing in practice.</p>
<p>We also learned about routes and how to include parameters in a URL and specify which controller and action
should be called. We know how to <ic>match</ic> any kind of HTTP request or <ic>get</ic>, <ic>post</ic>,
<ic>put</ic> or
<ic>delete</ic> specifically.</p>

<p><ed>but we didn't talk about deletes, or puts at all in this chapter.</ed></p>

<p>In our development we work hard to keep our controller methods to be small and clearly written. Controllers should do
as little as possible, so that all they are doing is directing traffic: fetching a model, then rendering a view or
redirecting. When our controller actions are small, we can see the whole implementation of a controller on a page or two
which helps us follow the interaction across multiple web requests in our heads as we read the code. It make debugging
easier and makes it easier to work together on a team and modify each other’s code.<ed>good conclusion, but you need to transition us to the next chapter.</ed></p>
</sect2>
</sect1>


</chapter>
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.controllers-rspec">
<title>Understanding Controllers through Testing</title>
<p>In the most common controller tests, we use the <ic>assigns Hash</ic> to verify that a
controller method has correctly set up data for the view and we check that the correct template is rendered. Let’s write a controller for the <class>Person</class>
model in our class app using a test first
approach. <ed>why? What are we really building? A user interface to manage people? Or something different?</ed></p>

<sect1>
<title>Writing a Controller Spec</title>
<p>We can use an RSpec generator to create our people controller spec file. Remember the
<class>Controller</class> works with multiple <class>Person</class> models, so it is plural:</p>
<code language="session">
  $ rails generate rspec:controller people
</code>
<p>Let’s first make sure that when we browse to the <ic>people/index</ic> page the
<class>PeopleController</class> renders the <ic>index</ic> template: <ed>is that really what you want to test? You told us that Rails will do that. I think you want to test that there's a template to render. Or that the URL works.</ed></p>
<code file="code/class_app/1_controller/spec/controllers/people_controller_spec.rb"/>
<p>When we’re testing controllers, we’ll use a <emph>nested describe</emph> to group each request. In this spec, we’ve got
an overall context for the <class>PeopleController</class> on line <cref linkend="code.people_controller_context"/> and
within that another context for <ic>"GET index"</ic> on line <cref linkend="code.people_index_context"/>  which is
just a string that tells us which request we’re testing.</p>
<p>Now that we’ve set up the example, we’re on to the interesting part! On line <cref linkend="code.get_index"/> we’re calling the
<method>index</method> method of the controller as if it came from a <ic>GET</ic> request. We’re not 
really performing an <ic>HTTP GET</ic> — we’re calling the controller using some testing
helpers which call into Rails the same way the web server will. Those same testing helpers create a <ic>response</ic> object to store the result. We then verify on line <cref linkend="code.should_render"/> that the
controller method rendered the template <filename>index.html.erb</filename>. </p>
<p>Whew! At first glance, it seems
like we’re learning a lot of extra stuff just for testing. But as we dig in, we find out that this extra stuff is just part
of how controllers work. By learning to test controllers, we understand them.<ed>and this is why I think this should be all the chapter should be about. And this feels more like a conclusion to the chapter than something that belongs right here.</ed></p>

<p>So, let’s run the spec!</p>
<code language="session">
$ rake spec
(in /Users/sarah/class_app)
/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby -S bundle exec 
rspec ./spec/controllers/people_controller_spec.rb ./spec/models/assignment_spec.rb 
./spec/models/person_spec.rb
/Library/Ruby/Gems/1.8/gems/rspec-core-2.5.1/lib/rspec/core/backward_compatibility
.rb:20:in `const_missing': uninitialized constant PeopleController (NameError)
	from /Users/sarah/class_app/spec/controllers/people_controller_spec.rb:5
  …
  …long stack trace here…
  …
rake aborted!
ruby -S bundle exec rspec ./spec/controllers/people_controller_spec.rb 
./spec/models/assignment_spec.rb ./spec/models/person_spec.rb failed
</code>

<p><ed>how much of that stack trace do you need to show to effectively show the error?</ed></p>
<p>Here’s our old friend, the <ic>uninitialized constant</ic> error, telling us that we have not yet
defined our <class>PeopleController</class> class. We’ll generate one, being careful not to overwrite our spec
when prompted:<ed>wait, why would we end up overwriting our spec? Should you explain that? and isn't there an option to skip spec generation?</ed> </p>
<code language="session">
$ rails generate controller people
      create  app/controllers/people_controller.rb
      invoke  erb
      create    app/views/people
      invoke  rspec
    conflict    spec/controllers/people_controller_spec.rb
  Overwrite /Users/sarah/class_appplt 
  (enter "h" for help) [Ynaqdh] n
        skip    spec/controllers/people_controller_spec.rb
      invoke  helper
      create    app/helpers/people_helper.rb
      invoke    rspec
      create      spec/helpers/people_helper_spec.rb    
</code>
<p>Defining the <class>PeopleController</class> class in <filename>app/controller/people_controller.rb</filename>
should address our first spec error. We don’t expect to be done yet, but we still run the spec again to see that our test
fails in the way we expect:</p>

<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
(in /Users/sarah/src/satfr/Book/code/message_app)
F
Failures:

  1) PeopleController GET index renders
     Failure/Error: get :index      
     ActionController::RoutingError:
       No route matches {:controller=>"people"}
     # ./spec/controllers/people_controller_spec.rb:8:in `block (3 levels)
     in <top (required)>'

Finished in 0.10692 seconds
1 example, 1 failure
</code>
<p>We’re seeing the same kinds of errors we saw interactively when we were experimenting with the web app, so we know we
are on the right track.  This error is similar to the one we saw in <ref linkend="fig.routing-error" /> except we’re
looking at it from the other direction. Instead of a URL that has no route connecting it to a controller action, we have
a controller action with no route leading to it.</p>
<p>Of course, to fix this we need to a add route. Looking in <filename>config/routes.rb</filename>, we see a lot of
comments generated as inline documentation for Rails. Let’s just delete those and add a simple route that matches our
people index page to our people index action:</p>
<code file="code/class_app/1_controller/config/routes.rb"/>
<p>That looks a little redundant, but for now let’s do <emph>the simplest thing that could possibly work</emph>. We’ll
worry about code prettiness later, because we know we’re still not done. Let’s run the spec again and expect to watch it fail:</p>

<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
F

Failures:

  1) PeopleController GET index renders
     Failure/Error: get :index       
     AbstractController::ActionNotFound:
       The action 'index' could not be found for PeopleController
     # ./spec/controllers/people_controller_spec.rb:8:in `block (3 levels) 
     in <top (required)>'

Finished in 0.0427 seconds
1 example, 1 failure
</code>
<p>Now the failure points to a missing action <ic>index</ic> for our <class>PeopleController</class>. We have
multiple options for how to create a controller action: write a controller method, create a view template or both. Let’s
do the simplest thing:</p>
<code language="session">
$ touch app/views/people/index.html.erb
</code>
<p>Um… huh? <ed>that doesn't work for me.</ed> We just used the Unix command <commandname>touch</commandname> which will create an empty file if it doesn’t
already exist <ed>which does not work on windows. have to  use echo instead, or use Ruby to create the file.</ed> In our controller spec, we’re verifying that the response is set up to render a specific template, but
we’re not yet checking to see if the view has anything interesting in it. We’re just making sure it is all hooked up. Let’s run the spec and see how that works:
</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
.

Finished in 0.07397 seconds
1 example, 0 failures
</code>
<p>Woo hoo! Our spec passes!</p>
<p>Time for a beer? Not yet! It is now time for us to reflect on our code and make it better if we see room for
improvement. This is the third step of TDD’s red-green-refactor mantra. Let’s take a look at the route we created, from
two angles. Here’s the declaration:</p>
<code file="code/class_app/1_controller/config/routes.rb"/>
<p>The other way we can look at our routes is with <commandname>rake routes</commandname>:</p>
<code language="session">
$ rake routes
people_index  /people/index(.:format) {:controller=>"people", :action=>"index"}
</code>
<p>Now there are are two things that aren’t lovely about this route. First we’re using a non-standard name for the
route — usually we simply call the route the main people page <ic>people_path</ic> rather than
<ic>people_index_path</ic>. The second bit is actually the cause of this. We can specify the index page more concisely
since that is the default page for any route:</p>
<code file="code/class_app/1a_controller/config/routes.rb"/>
<p>Now when we look at our routes, we see:</p>
<code language="session">
$ rake routes
people  /people(.:format) {:action=>"index", :controller=>"people"}
</code>
<p>Ah. Lovely. Go grab yourself a beverage!</p>


<sect2>
<title>Testing More Controller Action</title>
<p>Controller tests are all about the details of the <emph>controller</emph> — we’re not testing the contents of
the view. Still we are going to want our “people/index” page to show a list of people and the controller is where we
fetch models and lay the foundation for the view. We want to have an array of all of the people models which we can send
to the view by referencing it with an instance variable. <ed>can probably end here. You're getting a little *too* conversational and it's starting to feel awkward.</ed> Yep, that’s just how it is.</p>
<p>We’ll write the test first and check the <ic>assigns Hash</ic> to make sure our controller method set up the data
correctly, but first we need some fake data to test. There are a lot of fancy gems to help us create fake data for
tests, but we’ll start by simply creating some sample data with an ActiveRecord method we already know and love: <ed>do you think there's a need to even mention the gems or other options at this point?</ed>
<ic>Person.create!</ic>. We like to use <ic>!</ic> methods in our tests because if for some unexpected reason the
creation of the object were to fail, the method would raise an exception and any uncaught exception will cause our test
to fail.</p>
<p>At the beginning of our <class>PeopleController</class> spec, we’ll add this:</p>
<code file="code/class_app/1a_controller/spec/controllers/people_controller_spec.rb" part="create_people"/>
<p>At the beginning of each test we’ll create records for three of our favorite Nobel laureates to our test database.
This is why rspec tests are called <emph>examples</emph>.  We’re testing just one example case at a time. For this one,
we’ll write our example like this:</p>
<code file="code/class_app/1a_controller/spec/controllers/people_controller_spec.rb" part="setup"/>
<p>We first <ic>get</ic> the index page, then we test the <ic>assigns Hash</ic>, checking the value at <ic>:people</ic>
to see if it contains an Array of the three specific records we added to the database. We’re just making up the fact that we expect our controller method to set the instance variable <ic>@people</ic>.  It’s
a good design though — we’re following the Rails conventions on naming since we want to display a whole list of Person
objects, we name our variable with the plural noun, people.</p>
<p>Now let’s run the spec and see how it fails</p>

<code language="session">
$ rspec spec/controllers/people_controller_spec.rb 
.F

Failures:

  1) PeopleController GET index sets up the whole list of people
     Failure/Error: assigns[:people].should == [@emmy, @marie, @lise]
       expected: [#<Person id: 1, first_name: "Emmy", last_name: "Noether", 
       created_at: "2011-02-27 22:39:59", updated_at: "2011-02-27 22:39:59">, 
       #<Person id: 2, first_name: "Marie", last_name: "Curie", created_at: 
       "2011-02-27 22:39:59", updated_at: "2011-02-27 22:39:59">, #<Person 
       id: 3, first_name: "Lise", last_name: "Meitner", created_at: 
       "2011-02-27 22:39:59", updated_at: "2011-02-27 22:39:59">]
            got: nil (using ==)
     # ./spec/controllers/people_controller_spec.rb:21:in `block (3 levels) 
     in <top (required)>'

Finished in 0.22362 seconds
2 examples, 1 failure
</code>
<p>We can see that the new example fails because <ic>assigns[:people]</ic> has a value of nil, which is exactly how we
would expect it to fail since we haven’t written any code to give it a value.</p>
<p>To make the example pass, we need to modify our controller to have an index method that sets the value of its
<ic>@people</ic> instance variable to all of the people records:</p>
<code file="code/class_app/1b_controller/app/controllers/people_controller.rb"/>
<p>Behind the scenes, the Rails Controller superclass will take the contents of the <ic>@people</ic> instance variable
and stuff it into <ic>assigns[:people]</ic>. Just like that! Now we can watch the whole spec pass:</p>

<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
..

Finished in 0.18329 seconds
2 examples, 0 failures
</code>
<p>Are done yet?<ed>missing word?</ed> Nope. Time to reflect upon our code. Now it is hard to imagine something simpler than our 5 line
<class>PeopleController</class> class, but that’s not everything we’ve done. We also need to look at our specs.
Now is a good time to refactor tests as well as production code. There’s just one change we might make: </p>
<code file="code/class_app/1b_controller/spec/controllers/people_controller_spec.rb"/>
<p>We’ve moved the repeated code <ic>get :index</ic> into a <ic>before</ic> block. This reads a little clearer, even
though arguably we’ve replaced two lines of code with three – they are shorter lines and they don’t repeat themselves.
The code is fresh, airy and light.</p>
</sect2>
<sect2>
<title>Let’s Make a Person!</title>
<p>Controller actions aren’t just for displaying data in views, we can also use them to create objects. Following the
REST convention, HTTP POST requests are used for object creation. Following Rails convention, we POST to <ic>/people</ic> to create a
<class>Person</class> object.  Let’s write the test to show how a RESTful
controller expects to be called to create a new <class>Person</class> object. In a web application, an HTTP POST
typically <emph>redirects</emph> to another URL, which means that the web application will return a 302 status code and
the browser is responsible for making an HTTP GET request to the URL given in the Location field of the HTTP Header.  In
a RESTful web application, when an object is created, the address of that object is returned.  In Rails, we call the
page that displays the object the <firstuse>show</firstuse> page and the URL is something like
<ic>/people/1</ic>.</p>
<p>Let’s start by making our HTTP POST to <ic>/people</ic> do a redirect to an action that we’ve already defined, instead of the default
render</p>
<code file="code/class_app/1c_controller/spec/controllers/people_controller_spec.rb" part="post_create"/>
<p>
The parameters to a create action are conventionally given as a nested hash. There are Rails helpers to create forms
that generate POSTs just this way. <ed>I find it interesting that you are jumping into taking in parameters through testing rather than exploration through the view layer. I actually think this is great but it also validates my earlier opinion that this entire chapter should be test-driven.</ed> For now our focus is on the controller.  Let’s see how our example fails:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
..F

Failures:

  1) PeopleController POST create redirects
     Failure/Error: post :create, :person => {:first_name => "Barbara", 
                                              :last_name => "Liskov"}
     ActionController::RoutingError:
       No route matches {:person=>{:first_name=>"Barbara", :last_name=>"Liskov"}, 
       :controller=>"people", :action=>"create"}
     # ./spec/controllers/people_controller_spec.rb:27:in `block (3 levels) 
     in <top (required)>'

Finished in 0.21168 seconds
3 examples, 1 failure
</code>
<p>Hmmm… we’re missing a route.  We’ve got one that connects to <ic>/people</ic> to the <ic>index</ic> action, but we
need that to only happen for a GET request and we need the POST to go somewhere else. Well, as it turns out, the
<method>match</method> method will match any kind of
request that comes in for that URL which can be convenient for implementing certain kinds of APIs, but it’s not a good
fit for what we want to do here.</p>
<p>Let’s change our routes so the two HTTP actions map to two different controller actions:</p>
<code file="code/class_app/1d_controller/config/routes.rb"/>
<p>Now let’s check out our routes:</p>

<code language="session">
$ rake routes
people GET  /people(.:format) {:action=>"index", :controller=>"people"}
       POST /people(.:format) {:action=>"create", :controller=>"people"}
</code>
<p>If we run our spec again, we see…</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
..F

Failures:

  1) PeopleController POST create redirects
     Failure/Error: post :create, :person => {:first_name => "Barbara", 
                                              :last_name => "Liskov"}
     AbstractController::ActionNotFound:
       The action 'create' could not be found for PeopleController
     # ./spec/controllers/people_controller_spec.rb:27:in `block (3 levels) 
     in <top (required)>'

Finished in 0.22273 seconds
3 examples, 1 failure
</code>
<p>Now our example is failing since we don’t yet have a <method>create</method> action in our
<class>PeopleController</class>.  We’ll start by fixing just this error:</p>
<code file="code/class_app/1d_controller/app/controllers/people_controller.rb" />
<p>Then let’s run the spec again.  We still expect it to fail, but we want to make sure it fails the way we expect:</p>


<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
..F

Failures:

  1) PeopleController POST create redirects
     Failure/Error: post :create, :person => {:first_name => "Barbara", 
                                              :last_name => "Liskov"}
     ActionView::MissingTemplate:
       Missing template people/create with {:handlers=>[:erb, :rjs, :builder, 
       :rhtml, :rxml], :formats=>[:html], :locale=>[:en, :en]} in view paths 
       "#<RSpec::Rails ::ViewRendering::PathSetDelegatorResolver:0x0000010111ae20>"
     # ./spec/controllers/people_controller_spec.rb:27:in `block (3 levels) 
     in <top (required)>'
</code>
<p>Well, we’re not even getting to our check for redirect before the <ic>post</ic> to the <ic>create</ic> action fails.
Our empty create method is doing a render by default and then finding that it has no template – to fix that, let’s add
in the redirect: <ed>is this the first time we've seen redirect in a controller? Or is there a place you've explained this already?</ed></p>
<code file="code/class_app/1e_controller/app/controllers/people_controller.rb"/>
<p>Now we expect our example to pass:</p>
<code language="session">
$rspec spec/controllers/people_controller_spec.rb
...

Finished in 0.13336 seconds
3 examples, 0 failures
</code>
<p>and it does pass.  Good stuff, but we’re not done yet.<ed>this phrase shows up a lot.</ed> Our create action successfully redirects, but it doesn’t yet
create a record in the database.  Let’s add another example for that:</p>
<code file="code/class_app/1e_controller/spec/controllers/people_controller_spec.rb" part="post_create"/>
<p>and watch it fail:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
...F

Failures:

  1) PeopleController POST create creates a person record
     Failure/Error: Person.where(:first_name => "Barbara", 
                                  :last_name => "Liskov").should_not be_empty
       expected empty? to return false, got true
     # ./spec/controllers/people_controller_spec.rb:35:in `block (3 levels) 
     in <top (required)>'

Finished in 0.46923 seconds
4 examples, 1 failure
</code>
<p>We need to actually create the <class>Person</class> object from the given attributes from the nested Hash
that we called with the <ic>post</ic> action:</p>
<code file="code/class_app/1f_controller/app/controllers/people_controller.rb" />
<p>When we run the spec again, it passes:</p>
<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
....

Finished in 0.22511 seconds
4 examples, 0 failures
</code>
<p>Are we done yet? <ed>I bet we're not!</ed> With a passing spec, it is once again time for reflection.  Our code is nice and concise. Our tests
are readable, but we’re not testing all of the cases we want the code to handle. In <ref linkend="ch.activerecord"/>
we added validations, so we know that we could provide an empty first or last name and the record will fail to save, but
what will happen with our code? Let’s write an example for that and find out.</p>
<code file="code/class_app/1g_controller/spec/controllers/people_controller_spec.rb" part="post_create" />
<p>We put the first set of examples into their own context for “valid data” and then put our new examples into a context
for “invalid data.” Now when we run the specs:</p>
<code language="session">
rspec spec/controllers/people_controller_spec.rb
.....F

Failures:

  1) PeopleController with invalid data should render new template
     Failure/Error: response.should render_template(:new)
       expecting <"new"> but rendering with <"">.
       Expected block to return true value.
     # ./spec/controllers/people_controller_spec.rb:49:in `block (3 levels) 
     in <top (required)>'

Finished in 0.2994 seconds
6 examples, 1 failure
</code>  
<p>Our invalid person object is not saved, because of the model validation, but it is still redirecting to the people
index page instead of re-rendering the “new” form.  To fix that, we can use <ic>Person.new</ic> and the
<method>save</method> method so that we can check if the save was successful or not:</p>
<code file="code/class_app/1g_controller/app/controllers/people_controller.rb" part="create" />
<p>Now when we run the spec:</p>


<code language="session">
$ rspec spec/controllers/people_controller_spec.rb
....FF

Failures:

  1) PeopleController with invalid data does not create a person
     Failure/Error: post :create, :person => {:first_name => "Barbara"}
     ActionView::MissingTemplate:
       Missing template people/new with {:handlers=>[:erb, :rjs, :builder, 
       :rhtml, :rxml], :formats=>[:html], :locale=>[:en, :en]} in view paths 
       "#<RSpec::Rails::ViewRendering::PathSetDelegatorResolver:0x000001013011a8>"
     # ./app/controllers/people_controller.rb:11:in `create'
     # ./spec/controllers/people_controller_spec.rb:43:in `block (3 levels) 
     in <top (required)>'

  2) PeopleController with invalid data should render new template
     Failure/Error: post :create, :person => {:first_name => "Barbara"}
     ActionView::MissingTemplate:
       Missing template people/new with {:handlers=>[:erb, :rjs, :builder, 
       :rhtml, :rxml], :formats=>[:html], :locale=>[:en, :en]} in view paths 
       "#<RSpec::Rails::ViewRendering::PathSetDelegatorResolver:0x000001011faf98>"
     # ./app/controllers/people_controller.rb:11:in `create'
     # ./spec/controllers/people_controller_spec.rb:43:in `block (3 levels) 
     in <top (required)>'

Finished in 0.31349 seconds
6 examples, 2 failures
</code>
<p>We can see that both “invalid data” examples fail because we’re missing the new template. Let’s do the simplest thing
that could possibly work: <ed>you used this phrase last time - how about just explain what you're doing?</ed></p>
<code language="session">
$ touch app/views/people/new.html.erb
$ rspec spec/controllers/people_controller_spec.rb
......

Finished in 0.31042 seconds
6 examples, 0 failures
</code>
<p>Now we understand the basics of controllers, how they act as traffic directors for the web interface. Each controller
action either renders a view or re-directs. If a view is rendered, information may be passed to the view by assigning
instance variables. For very simple controller actions, we’ll often rely on integration tests rather than testing
controller actions in isolation. However, in understanding how to test controllers, we understand exactly how they work
and can make good decisions about where to apply testing in practice.</p>
<p>We also learned about routes and how to include parameters in a URL and specify which controller and action
should be called. We know how to <ic>match</ic> any kind of HTTP request or <ic>get</ic>, <ic>post</ic>,
<ic>put</ic> or
<ic>delete</ic> specifically.</p>

<p><ed>but we didn't talk about deletes, or puts at all in this chapter.</ed></p>

<p>In our development we work hard to keep our controller methods to be small and clearly written. Controllers should do
as little as possible, so that all they are doing is directing traffic: fetching a model, then rendering a view or
redirecting. When our controller actions are small, we can see the whole implementation of a controller on a page or two
which helps us follow the interaction across multiple web requests in our heads as we read the code. It make debugging
easier and makes it easier to work together on a team and modify each other’s code.<ed>good conclusion, but you need to transition us to the next chapter.</ed></p>
</sect2>
</sect1>
</chapter>
<appendix>
<title>Database Primer</title>
<p>We rarely write SQL directly in our Rails code, but to understand what our app is really doing in the
database, we’ll want to occasionally look at the SQL called by our app.</p>
<sect1 id="sec.sql">
<title>Understanding SQL</title>
<p> If you don’t already know SQL, refer to <ref
linkend="fig.database-commands" /> for a quick cheat sheet of the basic commands.</p>
<figure id="fig.database-commands">
  <title>Database Commands</title>
  <imagedata fileref="images/database-commands.png" />
</figure>
</sect1>
<sect1 id="sec.dbconsole">
<title>The <commandname>dbconsole</commandname> command</title>
<p>One of the Rails commands <ic>rails dbconsole</ic> invokes our database console. Every database comes with a command
line tool which has a unique command to invoke it and sometimes different names for command line options to specify the user, password and database name. The dbconsole command simply calls the appropriate database console app. So for SQLite, rails dbconsole is the same as:</p>
<code language="session">
$ SQLite3 <my_development_database>
</code>
<p>and for MySql, it is the same as:</p>
<code language="session">
$mysql –u<name> –p<password> <my_development_database> 
</code>
<p>The <commandname>dbconsole</commandname> is a very useful tool for inspecting the contents of the database when we
are debugging or want to take a quick look at what tables and schema exist for our app.</p>
</sect1>
<sect1>
<title>Using a Different Database</title>
<p>If you want to use Rails with a different database, there are shortcuts for creating different configuration files for the most commonly used databases. For example, to generate a Rails application with a default configuration for MySql, you would use the following command:</p>
<code language="session">
$ rails new –d mysql app_name
</code>
<p>The contents of the <filename>database.yml</filename> file is the only difference in the generated app when calling “rails new” with the –d option. </p>

<p>The following databases are supported:</p>
<table style="outerlines">
  <thead>
    <col><p>Database</p></col>
    <col><p>Configuration Option</p></col>
  </thead>
  <row> <col><p>SQLite</p></col><col><p>default</p></col> </row>
  <row> <col><p>MySQL</p></col><col><p>-d mysql</p></col> </row>
  <row> <col><p>PostgreSQL</p></col><col><p>-d postgresql</p></col> </row>
  <row> <col><p>Oracle</p></col><col><p>-d oracle</p></col> </row>
  <row> <col><p>DB2</p></col><col><p>-d ibm_db</p></col> </row>
  <row> <col><p>Frontbase</p></col><col><p>-d frontbase</p></col> </row>
  <row> <col><p>SQL Server</p></col><col><p>manual configuration required</p></col> </row>
  <row> <col><p>Sybase</p></col><col><p>manual configuration required</p></col> </row>
</table>

<p>When we use a different database, we need to install the database-specific driver so that our Ruby code can talk to
the database. Each of the supported databases requires a separate gem to connect to that database from Ruby.</p>
</sect1>
</appendix>
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.ruby-rspec-basics">
  <title>Ruby and Rspec Basics</title>

  <sect1 id="sec.ruby.lang.intro">
    <title>Ruby Language Introduction...and Why Ruby is Rad</title>
    <p>
    Every excellent Rails programmer has a thorough understanding of Ruby  - after all, Rails is written in Ruby.  Trying to write a Rails program without knowing Ruby is like trying to write a limerick in English without knowing English – you could do it with the help of a translator, but it would be much easier with fluency in the language.  Before we dig deeply into Rails let's get a solid grounding in Ruby.  
    </p>
    <p>
    There are many reasons to love Ruby.  For one, it is a concise language: forget about semi-colons and curly braces – we won’t need them in this book.   We also won’t need to wrap our arguments in parentheses if we don’t want to.  Check this out:
    </p>

    <code language="ruby">
      def combo thing1, thing2
        thing1 + " and " + thing2
      end
    </code>

    <code language="irb">
      > combo "peanut butter", "jelly"
      => "peanut butter and jelly" 
      > combo "pork chops", "applesauce"
      => "pork chops and applesauce"  
    </code>

    <p>
    We defined the <method>combo</method> method without parentheses around our parameters and we called <method>combo</method> without parentheses around the arguments.  This is totally legal in Ruby and is called &lquot;poetry syntax&rquot;.  Of course, Ruby allows us to put in parentheses if we prefer.
    </p>

    <p>
      One of my favorite things about Ruby is that the quality of our code is determined in large part by the quality of our tests.  Rubyists have developed sophisticated tools for testing Ruby code like Rspec, Cucumber and Capybara to name a few.  Abundant test coverage gives us confidence when changing old code or adding new code.  It empowers programmers with flexibility and speeds up development over the long-term life of a project.  Test driven development (TDD) is a popular testing technique among Rubyists where a test is written before the code. Lets get started playing with Ruby!
    </p>
    <sect2 id="ruby.lang.intro.irb">
       <title>Interactive Ruby (irb)</title>    
       <p>
       Ruby comes equipped with irb, which stands for &lquot;Interactive RuBy&rquot;. It allows us to see how Ruby will interpret our code and is one of the most valuable tools in our programmer toolbox.  To access irb, we type &lquot;irb&rquot; into our command line.  We should see a prompt with an angle bracket &lquot;>&rquot; where we can type in Ruby code.  Here’s an example:
       </p>
       <code language="session">
         $ irb
         > 1 + 1
       </code>
       <p>
         Now when we click enter, Ruby will evaluate 1 + 1 and show us what it returns:
       </p>
       <code language="session">
         => 2
       </code>
    </sect2>





    <sect2 id="ruby.lang.intro.evaluation">
       <title>Everything Evaluates to Something</title>
    <p>
     In Ruby every expression evaluates to (returns) something.  That means that every time we ask Ruby to evaluate an expression, it will tell us the result of the evaluation.  Irb will help us get a better handle on return values.  When we asked Ruby to evaluate <ic>1 + 1</ic> above, it returned 2 (<ic>=> 2</ic> appears after we hit the enter key).  We can evaluate addition of integers like 1 + 1 above, or we can evaluate strings:
    </p>

    <code language="session">
      > "like a string of pearls, but with characters"
       => "like a string of pearls, but with characters"
    </code>
    <p>
      A string consists of quotation marks with any number of characters in between.  Strings are used for any textual information that a program needs.  
    </p>
    <p>
      Ruby can add strings as well as integers.  When we add strings, we call it &lquot;concatenation&rquot;.  Check out this example of concatenating strings:
    </p>
    <code language="session">
      > "knock, knock." + " whose there?" +
      >   " interrupting cow." + " interrupting cow wh..." + " Moooo"
       => "knock, knock. whose there? interrupting cow. interrupting cow wh... Moooo"
    </code>

     <p>
        Ruby evaluates the concatenation of the five strings making up this cheesy knock knock joke and returns them all together as one string.
     </p>
   </sect2>
   
   <sect2 id="ruby.lang.intro.objects">
    <title>Everything Is an Object</title>
    <p>
      Yep, it’s true.  Everything in Ruby is an object, unlike many other languages.   The fact that strings and numbers are objects means that Ruby can define methods on them.  We can change a string from lowercase to uppercase as follows:
    </p>

    <code language="irb">
    > "too big for my britches".upcase
     => "TOO BIG FOR MY BRITCHES"
    </code>
   
    <p>
       The string &lquot;too big for my britches&rquot; is an instance of the <class>String</class> class where the <method>upcase</method> method is defined.  Ruby has many classes of its own such as<class>String</class>, <class>Hash</class>, <class>Array</class>, etc.   A class is like a blueprint from which we can make as many houses as we want.  We can also define our own classes and create objects from them.  That’s what we will do next.
     </p>
    </sect2>
  </sect1> 
  <sect1 id="sec.ruby.tdd.pre">
    <title>Test Driven Development Prerequisits</title>
    <p>
      RSpec and other testing frameworks are fantastic tools that make programmers’ lives easier and speed up the process of adding features and fixing bugs.  But what if they didn’t exist?
    </p>

    <p>
      To gain insight into the value of test frameworks, let’s suspend our disbelief and pretend testing frameworks haven’t been invented yet.  We can improvise a primitive test framework of our own by running our code in irb and understanding the error messages.  We can try out different permutations of our code to see what works and what doesn’t based on the same error messages we will be seeing once we start using RSpec.
    </p>
    <p>
        We need a simple example to start with.  Let's write a <method>welcome_message</method> method for the <class>Course</class> class.  We will continue to use our Course class throughout this book and the <method>welcome_message</method> method we are about to write will eventually be added to our Rails application.  A requirement of the <method>welcome_message</method> method is that it should change the greeting depending on the time of day.  It should say &lquot;Good Morning! Office hours are currently closed.&rquot; in the morning, &lquot;Good Afternoon! Office hours are currently open.&rquot; in the afternoon and &lquot;Good Evening! Office hours are currently closed.&rquot; in the evening. We are going to walk through this example in baby steps, but so you know what we are working towards, our end result will look like this: 
    </p>
    <code language='ruby'>
      class Course
        def welcome_message
          time = Time.now
          if ("01:00" < time.strftime('%R')) && (time.strftime('%R') < "11:59")
            message = "Good Morning! Office hours are currenlty closed."
          elsif ("12:00" < time.strftime('%R')) && (time.strftime('%R') < "16:59")
           message = "Good Afternoon! Office hours are currently open."
          elsif ("17:00" < time.strftime('%R')) && (time.strftime('%R') < "24:59")
           message = "Good Evening. Office hours are currently closed."
          end
        end
      end
    </code>
    
    <p>
      First we’ll need a file.  Ruby files end with a &lquot;.rb&rquot; extension.  By convention we name files after the class we plan to write, but it could be called <filename>super_welcome_message_maker.rb</filename> and it would still work.  Let’s follow the Ruby convention and make a file called <filename>course.rb</filename> since we plan to make our <method>welcome_message</method> method in the <class>Course</class> class.
    </p>
    
    <p>
      Before we load our Course class into irb, let's look at what happens if we try to use the Course class:
    </p>

    <code language="irb">
    $ irb
    > Course
    NameError: uninitialized constant Course
      from (irb):2
    </code>

    <p>
      In Ruby, classes are constants.  When typing in <ic>Course</ic> above, Ruby knows that there isn’t currently a <class>Course</class> class, so it throws a <constant>NameError</constant> telling us that the <class>Course</class> constant doesn’t exist.  (Note: constants in Ruby always start with a capital letter and by convention are all caps.  Classes are an exception to the convention.  For classes, the first letter of each word is capitalized and spaces are omitted.)   Ruby’s descriptive Error messages are crucial in helping us debug programs.  The <constant>NameError</constant> above describes exactly what is wrong with our program.  We are going over this in detail because a key to mastering TDD is learning to read error messages.
    </p>
    
    <p>
      Let’s try again after loading in <filename>course.rb</filename>.  We will see what happens if we just create the file without any contents and load it in irb:
    </p>
    <code language="irb">
    > load 'course.rb'
     => true 
    > Course
    NameError: uninitialized constant Course
      from (irb):2
    </code>

    <p>
      Loading <filename>course.rb</filename> reports true since it was able to successfully load the file and evaluate the (empty) contents of the file as Ruby code, but <class>Course</class> is still not defined.  Loading the file simply evaluates the text inside it as Ruby code.  
    </p>
    
    <p>
      Next we can add the class declaration to the file:
    </p>

    <p><filename>course.rb</filename></p>
    <code language="ruby">
      class Course
      end
    </code>
    
    <p>
       Our code can now create Course objects.  We create a new object with the <method>new</method> method:
    </p>
    <code language="irb">
      c = Course.new
       => #<Course:0x10044c6a8>
    </code>
    
     <p>
       Our new Course object’s return value shows the class of the object (<class>Course</class>) and an encoded version of the object’s id (0x10044c6a8).  If we make more objects of the <class>Course</class> class, each one will have a unique object id.  We haven’t defined any methods in our <class>Course</class> class, yet look at our output when we ask our <class>Course</class> object for its methods:
     </p>
     <code language="irb">
     
     c.methods
      => ["inspect", "tap", "clone", "public_methods", "object_id", "__send__", "instance_variable_defined?", "equal?", "freeze", "extend", "send", "methods", "hash", "dup", "to_enum", "instance_variables", "eql?", "instance_eval", "id", "singleton_methods", "taint", "frozen?", "instance_variable_get", "enum_for", "instance_of?", "display", "to_a", "method", "type", "instance_exec", "protected_methods", "==", "===", "instance_variable_set", "kind_of?", "respond_to?", "to_s", "class", "__id__", "tainted?", "=~", "private_methods", "untaint", "nil?", "is_a?"]
      
    </code>
    <author>Liah: the above code seems to be causing an issue...?</author>
    <p>
       Ruby gives many useful methods for free to any class we create.  This is because every class in Ruby is a descendent of the <class>Object</class> class where all these methods are defined.  We can prove this to our selves like this:
    </p>
    <code language="irb">
     > c.class
      => Course
     > c.class.superclass
      => Object 
     </code>

     <p>
       Our <class>Course</class> object is an instance of the <class>Course</class> class and the superclass of the <class>Course</class> class is the <class>Object</class> class.
     </p>
     
     <p>
       We’ll need to add our <method>welcome_message</method> method to our <class>Course</class> class in order for its objects to have useful functionality outside of its inherited methods.  Before we change our code, we should check out what happens when we call the <method>welcome_message</method> method on our <class>Course</class> object:
     </p>

     <code language="irb">
     > c.welcome_message
     NoMethodError: undefined method `welcome_message` for #<Course:0x10045f0a0>
       from (irb):19
     </code>

     <p>
       This time our error message is a <constant>NoMethodError</constant>.  It tells us that currently the <method>welcome_message</method> method is not defined, as we would expect.  Now we can edit <filename>course.rb</filename> so that the <method>welcome_message</method> method is defined and we give it a return value of &lquot;Good Morning! Office hours are closed.&rquot;.
     </p>
     <code language="ruby">
     class Course
       def welcome_message
          "Good Morning! Office hours are closed"
       end
     end
     </code>
     
     <p>
       When we reload <filename>course.rb</filename> and call the <method>welcome_message</method> method, the string &lquot;Good Morning! Office hours are open.&rquot; is returned.
     </p>
     
     <code language="irb">
     > c.welcome_message
      => "Good Morning! Office hours are open."
     </code>
  </sect1>
</chapter>
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.intro">
<title>Why Test? And How We Test First</title>
 
  <p>Ever wanted to rip out an old feature and replace it with the next big thing? Well-tested code gives us the power
  of worry-free refactoring and code reuse.    <ed>what if the "ever" sentence was first, and then you followed it up with 
  "well tested code gives us the power of worry-free refactoring and code reuse." and then dropped "well tested code makes us..."?</ed>
  <author>Sarah: great suggestion. done.</author>
  Tests give us the confidence to reinvent our code to our heart's content.  Where our human brains fail at remembering
  all the details of our code's behavior, tests succeed. We can ship sooner and more often, giving us huge competitive
  advantage.<ed>Can you shorten this? There are a lot of adverbs (-ly) here that make
   this a little hard to read. I'd lose "in the world of web apps" and just say "This special power leads to better
   applications that ship sooner and have more frequent updates, giving us a huge competitive
   advantage"</ed><author>Sarah: even shorter is better, I think</author></p>
  <p>In a language, like Ruby, without a compiler, changing code can be particularly dangerous. If we change a method or class name,
  and we don’t modify every piece of code that calls it, there’s no compiler to catch the error. <ed>is that clear why? Is it because it's a 
  dynamic language? or is it because it's an interpreted language and not compiled?</ed><author>Sarah: agree that
  dynamic language stuff is less common use case, focusing on compiler is easier to explain</author>This can lead to a
  deceptive feeling of safety with languages like Java or C++.
  Testing allow us to catch logic errors that a compiler would never recognize, in addition to flagging places where we
  changed an interface without adjusting the calling code. With testing we
can enjoy the flexibility of a language like Ruby with a safety net.<ed>the logic errors part feels out
of place in this paragraph. It might be better off as it's own and slightly expanded upon.</ed><author>Sarah: is that
better?</author>
  </p>
  <figure id="fig.tdd-productivity">
  <title>Test Driven Development vs. Traditional Velocity by Alex Chaffee</title>
  <imagedata fileref="images/TDD-productivity-graph.png" align="center" />
</figure>
<p>We can visualize how test-driven development increases our productivity by thinking about how much time it takes to develop
each feature, as shown in <ref linkend="fig.tdd-productivity" />. <ed>do you have permission to use this? do you need a
signed release to reproduce this? You do unless it's public domain.</ed><author>I will get a signed release.</author>
With the first few features, traditional development
may be faster, because we aren’t typing test code in addition to implementing a feature. However, as features
accumulate, the tests allow us to quickly see how the addition of a new feature impacts existing features. Refactoring,
which we’ll learn about later in this chapter when we describe the test first development cycle in detail,
is key to keeping the effort per feature consistent. With an executable specification, plus well-factored tests and
implementation code, we can maintain development velocity as a codebase matures. </p>
 <sect1>
 <title>Testing Helps Us Create Great Software</title>
 <p>Writing code test first isn’t just about creating tests and verifying that our code lacks defects, it’s a software development process that causes us to write
 better code with fewer bugs.</p>
  <sect2>
  
  <title>Effective Design</title>
  <p>First and foremost, test first development is about design. Before we write any code, we test
  our design. In our tests we develop against APIs that don’t exist yet. We see how the code will flow and what the
  behavior would be if that code existed. We are free to change APIs and modify how methods work together without having
  to rewrite any implementation code. </p>
  <p>This design process caused the creators of RSpec and other so-called test frameworks to rename the process
  <emph>behavior driven development</emph> (BDD). When we write our code test first, we are actually writing a
  <firstuse>specification</firstuse> of our code. We are
  specifying our code by example with each test case part of an <emph>executable specification</emph>.</p>
  <p>As with paper specifications, we can see the API in action; however, unlike paper specs, once all of the tests pass, 
  we know that the APIs work together to create the desired result and the test ensures that the API is used consistently across the whole specification.</p>
  <p>Verifying our design before we write our code translates into development velocity. It may take us longer to type
  the code the very first time, but the code has fewer bugs and we are more likely to develop the right solution. We
  develop production code significantly faster than traditional test last or wild west methodologies.</p>
  </sect2>
  <sect2>
<title>Easier Collaboration</title>
  <p>A test first approach has a few different effects in the way we work that make it easier to collaborate in a team.
  The nature of an executable specification improves interaction between developers and whoever is setting the
  requirements. Also, the tests themselves and the incremental nature of development improves collaboration betwen
  developers on the team.</p>
  <p>Historically we’ll have a product manager who sets requirements and engineers who write specifications on paper. Sometimes
  the line between setting requirements and figuring out the technical solution can get a little blurry. By writing our
  specifications in code, we clearly separate the definition of requirements from the
  specification process. With test-driven development, requirements are still defined in words, but specifications are written with code (even if it is code that sounds a bit like English). Having two different activities for each phase helps separate the steps in
  the process.</p>
  <p>When we sit down to write a spec or test, it forces us to consider whether we are missing some
  information. We need to clearly understand pre- and post-conditions for the code we are about to define. Do we need to ask some questions to refine the requirements? Do we need to learn more about the
  technologies we’re using before we dive into implementation? Test first development can help improve this process and
  allow developers to work with a product manager or product owner more effectively, and also ensure that developers
  know what they are doing when they sit down to write production code.</p>
<p>In addition to helping with the product definition workflow, test first development fosters collaboration between
developers. Tests serve as documentation for other developers on the team.  If a developer comes across unfamiliar code, it is easy to go check out the spec to see the code in action.</p>   
  <p>Writing tests first encourages small, frequent commits, contributing to effective collaboration.  Once our failing test passes, we know that we are done coding a particular requirement.  A test first approach allows
  us to chunk our requirements into little bite sized pieces that can be committed to source control separately.  All the developers on our project can then commit and pull multiple times per day and the code stays synched up.</p>
</sect2>
<sect2>
<title>More Maintainable Code</title>
<p>Less code is more easily maintained. A test first approach keeps us focused so that we only
  write necessary code. We write tests just for the new behavior we want to build, and it helps us not write redundant
  tests for the built in behavior of the underlying system.</p>
  <p>When we test drive development, we also tend to write smaller methods and write components with better separation
  of concerns. This kind of code is more flexible and easier to modify.</p>
</sect2>
<sect2>
<title>Shorter Bug Find-Fix Cycle</title>
  <p>Test driving our code turns us into a different kind of programmer.  We focus on getting things correct from all
  angles. Once we test drive some new behavior, we run our whole test suite so we can discover if our code had some
  unintended effect or the new behavior interacted with an old feature in an unexpected way. By finding bugs quickly,
  before the code ever goes to QA or to production, we dramatically speed up the process by shortening the bug find-fix
  cycle.</p>
</sect2>
<sect2>
<title>The Creation of Tests</title>
<p>Lastly, we end up with a test suite! Writing the tests first guarantees that. If we always write tests first, we’ll
have 100% code coverage. Of course, that doesn’t mean that every condition is tested or that the code does the right
thing, but it is certainly a great statrt.</p>
<p>We still sometimes release our code with bugs, but once a bug is found, we can write a test that exposes it by
failing. Then once the test passes, that bug will never bother us again.  We get into a rhythm of writing the test,
making it pass.  It becomes second nature.  It forces us to really know what we are doing.  It makes our brain grow and
our code solid.</p>
</sect2>
  </sect1>


<sect1>
<title>Red, Green, Refactor</title>
<figure id="fig.tdd">
  <title>Test Driven Development Cycle</title>
  <imagedata fileref="images/tdd.svg" align="center" />
</figure>
<p>Test first development is more than just writing the test first. The test first development cycle include series of
steps that are essential to capturing the benefits of a test first approach. We call the cycle "Red, Green, Refactor" because when we first write our test, it fails and the output is colored red.  Then once our code passes, the output is green.  Finally, we go back and <firstuse>refactor</firstuse> our code, meaning that we make it more readable and maintainable without changing its behavior.</p>
<p>We learn to embrace failure. Every test we write starts with a failure and we check that it fails properly before we
start writing our application code.  Why would we be such sticklers about failing?  Because sometimes the behavior of
our application surprises us and it passes without any new code, or we discover that the test wasn’t written correctly
and it passes or fails because of an error in the test. This test-driven development cycle is illustrated in <ref
linkend="fig.tdd" />. We always want to start by watching our test fail to ensure that it fails the way we expect it to fail.</p>
<p>Next we write just enough code to satisfy the error that we saw. We try to write <emph>simplest code that could
possibly work</emph> even if it means hard-coding some value that we’ll flesh out later as we write further tests. This
ensures that we don’t write extra code that we will have to maintain without test coverage and that might not even be
necessary for the current product requirements. </p>
<p>We continue the cycle of writing a little code and running our test again until we’ve written enough code to make our test pass.  Then we’ll go back and rework code that we want to improve for maintainability, readability or performance. We’ll also add tests to flesh out behavior so that we don’t leave hard-coded values in our final implementation.</p>


</sect1>

<sect1>
<title>Defining Our Application</title>
<figure id="fig.mock_home_page">
  <title>Mock Home Page</title>
  <imagedata fileref="images/intro/mock_home_page.png" />
</figure>
<p>Test first development dramatically changes how we define our application. Creating a specification using
tests rather than with words lets us put a stake in the ground early with the flexibility to shift our implementation as
requirements change.</p>
<p>Innovation in business
development is leading toward new processes where paper prototypes lead to working
software that implements a small fraction of the planned product. Feedback from prospective or real customers can
influence changes in direction that ultimately lead to product improvements and a better market fit. We’ll be learning
how to do test driven development, but we’ll be building an application with the goal of learning, rather than iterating
on a specific business need.</p>
<p>Throughout this book, we’ll work on a simple application that will provide many
opportunities to explore how Rails works. As we gain experience with each feature of Rails, we’ll use our knowledge to
write tests to specify new behavior and drive more development.

<ed>The first paragraph in this section isn't working for me at all. It follows "defining the application" section heading with "it doesn't". It just doesn't feel like it belongs here. The second paragraph doesn't really add much either because it somewhat undermines the process a bit - you're saying that what you're going to show us isn't how we will do things 
on a real project. I don't know if you need to say that. You have two goals here. First, you want
 to get people to know enough about Rails to build something, but you want them to learn Rails through exploration and testing, rather than simply following along and banging out some code. So you may want to just come out and say that. "Throughout this book, we'll be working on a simple application that will give us many opportunities to explore how Rails works. As we gain more experience with Rails, we'll use our knowledge to write tests which we then use to drive more development." or something. </ed>
 <author>Sarah:reworked the introduction to this section</author>
 </p>
<p>We’ll be developing an application to manage a creative writing class. <ed>I think this should come before the previous
para</ed><author>Sarah: good idea. done.</author>Each course has a set of assignments and students are expected to submit
their writing assignments through the website. Each student has a page so that everyone in the class can read everyone
else’s work to support class discussions and peer critiques. In <ref linkend="fig.mock_student_page"/>, we can see how
it might look for each student to have a page, where students can see which assignments are
completed, can review old assignments or complete a new one.</p>
<figure id="fig.mock_student_page">
  <title>Mock Student Page</title>
  <imagedata fileref="images/intro/mock_student_page.png" />
</figure>
<p>The application we’re building will have key elements which are part of almost every web application, so that you can take
what you learn in this book and build your own app.</p>
<p>Most web applications have a home page, we’ll make a simple one that links to the different parts of the application.
A mockup of the one we’ll build  is shown in <ref linkend="fig.mock_home_page"/><footnote><p>Screens were sketched using
Balsamiq Mockups: a great tool for getting a feel for the data you want to display and defining the initial interaction design.</p></footnote>. Most production web applications will
have fancier home pages. By the end of the book, we’ll have learned how to put additional dynamic data on a page, but we
won’t dive into additional HTML, CSS, and JavaScript that could be added to create a more effective user experience.</p> 

<p><ed>"By the time we're done, we'll..."?</ed><author>sarah: done</author>By the time we’re done, we’ll make it so that people can log in and only students can write or edit their own
assignments and only the teacher can add courses and make create new assignments for a course.</p>
<p>The data for our application will be stored in a relational
database. We’ll have information about <ed>a data? do you mean table? And should you have a diagram of your
tables?</ed><author>Sarah: the a was out of place, moved to more general english-y term “information”</author> students, lists of assignments and a way to keep track of the different course she has
offered in the past as well as the current one. </p>
<p>If we look at
the volume of code that it takes to build a web application, the majority of it will be common between web applications.
This a key strength of Rails. The framework implements the common behaviors, allowing us to focus on the parts
that are unique to what we want people to be able to do with our application.</p>
<p>We’ll begin with Ruby.</p>

</sect1>
</chapter>
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.migrations">
  <title>Creating Our Database Schema with Migrations</title>
  <p>We will learn about where the database schema
  in our application came from and how a model is created and modified with a migration.</p>
</chapter>
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.preface">
<title>Come On In</title>
<p>We’re diving into Ruby on Rails test first. We’ll be using techniques designed to create robust production code that
can be delivered quickly and adapt nimbly to new business requirements. We’ll experience testing as a software
development methodology, rather than in its traditional use in isolating and resolving defects. In most of the book,
we’ll focus on testing as an effective way to learn a new language and framework.</p>
<p>As kids we explore our world through experimentation. Researchers test hypotheses, learning about our world through
the scientific method. As programmers, we have test frameworks, originally developed for verifying defects, that can be
applied to learning.</p>
<p>Learning programming through testing has been independently discovered by dozens of engineers as a natural way to learn. We use two different kinds of testing in this book.
First we do exploratory testing: like kids exploring nature, we poke around Ruby using an
interactive console called <commandname>irb</commandname> (Interactive RuBy), Ruby’s own REPL (Read Eval Print Loop). Then, we use test
frameworks RSpec and Capybara.</p>
<p>Using test first development techniques, we have the opportunity to see all of the error
messages we will later see in the wild. We explore APIs in detail. We don’t just learn recipes for building an
application with Ruby on Rails – we learn the fundamentals of how the different parts of the framework fit together.
Much of time saving benefit of using a framework is created by the built-in behaviors that happen without our writing
any code at all,
and those are the hardest to learn. Using test first techniques, we can see those behaviors more
clearly and better understand what the framework does for us.
</p>
<p>A happy side benefit of a test first approach to learning is that we are learning to code using best practices. At the
end of the book, we will have written a whole application that includes tests. We will experience how testing helps us
effectively design our code and develop our software. We will see how testing goes beyond the bug find-fix cycle,
liberating us to write great code at high velocity.</p>
<sect1>
<title>Web Development with Rails</title>
<p>Speaking of high velocity, Ruby on Rails is a framework for building web applications that is optimized for
programmer productivity. David Hansson who created Rails in the early 2000s says that it was <emph>extracted</emph>
rather than created. He first wrote Basecamp, a popular online collaboration tool, as a web application in Ruby; then he
pulled out the code which was common to all web applications to create the Rails framework. Rails was created from a real-world use case at a time when web application design patterns were well
established. Since most web applications share a lot of common patterns and behaviors, the Rails framework speeds our
development by letting us create a lot of functionality with very little code.
</p>
<p>Rails is written in the Ruby language. When we develop Rails applications we are writing Ruby code.
First developed in the early 1990s by Japanese engineer, Yukihiro “Matz” Matsumoto, Ruby was designed not only for
programmer productivity, but also to increase programmer happiness. Matz believes that language design must follow the
same principles as user interface design, emphasizing human, rather than computer needs. Today, when time-to-market is
more often the gating factor of software development than compute power, this emphasis of Rails and Ruby on productivity
is particularly valuable.</p>
</sect1>
<sect1>
<title>Who Should Read This Book?</title>
<p>This book is written for programmers.  You’ve been developing in Java, C++, PHP or some other language, or perhaps
you studied programming in college and are considering diving back in with web development. Total beginners might want
to consider starting with Chris Pine's <bookname>Learn to Program</bookname> before jumping into this book.</p>
</sect1>
<sect1>
<title>Software We’ll Need</title>
<p>We recommend working through this book with the same versions of software that were used to write it. Almost
everything will be the same in the next incremental version of anything, but when you are learning, sometimes a small
difference can be confusing.</p>

  <p>Let’s first check that we have the right version of Rails and it is working, by typing <ic>rails -v</ic> on the command line.
  We should see the version printed afterwards.  Throughout this book, we’ll show you command-line output where the
  <ic>$</ic> is our command prompt with what we’re typing after a space on the same line. Then we’ll show you the output
  of the command, like this:</p>
<code language="session">
$ rails -v
Rails 3.0.3
</code>

<p><ed>watch the you vs. we here. It's probably ok to use "you" for these. You can tell us how to install things. We can jump to "we" when we are really doing things together.</ed>To get the most out of this book, we should all be using the same version of Rails. Any version that starts with 3.0
is fine (like 3.0.1 or 3.0.3). If you don’t have the right
version or got an error when you tried to run the <commandname>rails</commandname> command or for any of the commands in
this section, check out <ref linkend="sec.online-resources"/> for online references to installation instructions.</p>
<p>To be able to run the <commandname>rails</commandname> command and build the most minimal application, you will need Ruby and the Ruby Gems packaging manager.</p>
<sect2>
<title>Ruby</title>
<p>Great Rails developers are great Ruby developers. We need Ruby to build and run Rails applications. Check your
version:
</p>
<code language="session">
$ ruby -v
ruby 1.9.2p0 (2010-08-18 revision 29036) [x86_64-darwin10.4.0]
</code>
<p>Ruby 1.8.7 or higher is required for Rails 3.  Ruby 1.9.2 or higher is recommended.</p>
</sect2>

<sect2>
<title>Ruby Gems</title>
<p>A gem is a ruby library. Rubyists like to make up cute names for their creations. Jim Weirich was no exception when
he created Ruby Gems.  A gem is a precious bit of Ruby code that some developer has carved out for its usefulness. 
The name <emph>gem</emph> speaks to the Ruby aesthetic that our code should be beautiful and bring us delight as
well as having practical uses. Ruby Gems has a fabulous packaging system that supports having different versions installed
as well as installing native code extensions. We can also easily install libraries from local or remote sources.  To see
what version of Ruby Gems we have installed:
</p>
<code language="session">
$ gem -v
1.3.7
</code>
<p>To see the gems we have installed:</p>
<code language="session">
$ gem list
</code>
<p><ed>I would very strongly suggest you lose the 'sudo' stuff here. Just tell them to use
RVM.</ed><author>Sarah:removed</author> When we’re developing in Rails, we often add gems that offer functionality that is common to many web applications.
Ruby engineers are exuberant in providing open source implementations of any code that is generally useful, creating an
ecosystem of tools that adds to our velocity as Rails engineers.</p>
</sect2>
<sect2>
<title>Database</title>
<p> In this book, we’ll use SQLite since it is easy to install and is
great for experimentation. A database is not strictly required for a web application built with Rails, but most web applications
provide a user interface on a relational database, so that’s the kind of app we’ll build. The Rails code that we will develop will be database-independent, so we can use any of the
supported databases for deployment or further development.</p>
</sect2>
<sect2>
<title>Editor or IDE</title>
<p>There are a lot of great IDEs that work well for Rails, such as RubyMine, Aptana’s RadRails, TextMate (for the Mac)
and Komodo. Every code editor we’ve tried lately has Ruby syntax highlighting, which is essential for spotting errors. Additionally, it is handy to have a project view to see the directory hierarchy, since
when we develop a Rails application, we often switch between files to follow the flow of control or see the test and the
tested code. We highly recommend finding a IDE you love and learning its ins and outs.</p>
</sect2>
<sect2>
<title>Terminal or Command Prompt</title>
<p>Rails development relies heavily on command-line tools. On Mac or Linux, we run these in the <emph>terminal</emph>,
and on Windows, in the <emph>command prompt</emph>. We like running <emph>gitbash</emph> aka
<emph>msysgit</emph><footnote><p><url>http://code.google.com/p/msysgit/</url></p></footnote> on Windows, which is
distributed with git by the helpful folks who create git for Windows. Gitbash allows us to use the same Unix commands for
moving and copying files as we use on and Linux.</p>
</sect2>
<sect2>
<title>Test Frameworks</title>
<p>Throughout this book, we use RSpec, created by David Chelimsky. RSpec grew out of the behavior-driven development movement
and is focused on the idea that when we write our code test first, we are actually writing a specification of our code.
The key advantage of RSpec both for learning and for building production code is the clarity of its output. This is the
primary reason we use RSpec. When we’re learning, clear output will help us learn from the test failures. When part of
our existing test suite fails during development of new code, being able to clearly see the failure saves time fixing
it. Also, there are many smaller test framework details that work together in RSpec to make tests easier to read and
maintain once we understand the syntax. Trust us, it’s a good way to go, but if you find later that you want to switch
or find yourself in the midst of a project that uses Test::Unit, no worries – the principles and patterns we cover in
this book apply to all test frameworks.</p> 
<p>Like all of
the Ruby test frameworks, RSpec is distributed as a gem. Since we’re building a Rails application, we’ll use the
<commandname>rspec-rails</commandname> gem that includes RSpec and some additional helpers for Rails.</p>
<p>You don’t need these gems installed right now, but here are are the versions we’ll be using:</p>
<code language="session">
$ gem list rspec

*** LOCAL GEMS ***

rspec (2.5.0)
rspec-core (2.5.2, 2.5.1)
rspec-expectations (2.5.0)
rspec-mocks (2.5.0)
rspec-rails (2.5.0)
</code>
<p>We also use Capybara for integration testing:</p>
<code language="session">
$ gem list capybara

*** LOCAL GEMS ***

capybara (0.4.1.2)
</code>
<p>Now you have everything you need to build Ruby on Rails web applications test first.</p>

<p><ed>This is a little strange.... this whole section seemed full of tagents. The "do I have to use a db" part, the
diversion into the various types of databases and the consoles... one of that seems like it belongs in a "how to get set
up" section, which is what this started out as. I know you think this info is important, but does your reader need to
know this stuff right now? Can you get them set up with Rails, SQlite, and then get us on our way? The background info
on RSpec is good, but seems out of place with the installation instructions, especially since we probably shouldn't be
installing the gems this way now that we have Bundler. Another thing i didn't really see is enough of a justification
for using rspec. I could just as easily meet the same requirements with test:unit which is the default. Personally, I
  favor Rspec, but my reasons are completely arbitrary -- I like it cos I like it.  Why are you using it? Does it belong
  in the installation section, or should it go in another section in the preface, where you talk about Ruby and Rails? I
  feel like it belongs there, with the IDE stuff too.</ed><author>Sarah:moved from intro to preface, some stuff in
  appendix, installation stuff
  will go online. This is much more concise and I think it works better.</author></p>

</sect2>


</sect1>
<sect1>
<title>What is in This Book?</title>
<p>Throughout this book, you will learn both the Ruby language and the Rails framework. We first will explore a concept
with exploratory testing through <commandname>irb</commandname> and sometimes with the command line and the browser. 
Then in the following chapter, we will continue our development test first using Ruby automated test frameworks.</p>
<p>In each chapter, we will build one small part of a larger application. The application is for an imaginary
creative writing class and serves as a resource for the students in the class. The domain of the application that we
first implement when learning Rails isn’t important, since most Rails applications, like most web applications, are very
similar to each other. We have some
data that we want to store in a database and later see it again. Sometimes we want to change it or delete it. We want to
provide the user interface in HTML so anyone with a web browser connected to the Internet can access it. Whether it is
the text of a writing assignment, the name and part number of a piece of equipment or items in a product catalog, these
are all just data that we can keep in a database and display in HTML.</p>
<p>In <ref linkend="ch.intro"/>, we’ll  talk about
how testing is first and foremost about good design, how it helps the software development workflow and collaboration,
how we can write more maintainable code and how the creation of tests is a nice artifact of the process, not the
main point. We’ll also introduce how we test first with the Red-Green-Refactor pattern of test first development. We’ll
also talk more about the app we will build in the book and we’ll work through all of the tools and components we need to develop a Rails application.</p>
<p>In <ref linkend="ch.ruby-intro"/>, we’ll learn just enough of the Ruby language to get started with Rails. We’ll
start using <commandname>irb</commandname> and write our first class and a method that we’ll use later in our Rails
application. Then in <ref linkend="ch.rspec-intro"/>, we’ll learn how to use RSpec, the automated test framework that
we’ll use throughout the book. We’ll test drive the development of some Ruby as well as understanding how to test the
code that we already wrote.</p>
<p>In  <ref linkend="ch.firstapp"/>, we’ll start our Rails application with command line generators that we’ll
explore in the browser. We’ll gain some experience with our first Rails pattern, most importantly the
Model-View-Controller (MVC) pattern, which we will learn in more detail throughout the first half of the book. We’ll get
a feel for how views work with ERB (Embedded RuBy) templates.</p>
<p>We’ll learn about ActiveRecord, the <emph>model</emph>, in the MVC pattern, interactively in <ref
linkend="ch.activerecord"/> and with RSpec in <ref
linkend="ch.activerecord-rspec"/>.</p>
<p> In <ref
linkend="ch.rake"/> we’ll get deeper into Ruby code, which will give us a firm foundation for the rest of the book.
We’ll also learn about the command line tool <commandname>rake</commandname>, which is like the Unix tool
<commandname>make</commandname>, but for Ruby. With Rake, we’ll write a Ruby script that uses our ActiveRecord class
that we created in the previous chapters.<ed>in the beforeyoustart chapter you have nearly identical content about Rake.
Do you want to consolidate?</ed><author>Sarah: I think that has been deleted now.</author></p>
<p>In <ref linkend="ch.migrations"/>, we’ll understand how our database schema is created and modified. We’ll learn the
mechanisms of how Rails can be database independent.</p>
<p>In <ref linkend="ch.controllers"/>, we’ll build a dynamic web page one step at a time, experimenting with how the browser
responds with the default Rails behavior and with our code. We’ll get to know how Rails handles HTTP requests. Then
we’ll continue the development of our controller by test-driving the rest of its behavior in <ref
linkend="ch.controllers-rspec"/>.</p>
<p>In <ref linkend="ch.integration"/>, we’ll solidify our understand of the MVC pattern and how it is implemented in
Rails core classes by test driving new behavior with the Capybara integration test framework. <ed>that "rodent" thing
doesn't work for me. it's a bit of a stretch.</ed><author>Sarah: removed</author></p>
<p>In <ref linkend="ch.stubs"/>, we’ll learn more about testing Ruby code, coping with uncertainty when the results of our code are
      non-deterministic and keeping our tests running fast.
</p>
<p>As we add more behavior to our application, in <ref linkend="ch.helpers"/>, we’ll learn some
techniques to keeping our code manageable and easy to read.</p>
<p>In <ref linkend="ch.associations"/>, we’ll take a closer look at ActiveRecord and learn how to leverage the power of
our relational database. Through <commandname>rails console</commandname>, we’ll gain experience with common association
methods in a “has many” relationship. Then, in <ref linkend="ch.associations-rspec"/> we’ll learn more about the details
by understanding how to define associations with RSpec.</p>
<p>In <ref linkend="ch.has-many-through"/>, we’ll learn how to create a many-to-many relationship using another kind of association.</p>
<p>In <ref linkend="ch.auth"/>, we’ll gain experience using a gem to extend Rails. We’ll also learn about how to lock
down controller actions, securing the entry points to our app with “before” filters. </p>
<p>At the end of the book, inn <ref linkend="ch.dunno"/>, we’ll highlight the parts of Rails that you’ll want to learn
next.</p> 
<p><author>Sarah: if you like the way this is going, I’ll fill in the rest.</author><ed>yup keep going.</ed>
 <ed>you've said this a couple of times. </ed> Through testing and experimentation, we’ll have
developed a thorough understanding of Rails. You will know
enough to build an intranet application or kick-off the development of a small-scale web app, and you will have enough
of a foundation to support further learning on your own to create highly-scalable consumer-facing web applications. </p>
</sect1>
<sect1 id="sec.online-resources" >
<title>Online Resources</title>
<p>
This book has its own web page, <url>http://pragprog.com/titles/satfr</url>, where you can find more information about the book.
You can:</p>
<ul>
<li><p>Get links to all of the software dependencies, so you can install what you need to work through the examples.</p></li>
<li><p>Download the full source code for the application that we’ll build in the book, including code for the
intermediate stages and Ruby scripts.</p></li>
<li><p>Participate in a discussion forum with Sarah, Liah, and other readers like you.</p></li>
<li><p>Help improve the book by reporting typos and code that didn’t work the way you expected. We also welcome
suggestions for improvement.</p></li>
</ul>
<p>You are free to use the source code in your own applications in any way that you want. If you’re reading the ebook, you can also click the little gray rectangle before the code listings to download that source file directly.</p>
<p>Throughout the book, we’ll also point you to online resources where you can learn more about Ruby and Rails.</p>
</sect1>

<sect1>
<title>How to Read This Book</title>
<p>Except for  <ref linkend="ch.intro"/><ed>ref it, don't say "the first chapter"</ed><author>Sarah:ok</author>, this book is not meant to be read on the bus or leaning back on the sofa. You should have hands on the keyboard and try out each experiment. For most of the code, you’ll be able to see the expected result, but now and then we’ll
challenge you to take what you’ve learned and write some of the application on your own.</p>
<p>Let’s start by learning a bit more about why and how we write code test first.  </p>
<p><ed>I think you did a good job on this chapter, but I think you both need to read this and the beforeyoustart chapter together and consolidate some of the information. I think some things are in the wrong place and other things are definitely repeated. There are a couple of sections in the beforeyoustart that could go here, and a little bit of content  here that could go over there. The first paragraph isn't really a good first paragraph but it's a great second paragraph. "come on in" is such a great welcoming title, but the paragraph that follows is a little weak.</ed></p>


</sect1>
</chapter>
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.firstapp">
  <title>Diving Into Rails</title>
   
<p>Rails engineers are some of the speediest coders around, in part, because of the effective Rails code generators.
Rails generates just enough code to get us started, but not so much to bog us down. In this chapter, we’ll generate a
Rails app using the command-line generators. We’ll also edit a small amount of code and interact with the application in the
browser. This isn’t test first at all, but before we do any testing we need an
understanding of the tech we’re working with and the patterns we will use in creating web applications.</p>
<p>A two-word command is all we need to
create more than 70 files and directories that make up our first Rails app. These two words are: <ic>rails new</ic>.
Let's use this powerfull command to make a simple application that allows a to keep track of students and their work for
a class.</p>
<p>Along with <ic>rails new</ic> we need to specify an application name, in this case we'll call it <ic>class_app</ic>.
The application name is for our reference as developers and for the most part won't affect the code we generate, but we
don’t want to use a Ruby keyword like <ic>class</ic>. We’re also using RSpec in this book, so we’ll use the <ic>-T</ic>
option to turn off the default Test::Unit code generation:</p>

<code language="session">
$ rails new class_app -T
</code> 
<sidebar>
<title>Creating a Rails App with JRuby</title>
<p>With most versions of Ruby, like REE, MRI and YARV, you don’t need anything extra for Rails. However, JRuby has additional dependencies. To create a Rails app with appropriate dependendencies, the JRuby team has published a handy template:</p>
<code language="session">
$ rails new class_app –m http://jRuby.org
</code>
</sidebar>
<p>Doesn't get much easier than that!  Typing this command into the command line tells Rails to make a directory full of
new files and directories that combine to make a complete framework for our code.  A framework that we call
&lquot;opinionated&rquot; because of its built in patterns.</p>

<p>If you see errors at this step, check <ref linkend="sec.online-resources"/> for online references to installation instructions. Assuming Ruby, Rubygems and the Rails gem are installed properly, you’ll have a
<dir>class_app</dir> directory with dozens of files in it and output on the command line that looks like this: </p>
<code language="session">
      create  
      create  README
      create  Rakefile
      create  config.ru
      create  .gitignore
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  app/mailers
      create  app/models
      create  app/views/layouts/application.html.erb
      create  config
      create  config/routes.rb
      create  config/application.rb
        :
        :
      create  tmp/sockets
      create  tmp/cache
      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
</code>


<p>We have just created a simple, yet complete web application. Rails prefers <emph>convention over
configuration</emph> meaning that having a conventional way of
doing things is preferred to spending time configuring each new project. Rails generates its configuration files 
 with <commandname>rails new</commandname>. Each configuration option has a well-thought out default value, so we can
 get started without spending time on configuration.</p>

<sect1>
<title>Running Our Web App</title>
<p>The whole Rails app is in our newly created <dir>class_app</dir> directory.  This is convenient for a few reasons:</p>
<ul>
<li><p>There are no hidden configuration files in system directories.</p></li>
<li><p>We can delete the directory and its contents if we want to throw it away and start over.
  <footnote><p>We’re using SQLite so even the database is in this directory, but usually the database is the only part
  of our application that lives somewhere else.</p></footnote>
    </p></li>
<li><p>We can simply copy this directory to our server to deploy the app.</p></li>
</ul>
<p>We will add and modify many files in our <dir>class_app</dir> directory during development. All of the commands that we will run on the command line will be at the root of the the application directory, so let’s be sure to change the working directory:</p>
<code language="session">
$ cd class_app
</code>
<p>We have a complete boilerplate web application that has everything it needs to run.  Let’s start up our server:</p>
<code language="session">
$ rails server
=> Booting WEBrick
=> Rails 3.0.1 application starting in development on http://0.0.0.0:3000
=> Call with -d to detach
=> Ctrl-C to shutdown server
[2010-11-28 09:52:39] INFO  WEBrick 1.3.1
[2010-11-28 09:52:39] INFO  Ruby 1.8.7 (2010-08-16) [i686-darwin10.4.0]
[2010-11-28 09:52:39] INFO  WEBrick::HTTPServer#start: pid=27080 port=3000
</code>

<p> We'll need to point our browser at <url>http://localhost:3000</url> to see our running webapp. We can admire our first Rails app in action!  The default home page of the generated Rails web
app, as shown in <ref linkend="fig.welcome-aboard" />, contains information about the app’s configuration and links to documentation.</p>
<figure id="fig.welcome-aboard">
  <title>Default Home Page</title>
  <imagedata fileref="images/welcome-aboard.png" />
</figure>
<p>Our app is all set up with required boilerplate and default configuration.  Let’s make it our own by modifying the home page of the app.</p>
</sect1>

<sect1>
<title>Modifying the Home Page</title>
<p>If this were a static HTML web site, we
would find the home page in the root directory, probably in a file called <filename>index.html</filename>.  There is no
such file in our root directory. Rails will look first for static files in the <dir>public</dir> directory.  Here we
keep static HTML pages and other files such as images, CSS and Javascript.</p>
<p>Rails will look for a static page before it looks for a dynamic page, so if both are available, the static page will win and be served up to the browser.  If we take a look in our <dir>public</dir> directory we will find a file called <filename>index.html</filename>.  This file contains the HTML that formed our home page.  We have found the code we need to modify to make our static homepage more snazzy.</p>
<p>In Rails we can modify most files without stopping and starting the server.  To stop the server, just type control-C,
but it is much easier to just keep the server running.  Let’s open another terminal window and go to the
<dir>class_app</dir> directory, so we can run the server (and see the output) and keep using the command-line in our
first window. Next we’ll open the <filename>/public/index.html</filename> file in an
editor to modify the web page title or some text.</p><p>For example, let’s change:</p>
<code file="code/class_app_new/00a_rails_new/public/index.html" part="title"/>
<p>to:</p>
<figure id="fig.home-page-change">
  <title>Home Page with Modified Title</title>
  <imagedata fileref="images/home-page-change.png" />
</figure>
<code file="code/class_app_new/00b_change_home_page/public/index.html" part="title"/>
<p>Now we can just refresh the page at <url>http://localhost:3000</url> to see that its title now reads “My Cool Web App.” <ref linkend="fig.home-page-change"/> shows a screen shot of the app in the Chrome browser, so the web page title appears as the name of the tab, but it might appear in your browser in the window title bar.
</p>
<p>Now that we know the basics of running our Rails app and understand how the <dir>public</dir> directory
stores static content,  let's set up our web app for development, configuring the test framework we want to use since it
is different from the default and also look at some of the configuration that Rails has already done for us.</p>
</sect1>
<sect1>
 <title>Setting up RSpec for Rails</title>
 <p>We’ve decided to use the RSpec test framework, instead of the default Test:Unit, so we’ll take a moment and
 configure that.</p> 
   <sidebar>
  <title>Rails Environments</title>
   <p>The group names in our Gemfile
  match the names of our Rails environments. Rails starts with configuration for three environments: development, test,
  and production.</p><p>By default, when we run the server on the command line, Rails will use the development environment.
  When RSpec runs, it will set the environment to test. When we deploy our server for real people to use it, we make
  sure we are running the production environment.</p><p>The <emph>environment</emph> is simply a set of configuration
  options. The general application config is kept in <dir>config/application.rb</dir>, which we can override in the
  specific environment config files:</p>
<code language="session">
$ ls config/environments/
development.rb	production.rb	test.rb
</code>
<p>Also, we have a different log files for each environment, in addition to the web server log file:</p>

<code language="session">
$ ls log
development.log		production.log		server.log		test.log
</code>
<p>The rspec-rails gem provides a rake task,
  <commandname>rake spec</commandname>, which will take care of setting
  the environment to “test” when we run our specs.</p>
  </sidebar>
  <p>
  We need to install the rspec-rails gem, which includes additional configuration and support for working with a Rails
  app.  We specify this dependency in the Gemfile, which we find in the root directory of our Rails app:</p>
<code file="code/class_app_new/00c_add_rspec/Gemfile" part="test"/>  
  <p>By adding rspec-rails to the <ic>:test</ic> and <ic>:development</ic> groups in the Gemfile, we
  tell Rails that we are just using this gem for testing and development. We don’t want our test frameworks to be a dependency in
  production.</p>
 <p> We don’t need to specify that we need the RSpec gem in the Gemfile. Since
  rspec-rails has an
  internal dependency list, it will automatically install RSpec.</p> 
<p>After we’ve edited the Gemfile, we need to call <commandname>bundle</commandname> to tell Rails that we have
modified the dependencies.</p>
<code language="session">
$ bundle
</code>
<p>The <commandname>bundle</commandname> command can take some time because it will go out to the Internet to find gems
that we haven’t installed locally. It will tell us what gems it installs and which ones it just uses from what we
already have installed with Ruby Gems.</p>
<p>
  Now that we have configured Rails to be able to use the RSpec gem, we can use RSpec’s own generator on the command
  line, to create the default configuration and other files required for running RSpec with Rails:</p>
<code language="session">
$ rails generate rspec:install 
      create  .rspec
      create  spec
      create  spec/spec_helper.rb
</code>
<p>The <filename>.rspec</filename> file contains the options for the <commandname>rspec</commandname> command when it is
called with the <commandname>rake</commandname> task. To see all of the options for
<commandname>rspec</commandname>, we can type <ic>rspec --help</ic> on the command-line.</p>
<p>We’ll be keeping all of our specs for our Rails application in the <dir>spec</dir> directory. Inside
<dir>spec</dir>, we now also have <filename>spec_helper.rb</filename>, which contains some additional
configuration needed for using RSpec with Rails. We’ll require <filename>spec_helper.rb</filename> in each spec that we
write for our app.</p>
<p>The name <emph>Rails</emph> is a metaphor for its philosophy. Like
 a train on a track, our development can be very fast with Rails; however, it is not a precise metaphor. Unlike with a
 train, when we follow a slightly different path, we are not immoblized. We can veer a little off the common path and
 still maintain velocity for much of our development. The power of Ruby allows Rails to be flexible. We can adapt it
 to our needs, going incredibly fast when our web app is
 very much like most other web applications in the world and needing to take more time, slowing our development only
 when developing something very unique to our application.</p>

</sect1>




<sect1 id="database-yaml">
<title>Connecting to a Database</title>

<p>Rails excels at creating database-driven web applications. By default, Rails is configured to use a relational database, catering to the most common type of web application. The vast majority of applications on the web today are merely a thin layer of HTML and code on top of a relational database. </p>
<p>We’ll use SQLite as the database in learning Rails because it requires no additional configuration and is easy for learning and
experimenting. You can see that the default Rails configuration uses SQLite in <filename>config/database.yml</filename>:</p>
<code file="code/class_app_new/00c_add_rspec/config/database.yml"/>
<p>In the <filename>database.yml</filename> file there are three sets of configurations: development, test, and production. Typically we want at least these three isolated environments, each with their own database. The <emph>development</emph> environment is the default environment in Rails, which acts as a
sandbox for us to work with new code. </p>


<sect2>
<title>The Rails MVC Pattern and REST</title>
<p>Rails includes a default implementation of the Model-View-Controller pattern with Representational State Transfer (REST).<footnote><p>In 2000, Roy Fielding described REST as an architectural pattern well-suited to web applications.
<url>http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</url></p></footnote>  When we use the REST pattern in our websites we are piggybacking on the Web's architecture.  This makes for intuitive design that benefits us and our users.</p>
<sect3>
<title>REST Principals</title>
<p>The REST architecture simplifies our web application by treating data on the server as an abstract
<emph>resource</emph> with a consistent representation to the client. This allows for a separation of concerns between the user interface and data storage and for stateless communication between client and server.  The key REST principals are:</p>
<ul>
<li><p>Separation of concerns between UI and data storage</p></li>
<li><p>Uniform interface between components</p></li>
<li><p>Stateless communication</p></li>
</ul>
<p>We’ll see this pattern in action with our <class>Person</class> class, which is acts as a <emph>resource</emph> in
Rails.
Rails implements REST by creating a standard set of web pages for the user interface to represent a collection of data.
We’ll start by using scaffold which creates a default representation in both HTML and XML, as well as standard URLs and HTTP actions.  </p>
</sect3>
<p>So, what are the models, views and controllers, exactly?. <ed>this sentence actually seems unnecessary now because
it's nearly a repeat of what you said  at the beginning of the previous sect2. </ed><author>Sarah: agreed but the list
below needs some kind of intro, edited.</author></p>
<ul>
 <li><p><emph>Model</emph> represents what is in the database</p></li>
 <li><p><emph>View</emph> is typically HTML, rendered from a template which mixes static content and dynamic data</p></li>
 <li><p><emph>Controller</emph> receives HTTP actions (GET, POST, PUT, DELETE) and then decides what to do, typically rendering a view</p>
 </li>
</ul>
<p> In <ref linkend="fig.rails-mvc"/> you can see the HTTP request-response cycle showing the
flow-of-control through the controller, to the model, then to the view. 
The visitor types a URL into the browser which generates an HTTP request to the Rails web app. That request is handled by a class
called a <emph>controller</emph>. The controller will typically use a <emph>model</emph> to get data from the database which it then renders
using a <emph>view</emph>. Rendering the view creates HTML which is sent to the browser and displayed. Then the visitor
may click a link, which generates a request, and the cycle begins again. </p>
<figure id="fig.rails-mvc">
  <title>The MVC Request-Response Cycle</title>
  <imagedata fileref="images/rails-mvc.pdf" />
</figure>
<p>The easiest way to understand this is by example.  Before we create a web application of our own design, let’s use
the Rails scaffold generator to get a feel for the Rails patterns that are easy to build in our own applications. The
<commandname>rails generate scaffold</commandname> command creates a set of web pages and Ruby code for accessing the database and responding to HTTP requests. Rails makes it easy to develop web pages and application code for standard database operations: create, read, update, and delete. </p>
<p>Our application needs to have a list of people in a class.
We’ll specify that we want to create a <ic>person</ic> object that has <ic>given_name</ic> and <ic>surname</ic> attributes which are both strings. </p>
<code language="session">
$ rails generate scaffold person given_name:string surname:string
      invoke  active_record
      create    db/migrate/20110508181731_create_people.rb
      create    app/models/person.rb
      invoke    rspec
      create      spec/models/person_spec.rb
       route  resources :people
      invoke  scaffold_controller
      create    app/controllers/people_controller.rb
      invoke    erb
      create      app/views/people
      create      app/views/people/index.html.erb
      create      app/views/people/edit.html.erb
      create      app/views/people/show.html.erb
      create      app/views/people/new.html.erb
      create      app/views/people/_form.html.erb
      invoke    rspec
      create      spec/controllers/people_controller_spec.rb
      create      spec/views/people/edit.html.erb_spec.rb
      create      spec/views/people/index.html.erb_spec.rb
      create      spec/views/people/new.html.erb_spec.rb
      create      spec/views/people/show.html.erb_spec.rb
      invoke      helper
      create        spec/helpers/people_helper_spec.rb
      create      spec/routing/people_routing_spec.rb
      invoke      rspec
      create        spec/requests/people_spec.rb
      invoke    helper
      create      app/helpers/people_helper.rb
      invoke      rspec
      invoke  stylesheets
      create    public/stylesheets/scaffold.css
</code>
<p>Since we’re using SQLite we don’t need to do anything special to create the database that our app will use. For any
other kind of database, we would need to call <ic>rake db:create:all</ic> which does nothing when we are using SQLite.</p>
<p>With three environments, specified in <filename>database.yml</filename>, our application will have three databases.
When we experiment with our code interactively, we use the <emph>development</emph> environment and the development database.  With Rails we create database tables and make schema changes using a <emph>migration</emph>, which we'll learn more about in <ref linkend="ch.migrations"/>. Our person object will store its data in a table in the database. To create the table we call:</p>
<code language="session">
$ rake db:migrate
(in .../class_app)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -> 0.0012s
==  CreatePeople: migrated (0.0013s) ==========================================
</code>
<p>We can see by the output that we just created a <emph>people</emph> table in the database.  </p>
</sect2>
<sect2>
<title>What’s up with these plural nouns?</title>
<figure id="fig.pluralization">
  <title>MVC Pattern with Pluralized Names</title>
  <imagedata fileref="images/pluralization.pdf" />
</figure>
<p>How did we get a list of <emph>people</emph> when we specified that
we wanted a <emph>person</emph> object? Rails prides itself in letting
programmers be human and speak in English. If we have a person object, a collection of those objects should be
grammatically correct. We should be able to call them people, both in terms of the user interface and internally in the
code. Rails follows a set of naming conventions where a single entity, such as a &lquot;customer&rquot; is referred to in the singular, whereas collections, like a bunch of &lquot;customers&rquot;  are
referred to as plural. To put it another way, the model object which refers to a single row in the database table is singular, but the
table itself which stores the data for a whole collection of models is plural. The default names in Rails take advantage of helper methods to pluralize the model name to create the
database table name and other names too.  We’ll get into the details of database tables, model and controller classes
and how they work in a bit, but first let’s look at how they are named.</p>

<joeasks>
<title>How does Rails know about irregular nouns?</title>
<p>Pluralization rules are controlled by the ActiveSupport::Inflector class in Rails. The <commandname>rails new</commandname> command generates a placeholder configuration file with comments that indicate exactly how to configure this.</p>
<p>Using <ic>rails console</ic> we can see that the irregular noun "foot" is not correctly pluralized in Rails.</p>
<code language="session">
> "foot".pluralize
 => "foots" 
</code>
<p>To fix this, let’s edit the file <filename>config/initializers/inflections.rb</filename> changing the commented out person/people line to
foot/feet:</p>
<code file="code/class_app_new/00c_add_rspec/config/initializers/inflections.rb" />
<p>Now when we go back to the console (after exiting and  starting again, <commandname>reload!</commandname> is not sufficient in this
case) we’ll  see the correct pluralization:</p>
<code language="session">
> "foot".pluralize
 => "feet" 
</code>
<p>Looking at <filename>inflections.rb</filename>, we can see that Rails supports flexible rules for pluralization,
which are well documented in the API
reference<footnote><p><url>http://api.rubyonrails.org/classes/ActiveSupport/Inflector/Inflections.html</url></p></footnote>.

There’s also a nice interactive demonstration of Rails pluralization online<footnote><p>
<url>http://nubyonrails.com/tools/pluralize</url></p></footnote>.</p>

<p>Internally, Rails uses Ruby to extend the <class>String</class> class to include a
<method>pluralize</method> method.</p>

</joeasks>
<sect3>
<title>Models are Singular</title>

<p>The model represents a single object (which maps to a single row in the corresponding database table). You’ll find
the code for the <class>Person</class> class in <filename>app/models/person.rb</filename></p>
<code file="code/class_app_new/00d_person_scaffold/app/models/person.rb"/>
<p>This code is explained in <ref linkend="ch.activerecord"/></p>
</sect3>
<sect3>
<title>Views Directory is Plural</title>
<p>There are many views for a specific model, so the views sub-directory is plural. For the whole application there is a
<dir>views</dir> directory. The views associated with this model and controller are kept in the
<dir>people</dir> directory.</p>
</sect3>
<sect3>
<title>Database tables are Plural</title>
<p>A database table stores the data for a collection of model objects so the table is named with a plural
noun.  We keep data in a <ic>people</ic> table.</p>
<code language="session">
rails dbconsole
>> select * from people;
</code>
<p>We'll learn more about interacting with the database console in <ref linkend="ch.activerecord"/>.</p>
</sect3>
<sect3>
<title>Controllers are Plural</title>
<p>The controller works with a collection of models so its name is plural.  In
<filename>app/controllers/people_controller.rb</filename>, we can see that <class>PeopleController</class> is a
subclass of <class>ApplicationController</class>. We have just one <emph>application</emph> that provides access
to a list of <emph>people</emph>.</p>
<code file="code/class_app_new/00d_person_scaffold/app/controllers/people_controller.rb"  part="class"/>
<p>This code is explained in <ref linkend="ch.controllers"/></p>
</sect3>
</sect2>
<sect2>
<title>What are all these files generated by scaffold?</title>
<p>Let’s take a quick look at the files that were generated by the <commandname>rails generate
scaffold</commandname> command. We will focus on the core files that implement the MVC pattern.</p>
<p>The <emph>model</emph>, which we’ll look at in depth in the <ref linkend="ch.activerecord"/> has two associated files. The
<class>Person</class> class that implements the model in <filename>person.rb</filename> and the migration that creates the database table that we executed with the “rake db:migrate” command.</p>
<ul>
 <li><p>app/models/person.rb</p></li>
 <li><p>db/migrate/20090611073227_create_people.rb</p></li>
</ul>
<p>The <emph>controller</emph>, which we’ll learn all about in <ref linkend="ch.controllers"/> is implemented in the PeopleController class in people_controller.rb. It also has a line added to the routes configuration in config/routes.rb which affects how the URL requested from the browser triggers controller actions. </p>
<ul>
 <li><p>app/controllers/people_controller.rb</p></li>
 <li><p>route map.resources :people</p></li>
</ul>
<p>The <emph>views</emph> generated by scaffold are the four pages required for create, update, delete and viewing all
of the data in a table and a the details of a single record. plus a fifth file (_form.html.erb) which
contains snippet of code which is shared by two of the other views. We’ll learn a little about views in <ref
linkend="sec.intro-views"/> and more
in <ref linkend="ch.integration"/>.</p>
<ul>
 <li><p>app/views/people/index.html.erb</p></li>
 <li><p>app/views/people/show.html.erb</p></li>
 <li><p>app/views/people/new.html.erb</p></li>
 <li><p>app/views/people/edit.html.erb</p></li>
 <li><p>app/views/people/_form.html.erb</p></li>
</ul>
</sect2>
<sect2>
<title>Exploring the HTML Generated with Scaffold</title>
<p>To see our scaffold in action, we don't need to stop the server, just browse to
<url>http://localhost:3000/people</url>.  Here we see a the listing of the <emph>people</emph> in the database --
a plural noun for the default URL because the page displays a collection.</p>

<p>We have an empty list right now, as shown in <ref linkend="fig.people-listing-empty" />, but we can see that with
just one command we have a complete web interface for adding, editing and deleting records from our database. We'll
explore it a bit to understand how different parts of Rails work together to create a compelling default implementation
of REST using the MVC pattern.</p>
<figure id="fig.people-listing-empty">
  <title>Index Page with No Data</title>
  <imagedata fileref="images/people-listing-empty.png"  />
</figure>
<sect3 id="sec.scaffold-rest-mvc">
<title>How Does Scaffold Implement REST and MVC?</title>
<p>The <commandname>generate scaffold</commandname> command adds just one line to <filename>config/routes.rb</filename>, which implements all of the REST
URLs: <ic>resources :people</ic>. We'll explore more details about routes in <ref linkend="ch.controllers"/>.  Using
the <method>resources</method> method for 
a route allows us to specify a whole group of URLs. In just one line, we can express all of the URLs needed for the common database
interactions.</p>

<p>Under the class_app application, we can inspect our routes on
the command-line using a useful rake task:</p>
<code language="session">
$ rake routes     
people GET	/people(.:format)     	{:action=>"index", :controller=>"people"}
people POST	/people(.:format)      	{:action=>"create", :controller=>"people"}
new_person GET	/people/new(.:format)	{:action=>"new", :controller=>"people"}
edit_person GET	/people/:id/edit(.:format) {:action=>"edit", :controller=>"people"}
person GET	/people/:id(.:format)  	{:action=>"show", :controller=>"people"}
person PUT	/people/:id(.:format)  	{:action=>"update", :controller=>"people"}
person DELETE	/people/:id(.:format)  	{:action=>"destroy", :controller=>"people"}
</code>
<p>Looking at the first line, we can see that the <ic>/people</ic> URL maps to the <ic>index</ic> action when we type
the URL into the browser or follow a link, which results in an HTTP GET request. However, when the same URL is sent an HTTP POST request, the <method>create</method> action is triggered.</p>
<p> Let’s go back to our browser to see how this works.  When we click the <emph>New Person</emph> link, we move to a page with a form where we can input data for a new Person record.  The <emph>new</emph> page, as shown in <ref
linkend="fig.new-person" />, corresponds to the URL <ic>/people/new</ic>.  </p>
<figure id="fig.new-person">
  <title>The  “New” Page</title>
  <imagedata fileref="images/new-person.png"  />
</figure>

<p>When we fill in the fields with a name, like “Fred” for the first name and “Flintstone” for the last name and click
“Create Person” the browser will send an HTTP POST to the <ic>/people</ic> URL.  The <method>create</method>
action inserts a new record in the database and redirects to the <emph>show</emph> page, which is <ic>/people/1</ic> for
our first record.</p>

<p>We can then click the “Back” link and to see the the list of people which includes our new record, as shown in <ref
linkend="fig.people-listing-fred" />.</p>
<figure id="fig.people-listing-fred">
  <title>Index Page with One Record</title>
  <imagedata fileref="images/people-listing-fred.png" />
</figure>

<p>From the people index page we now have the option to show the detail page, edit the record or destroy the record. Go ahead and create a few people for your list. Experiment with editing and deleting a record.</p>
</sect3>
</sect2>

</sect1>

<sect1 id="sec.intro-views">
<title>Editing Views</title>
<p>View files, also known as <emph>templates</emph>, ending in .erb are <emph>Embedded Ruby</emph> files.  Similar to JSP, ASP and PHP, these are dynamic web pages that mix HTML and Ruby code.</p>
<p><ic>&lt;%  ... %></ic>	executes Ruby code	(e.g., setting up conditionals) </p>
<p><ic>&lt;%= ... %></ic>	evaluates Ruby code, inserting the result in HTML	
(e.g., displaying value returned from a method) 
</p>
<p>Let’s look at part of the code in <filename>app/views/people/index.html.erb</filename>:</p>
<code file="code/class_app_new/00d_person_scaffold/app/views/people/index.html.erb" part="example"/>

<p>On line <cref linkend="code.people-index.each"/>, in between &lt;% and %&gt; is Ruby code, where <ic>@people</ic> is an instance variable containing an array of
person objects which have a given_name and surname attribute. Calling <method>each</method> on the array
iterates over the list, each time assigning the next object to the variable <ic>person</ic> which is available to the
following block of code. Notice that the loop ends on line <cref linkend="code.people-index.end"/> – you can continue a multiline
Ruby expression with HTML interspersed. For every iteration, the inner lines HTML will be output as part of the response, so we will see a table row for each person in the collection.</p>
<p>Inside the loop, the Ruby code is evaluated as part of the output stream. <ic>&lt;%= person.first_name
%&gt;</ic> will evaluate <ic>(person.first_name).to_s</ic> and insert the result into the given HTML. If we had Fred Flintstone and Barney Rubble in our list, we would see the following HTML response:</p>

<code language="html"> 
<tr>
    <td>Fred</td>
    <td>Flintstone</td>
</tr>
<tr>
    <td>Barney</td>
    <td>Rubble</td>
</tr>
</code>

<p>The key points to remember are that <ic>&lt;%</ic> just lets us execute Ruby code and that <ic>&lt;%=</ic> will call
<ic>to_s</ic> on the result and insert it into the HTML that is generated.</p>
<sect2>
<title>Exercise</title>
<p>On the main people page </p>
<ol>
<li><p>Change &lquot;Listing people&rquot; to &lquot;My Class List&rquot;</p></li>
<li><p>List people with first initial and last name in one visual column (e.g. F. Flintstone) </p></li>
</ol>
<p>When editing views, you will see some helper methods that we haven’t explained yet. Don’t worry about them for now,
you’ll need to understand models, controllers and routes first. However, you may find them fairly easy to read and
understand anyhow. The intent with Rails views is that any Ruby code is small and human readable, so that someone
familiar with HTML and the high-level functionality of the applications would be able to change the visual appearance of
the page, moving around elements generated with Ruby without necessarily understanding the code underneath. Go ahead and
try the exercise yourself before we go through it together. It’s okay. We’ll wait.</p>
</sect2>
<sect2>
<title>Solution</title>
<p>To modify the main page, we need to edit <filename>app/views/people/index.html.erb</filename>. The first challenge is changing plain
HTML. We can see “Listing people” in an <ic>&lt;h1&gt;</ic> tag at the top and we can just change the text to “My Class
List”. For the second challenge, we need to
remove a visual column <ic>&lt;th&gt;Last Name&lt;/th&gt;</ic> and combine the two table cells (<ic>&lt;td&gt;</ic> tags) into one Ruby
expression that concatenates the first letter of the first name with the last name. Below we use string interpolation to
accomplish this the results can be seen in <ref linkend="fig.people-listing" />.</p>
<code file="code/class_app_new/00e_view_edits/app/views/people/index.html.erb" part="example"/>
</sect2>

<figure id="fig.people-listing">
  <title>Modified People Index Page</title>
  <imagedata fileref="images/people-listing.png"/>
</figure>
<p>We have created our first database-driven Rails application using the <commandname>rails new</commandname> and
<commandname>generate scaffold</commandname> commands.</p>
<sect2 id="sec.running-tests">
<title>Running Our Tests</title>
<p>Since we configured our application to use RSpec, when we
generated our scaffold, Rails generated tests for our model, views and controller. Since we just modified the code
without test-driving it, let’s take a look at what happens when we run the tests:</p>
<code language="session">
$ rake spec
(in /Users/sarah/…/class_app_new_source)
...............**.........F..

Pending:
  PeopleHelper add some examples to (or delete) …/people_helper_spec.rb
    # Not Yet Implemented
    # ./spec/helpers/people_helper_spec.rb:14
  Person add some examples to (or delete) …/spec/models/person_spec.rb
    # Not Yet Implemented
    # ./spec/models/person_spec.rb:4

Failures:

  1) people/index.html.erb renders a list of people
     Failure/Error: assert_select "tr>td", :text => "Given Name".to_s,…
     MiniTest::Assertion:
       <"Given Name"> expected but was
       <"G Surname">.
     # (eval):2:in `assert'
     # ./spec/views/people/index.html.erb_spec.rb:20:in `block (2 lev…

Finished in 0.39219 seconds
29 examples, 1 failure, 2 pending
rake aborted!
</code>
<p>RSpec will first print out one character per test. The dots are for tests that pass, <ic>*</ic> for
<firstuse>pending</firstuse> specs that are placeholders for tests we plan to write later, and <ic>F</ic> for a failing
test. The RSpec framework creates some tests for us and for other parts of our code, it
leaves them for us to fill in. We can see that our change in the view introduced a test failure. We don’t want to leave our code with failing and pending tests, so let’s just delete
those files now. Later we’ll learn how to add our own test code, but for now we want to just leave this chapter with all
of our tests passing.</p>
<code language="session">
$ rm spec/views/people/index.html.erb_spec.rb
$ rm spec/models/person_spec.rb
$ rm spec/helpers/people_helper_spec.rb
$ rake spec
(in …/code/class_app_new_source)
…/bin/ruby -S bundle exec rspec ./spec/controllers/people_controller_spec.rb
./spec/requests/people_spec.rb ./spec/routing/people_routing_spec.rb ./spec/
views/people/edit.html.erb_spec.rb ./spec/views/people/new.html.erb_spec.rb 
./spec/views/people/show.html.erb_spec.rb
..........................

Finished in 0.34845 seconds
26 examples, 0 failures
</code>
<p>Scaffold is rarely used in the development of production Rails applications, largely because the generated code may
or may not fit exactly what we need, and can lead to maintenance headaches if we’re not careful to delete unused code
and modify or delete broken tests as we develop our application. However, scaffold is an effective learning and
prototyping tool.</p>
</sect2>
<p>Through our experiments with scaffold, we have a feel for how the
Model-View-Controller pattern works in Rails and the default implementation of REST. We understand how to edit view
templates and the static files that we keep in the <dir>public</dir> directory.  Next we'll dive deeper into
models, controllers and views using interactive testing with the Rails console and test first learning with RSpec. </p>

</sect1> 
</chapter>
<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.rake">
  <title>Rake Helps us Organize Our Ruby Scripts</title>
  <p>Remember how we created our database back in the ActiveRecord chapter?  It went something like this: <ic>rake db:create</ic> and then <ic>rake db:migrate</ic>. These commands are called rake tasks.  Rake is a build program written in Ruby.  It is also another example of a Domain Specific Language (DSL), meaning that it is a new language that sits on top of Ruby with the sole purpose of building files and running scripts. Rake tasks are great because they make our lives easier.  How would we have created our database without rake?  We could have used a sql console to create the database, add the tables and indexes.  Sounds much more time consuming and error prone than using our two rake commands, right?</p>
  
  <p>
    We've seen first hand how powerful rake can be.  Would you believe that when Jim Wierich came up with the idea for rake, he wasn't convinced it would be of use to Ruby programmers?  It's true.  Read all about it yourself and have a good giggle: http://rake.rubyforge.org/files/doc/rational_rdoc.html.  In this document Jim concedes that he's not sure that anyone would be interested in it.  Thankfully, Jim went ahead and built rake anyway.  Without rake (or something like it), we would need to worry about xml files or finicky Make syntax. Perhaps the most brilliant thing about rake is that we get to continue using Ruby.  With Rake we can use the basic DSL syntax for most tasks.  When tasks are more complex and the rake DSL doesn't have a solution, we can easily use Ruby from within Rake to accomplish our goal. 
  </p>
  <p>
    Let's get ready to learn all about rake.  We'll start off by understanding the basic syntax of common rake tasks.  Later we'll have a chance to talk about Ruby <firstuse>blocks</firstuse> and <firstuse>method missing</firstuse>.  First, let's start off learning about the rake tasks we've already used.
  </p>

<sect1>
  <title>ActiveRecord Built In Rake Tasks</title>
  <p>
    We can see all of the rake tasks that are built into our installed gems by running <ic>rake -T</ic> on the command line.  If we type <ic>rake -T db</ic>, we see a list of our tasks that include the characters <ic>db</ic>.  We see several familiar tasks that we've run before such as <ic>rake db:create</ic> and <ic>rake db:migrate</ic>.  Let's take a moment to dig into how rake tasks do what they do.
  </p>
  <p>
    Let's start off by understanding a task we've used before, <ic>rake db:create</ic>.  We can find this task inside of the activerecord gem.  We can see where the activerecord gem is installed with the following command: <ic>bundle show activerecord</ic>.  The output of this command should be a path to the gem directory.  Now here's a fancy trick: <ic>cd `bundle show activerecord`</ic>.  The code inside of the tic marks is executed so that we move into the directory where the activerecord gem is installed.  When doing Rails development we often need to get a better understanding of how a gem works.  Knowing how to navigate to each gem will make this easy.  Once we open up a gem, we can even put debugging information into the gem's code to inspect variables and make sure the right methods are getting called.
  </p>
  <sect2>
    <title>Namespaces in Rake Files</title>
      <p>
        To see how <ic>rake db:create</ic> works, let's open this file: lib/active_record/railties/databases.rake in a text editor. Check out that first line, <ic>namespace :db do</ic>.  The <method>namespace</method> method is defined in the rake gem and does exactly what it sounds like it would do. It allows us to create namespaces for our tasks, putting different tasks into different categories.  The <ic>rake db:create</ic> command is put into the namespace of <ic>db</ic>, short for database.  When we run the command we put a colon after the namespace and then type the name of the task, in this case our task is <ic>create</ic>.    
        
          

        explain rake db:create, rake db:migrate, rake db:seed
        rake -T
    </p>
  </sect2>
</sect1>

<sect1>
  <title>Test Driving A Custom Rake Task</title>
  <p>
    create a rake db:seed task (test first)
  getting rails environment to be loaded in the task
  task :add_students => :environment do; #code; end
  also, if you want to specify the environment to run the code in, you can do rake add_students RAILS_ENV=production
  eager loading
(http://stackoverflow.com/questions/4300240/rails-3-rake-task-cant-find-model-in-production) 
  could maybe go into method missing
too(http://stackoverflow.com/questions/4017069/correct-rails-3-replacement-for-envrails-env-production)
 </p>
</sect1>

<sect1>
  <title>Ruby Blocks</title>
  <p>
    explain blocks - show that you can use rake without a block too if your task just consolidates other tasks
 </p>
</sect1>

<sect1>
  <title>Rake Features</title>
  <p>namespaces</p>
  <p>accepting arguments </p>
  <p>desc method for documentation - shows up in rake -T</p>
  <p>default task </p>
</sect1>

<sect1>
  <title>Ruby Blocks</title>
  <p>
    explain blocks - show that you can use rake without a block too if your task just consolidates other tasks
 </p>
</sect1>

<sect1>
  <title>Test Driving Importing Students</title>
  <p>
  rake task that imports students from a csv file
  File, i/o
  open the csv file
  read/write/play with it
  Rake dependencies &amp; methods
  explain task method vs file method
  show how the file rake method works by having a directory that the csv file is in.  (show how dependencies work.)
  Arrays &amp; Hashes
  manipulate the csv data...maybe only insert some of the students into the db?  
 </p>
</sect1>

    
 </chapter>
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.rspec-intro">
  <title>Test First Ruby</title>
<p>We've explored enough Ruby that we are ready to learn RSpec, our key to unlocking the power of testing our code. Of course, there is always more Ruby to learn and we will also learn some more advanced Ruby concepts including attr_accessor methods, hashes, and string interpolation.</p>
<p>By the end of <ref linkend="ch.ruby-intro"/> we had a simple <class>Person</class> class that could store a name.  We’ll continue to work on the <class>Person</class> class, but now we’ll be building it test first with RSpec.  We will use RSpec <firstuse>specs</firstuse> (RSpec lingo for tests) to suss out what our API should look like, and how we want to use our code. Each spec will verify one example of how we expect our code to work. We will end up with a suite of specs that describe a well thought out and detailed technical design of our <class>Person</class> objects.</p>
<sect1>
<title>Writing an Executable Specification</title>
     
     <p>Our <class>Person</class> class already has a <method>full_name</method> method.  Now we need a  <method>given_name</method> method and a <method>surname</method> method that we will concatenate together in our <method>full_name</method> method. We will design our <class>Person</class> class so that <method>given_name</method> and <method>surname</method> will be set when we create the object.  We will  also be able to change them or access them at any time. </p>
     <sect2> 
<title>Creating an RSpec File</title>
<p>By convention, RSpec files are named with a suffix of _spec.rb. A single RSpec file doesn’t need to be named in any
special way, but when we have developed a lot of specs in our Rails applications, we’ll be able to run a whole directory
full of them if we follow this naming style. In Rails, RSpec will use this suffix to know which files to run. Besides it’s just a good idea to be able to look at a
filename and know what’s in it.  So let’s make a spec to test the code we wrote in
<filename>person.rb</filename> by creating a file named <filename>person_spec.rb</filename>.  
</p>
<p>Like Rails, RSpec is its own domain-specific language. We introduced
the idea of a DSL in <ref linkend="side.dsl"/>. The RSpec files we write are Ruby code. RSpec defines a number of methods which when used together make it feel like its own language.  The way RSpec names methods is important.  Method names such as <method>describe</method>, <method>it</method> and <method>should</method> are designed to lead us toward thinking of our application as a set of behaviors rather than as chunks of code. </p>
</sect2>
<sect2>
<title>Describing our Person Class</title> 
<p>
  RSpec's <method>describe</method> method sets the stage for specifying part of our code.  We use it to separate
  different concepts and keep our specs organized. The <method>describe</method> method accepts either a class name or a
  string as a parameter.  Whatever parameter we pass in to the describe block is shown to us when a test fails, so it
  pays off to be thoughtful about what we pass in.  We’ll start our spec, with a <commandname>describe</commandname>
  block telling RSpec that this is a specification for a <class>Person</class> class. 
</p>
     <code file="code/person_spec/00/person_spec.rb"/>
<p>Nested inside of our first describe block are two describe blocks that specify different aspects of the
<class>Person</class> class’s behavior. Even though we aren't testing anything yet, let’s run our spec to see how
<method>describe</method> works. We run specs using the rspec gem.  The rspec gem installs a command-line tool that has the same name as the gem. The <commandname>rspec</commandname> command will load our spec file and call
the gem. Here's how we run it:</p>
     <code language="session">
$ rspec person_spec.rb
/lib/rspec/core/backward_compatibility.rb:20:in `const_missing': 
  uninitialized constant Object::Person (NameError)
	from /code/person_spec/person_spec.rb:2:in `<top (required)>'
	from /rspec-core-2.5.1/lib/rspec/core/configuration.rb:386:in `load'
	from /rspec-core-2.5.1/lib/rspec/core/configuration.rb:386:in `block in 
  load_spec_files'
	from /rspec-core-2.5.1/lib/rspec/core/configuration.rb:386:in `map'
	from /rspec-core-2.5.1/lib/rspec/core/configuration.rb:386:in 
  `load_spec_files'
	from /rspec-core-2.5.1/lib/rspec/core/command_line.rb:18:in `run'
	from /rspec-core-2.5.1/lib/rspec/core/runner.rb:55:in `run_in_process'
	from /rspec-core-2.5.1/lib/rspec/core/runner.rb:46:in `run'
	from /rspec-core-2.5.1/lib/rspec/core/runner.rb:10:in `block in autorun'     
     </code>
     <p>What’s all this? Did we do something wrong? Nope. In test-driven development, we always start with a failing test since we haven't written any code yet. </p>
     <p>This first failure is complaining about a <ic>NameError</ic> for an “uninitialized constant”. We've seen a <ic>NameError</ic> before, right? During our <commandname>irb</commandname> experimentation in the last chapter we got a <ic>NameError</ic> because we hadn't yet defined our <class>Person</class> class (remember classes in Ruby are constants).  Our describe block is describing our <class>Person</class> class which causes RSpec to go look for that class. </p>
     <p> Whenever we pass a class name to a describe block, the class must exist in order for our tests to pass. When we pass a string into a describe block as we did with <ic>describe "name"</ic>, RSpec doesn't care what characters we put in the string. On the other hand, <emph>we do care</emph> about the contents of the string since it serves as documentation for our code and it will be the output we see when we run our spec.

</p>
     <p> What can we do to move past the <ic>NameError</ic>?  We already wrote the code for the class, so the only thing we need to do is tell RSpec where to find it.  We've already learned one way to include the contents of a file.  Remember how we loaded our person file into irb?  We typed in <ic>load 'person.rb'</ic>.  When we call <ic>load</ic>, Ruby will always load the file, no matter how many times we call it. This behavior is what we want in irb when we are experimenting and loading the file again and again. On the other hand, when we have finished with experimenting, it would be better if our file was included just once.  We can achieve this behavior by calling <ic>require</ic> instead of <ic>load</ic>.  Here is how we use <ic>require</ic> to bring our <class>Person</class> class into our spec:
</p>
     <code file="code/person_spec/01/person_spec.rb" part="require"/>
     <p>Ruby expects that the file extension is “.rb” so we can leave it off. As usual,
     Ruby lets us type less and keep our code uncluttered with information that is almost always the same.
     When we write <ic>require './person'</ic>, we are
     telling Ruby that we want to look for a file called <filename>person.rb</filename> in the current directory.</p>
     <p>Now we can run the spec without an error:</p>
<code language="session">
$ rspec person_spec.rb
No examples were matched. Perhaps {:if=>#<Proc:0x00000100bb7e10@/…
/gems/rspec-core-2.5.1/lib/rspec/core/configuration.rb:50 (lambda)>, 
:unless=>#<Proc:0x00000100bb7de8@/…/gems/rspec-core-2.5.1/lib/rspec/
core/configuration.rb:51 (lambda)>} is excluding everything?

Finished in 0.00003 seconds
0 examples, 0 failures
</code>
<p>RSpec tells us <ic>No examples were matched</ic>, which means we haven't written any tests yet.  RSpec is also trying
to be helpful by providing a solution message, but we can ignore it because it doesn’t apply to us. We haven’t written
any examples yet, so we expect that RSpec won't find any.  The next thing to do is begin writing examples of how we
expect our code to behave.</p>
     </sect2>
     <sect2>
     <title>Specifying by Example</title>
     <p>RSpec uses the word <emph>example</emph> to mean individual test case.  There is a good reason to call them examples: it reminds us that we are specifying our code by writing examples of our APIs in action.</p>
         <p>
     We'll start our RSpec example with the <method>it</method> method, which refers to the context from the enclosing
     <method>describe</method>. The <method>it</method> method must be called inside of a describe
     block, otherwise RSpec will
     raise an error. Ideally, each <method>it</method> block will verify just one aspect of our code.   
     </p>
     
     <p>Let’s write our first example for our <class>Person</class> class as we defined it in <ref linkend="ch.ruby-intro"/>: </p>
     <code file="code/person_spec/02/person_spec.rb" part="example1"/>
     <p>We are using the RSpec <method>should</method> method to assert what we expect to happen in our
       code. The syntax is designed to read a bit like English.</p>
<p>Let's take a quick tour of this code.  On line <cref linkend="code.person.new"/> we made a new <class>Person</class> object with an argument of "Hiawatha". We know that this argument will be passed into the <method>initialize</method> method and that our <ic>@name</ic> instance variable will be set to "Hiawatha".  With this knowledge, on line <cref linkend="code.p.full_name.should"/> we say that we expect the <method>full_name</method> method to return the same string that we passed to <ic>Person.new</ic>. We are calling the <method>should</method> method on a <class>String</class> object returned by <method>full_name</method>, but RSpec is designed so that when we are in a spec file we can call the <method>should</method> method on any object.</p>
     <p>This is actually a <emph>test last</emph> approach because we have already written the code for this example.
     Testing our code last is okay on occasion when we’re exploring how our code will work, but we always want to see our test fail first.
     We can ensure that our test fails before it passes by commenting out the implementation of the full_name method like this: </p>
     <code file="code/person_spec/02/person.rb" part="full_name_method_comment"/>
     <p>In Ruby, a comment starts with a <ic>#</ic> which can start anywhere on a line. </p>
<p>Before we run the spec, we think about what will
happen. Remember from <ref linkend="ch.ruby-intro"/> what a method returns when it has no contents? Here's a refresher:</p>
<code language="irb">
$ rspec person_spec.rb 
F

Failures:

  1) Person name must be set on creation
     Failure/Error: p.full_name.should == "Hiawatha" 
       expected: "Hiawatha"
            got: nil (using ==)
     # ./person_spec.rb:11:in `block (3 levels) in <top (required)>'

Finished in 0.00051 seconds
1 example, 1 failure
</code>
  <p>Our answer is that an empty method returns <ic>nil</ic>.  The spec fails as we expect; when we called <ic>p.full_name</ic>, it returned <ic>nil</ic> because we commented out
    the implementation. Let’s look closer at the rest of what RSpec tells us. See the “F”
  on the very first line of the output? RSpec outputs one “F” per failed example (and one “.” per passing example). In this case, “F” stands for failure. This
  seems like a very small indicator now, but for a whole app concise feedback is really helpful. We’ll
  have dozens and eventually hundreds of examples.  If one of our specs fails, RSpec will output more helpful feedback to help us correct the error.</p>
  <p>Now we can uncomment the code in our <method>full_name</method> method and watch it pass:</p>
<code language="session">
$ rspec person_spec.rb
.
Finished in 0.00051 seconds
1 example, 0 failures
</code>
<p>We can see that the initial feedback for a passing test is just one dot.</p>
</sect2>
</sect1>
     <sect1 id="getter_and_setter_methods">
     <title>Creating Getter and Setter Methods</title>
     <p>We’ve developed a <class>Person</class> class that is given a name when it is created.  What
     if we want to change the name after we have already instantiated a <class>person</class> object?  That is a job for a setter method.  If we simply want to get the value of the name, we can write a getter method.  We’ve already written a <method>full_name</method> getter method, but our plan for that method is to compose a full name out of a person's given name and surname. Let's make a method that can get just persons given name.</p>
<sect2>
	<title>Test Driven Getter Method</title>
	    <p>We are about to write a method test first!  Let’s start by specifying that our class will have a <method>given_name</method> getter method:</p>
	     <code file="code/person_spec/02/person_spec.rb" part="example2"/>
	    <p>This spec is very similar to our last one.  We are simply telling RSpec that we expect our <method>given_name</method> method to return the argument we pass in to <method>new</method>. </p>
	<code language="session">    
	$ rspec person_spec.rb
	.F
	  1) Person name can be accessed
	     Failure/Error: p.given_name.should == "Hiawatha"
	     NoMethodError:
	       undefined method `given_name' for #<Person:0x000001008b0730 @name="Hiawatha">
	     # ./person_spec.rb:18:in `block (3 levels) in <top (required)>'

	Finished in 0.00051 seconds
	2 examples, 1 failure
	</code>
	<p>As expected, we see <ic>NoMethodError: undefined method given_name</ic>, so we create a <method>given_name</method> method:</p>
	     <code file="code/person_spec/02/person.rb" part="name_method_only"/>
	     <p>We always want to write as little code as possible to fix the error.  We know that our spec will fail again because it is empty and will return nil rather than "Hiawatha", but we want to be sure that it is failing for the right reason.  This technique of fixing only the error at hand becomes increasingly important as code becomes more complex, so it is a good habit to get into.  Let's run the spec again:</p>
	<code language="session">    
	$ rspec person_spec.rb
	.F
	  1) Person name can be accessed
	     Failure/Error: p.given_name.should == "Hiawatha"
	       expected: "Hiawatha"
	            got: nil (using ==)
	     # ./person_spec.rb:18:in `block (3 levels) in <top (required)>'

	Finished in 0.00051 seconds
	2 examples, 1 failure
	</code>
	<p>We progressed a little bit as we are no longer getting a <ic>NoMethodError</ic> Our empty method is  returning <ic>nil</ic> instead of the <variable>@name</variable>.  Let's go ahead and make it pass in the same way we did for <method>full_name</method>.</p>
	<code file="code/person_spec/02/person.rb" part="name_getter"/>
	<p>Let's run our test again:</p>
	<code language="session">    
		$ rspec person_spec.rb 
		..

		Finished in 0.0005 seconds
		2 examples, 0 failures
	</code>
	<p>Zero failures!  Congratulations, we just completed our first test driven method.</p>
</sect2>

<sect2>
<title>Red, Green, Refactor</title>
<p> Now that we have some passing tests, let's work on making them readable, concise and maintainable.   Refactoring is the word we use when we rewrite our code with readability and maintainability in mind, without changing what it actually does.  It is a kind thing to do for ourselves and our coworkers.  Refactoring is a key term in test-driven development (TDD): we often hear about the “red, green, refactor” workflow. In the first step, “red” describes our failing test. We write the test first and watch it fail. The second step, “green,” represents the stage when we’ve written our code and it works, so the test passes. But we don’t stop there. After the test passes, we have the opportunity to <emph>refactor</emph> the code to make it more concise and maintainable. When we refactor we are changing the code, but not the behavior of the code. </p>
<p>Let's put what we just learned into practice and refactor our spec file.</p>
</sect2>

<sect2>
	<title>Refactoring Our Spec To Use A Before Block</title>
	<p>Before we move on to writing a setter, lets clean up our spec a
little. Both of our examples create <class>Person</class> objects.  We
can remove this repetition by moving the instantiation of our objects
into RSpec's <method>before</method> method.  The <method>before</method>
method allows us to keep all the test setup code in one place.  We can
use instance variables in our specs to store our object across all of our
examples.  Let's take a look:</p>
	     <code file="code/person_spec/03/person_spec.rb" part="before"/>
	<p>The <method>before</method> block runs before each of our
<method>it</method> blocks.  RSpec is using some advanced Ruby features to
	make the <method>it</method> method run whatever code we put into the
<method>before</method> block before the example code is run.</p>
<p>Be sure to run the spec again to make sure it still works.  We are ready to write our setter method.</p>
</sect2>

<sect2>
<title>Test Driven Setter Method</title>
    <p>We’ll put our setter example inside the <ic>describe "name"</ic> so that we can use
    the same person object from the <ic>before</ic> block.</p>
     <code file="code/person_spec/03/person_spec.rb" part="set"/>
    <p>We’re setting <ic>given_name</ic>, getting its value, and then verifying that it retains the value we set. Let’s run it:</p>
<code language="session">
$ rspec person_spec.rb
..F

Failures:

  1) Person name can be set
     Failure/Error: @person.given_name = "Jean"
     NoMethodError:
       undefined method `given_name=' for #<Person:0x000001008b9d30>
     # ./person_spec.rb:18:in `block (3 levels) in <top (required)>'

Finished in 0.00067 seconds
3 examples, 1 failure
</code>
<p>The spec failure tells us that when we write <ic>p.given_name = "Jean"</ic>, Ruby expects that the object has a
<method>given_name=</method> method. We often refer to this as a <firstuse>setter</firstuse>, but its just a
special case of operators as methods in Ruby. Writing <ic>p.given_name = "Jean"</ic>, is just different syntax for
calling the <method>given_name=</method> method in the usual way: <ic>p.given_name=("Jean")</ic>. The Ruby
language parser let’s us put space around the operator, but in other respects, it is just a plain old method call.</p>


    <p>To fix our <ic>NoMethodError</ic>, we define the <ic>given_name=</ic> method:</p>
     <code file="code/person_spec/02/person.rb" part="name_setter_only"/>
    <p>We still haven’t fully implemented the method, but we want to run the spec and see the new failure:</p>
<code language="session">
$ rspec person_spec.rb
.F

Failures:

  1) Person name can be set
     Failure/Error: p.given_name = "Jean"
     ArgumentError:
       wrong number of arguments (1 for 0)
     # ./person.rb:13:in `given_name='
     # ./person_spec.rb:18:in `block (3 levels) in <top (required)>'

Finished in 0.00056 seconds
2 examples, 1 
</code>
<p>Our example now fails because of an <ic>ArgumentError</ic>. When we write <ic>p.given_name = "Jean"</ic>, the string
“Jean” is interpreted by Ruby as an argument to the <ic>given_name=</ic> method. To fix this failure, we declare an
argument:</p>
     <code file="code/person_spec/02/person.rb" part="name_setter_sig"/>
<p>and then run the spec:</p>
<code language="session">
$ rspec person_spec.rb
.F

Failures:

  1) Person name can be set
     Failure/Error: p.given_name.should == "Jean"
       expected: "Jean"
            got: "Hiawatha" (using ==)
     # ./person_spec.rb:19:in `block (3 levels) in <top (required)>'

Finished in 0.00103 seconds
2 examples, 1 failure
</code>
<p>Whew, we’re onto the next line! Now we know our method is defined with the correct name and arguments, and we’re
seeing our example fail because we’re missing internal logic.</p>		
      <p>Our setter method is working just fine except that it doesn't actually set a variable, which is the purpose of
      setter methods.  Setter methods don't set just any variable either.  They set a variable that has a scope of our
      whole object.  As we learned in <ref linkend="ch.ruby-intro"/>, variables within the scope of the object are
      called <emph>instance variables</emph> and start with an <ic>@</ic> symbol. In order for the <method>given_name=</method> method to set an instance variable to a value, it will need to use the argument as the value we give to our instance variable. It will look something like this: </p>
<code file="code/person_spec/02/person.rb" part="name_setter"/>
<p>This is where the importance of instance variables shines.  We set the instance variable in the setter method,
    then it is available throughout our entire object, including inside of our getter method.  Let's go back to irb and
    try out our getter and setter methods working together:</p>
<code language="irb">
$ irb
ruby-1.9.2-p0 > load 'person.rb'
 => true 
> p1 = Person.new("Spock")
 => #<Person:0x00000100a89ea8> 
> p1.given_name
 => "Spock" 
> p1.given_name = "Sarek"
 => "Sarek" 
> p1.given_name
 => "Sarek" 
</code>
		<p>Works like a charm! </p>
</sect2>
</sect1>

<sect1 id="attr_accessor">
		<title>Getting and Setting Instance Variables</title>
    <p> You could name a method anything and return any instance variable from it,
    but we get some benefits if we name getter and setter methods with the same name as the instance variable they allow us to access. For example, for our <method>given_name</method> getter and <method>given_name=</method> setter, we would want an instance variable named <variable>@given_name</variable>.  When we name our code with this convention and need conventional behavior, Ruby offers us the <method>attr_accessor</method> shortcut which we will make use of soon.  First we need to refactor our code to abide by this convention. Let's change the <variable>@name</variable> variable to <variable>@given_name</variable> so that it has the same name as our getter and setter methods:</p>
    <code file="code/person_spec/03/person.rb"/>
    
    
		<p>Our getter and setter methods are currently written out the long way.  Now it is time to learn the shortcut.  Ruby gives us three methods that reduce our getter and setter methods down to one line: <method>attr_reader</method>, <method>attr_writer</method> and <method>attr_accessor</method>.  If we only need the getter method, we use <method>attr_reader</method>.  If we only need the setter method, we use <method>attr_writer</method>.  If we want to create both a getter method and a setter method, we use <method>attr_accessor</method>.</p>
		
		<p>In our case, we can condense our two methods to just one line:</p>
		<code file="code/person_spec/04/person.rb" part="complete"/>
		<p><ic>attr_accessor :given_name</ic> creates both of these methods for us, all in one line:</p>
		<code file="code/person_spec/03/person.rb" part="getter_setter"/>
		
    <p>We run our spec again which verifies that the new code has the same behavior as our initial implementation:</p>
<code language="session">
$ rspec person_spec.rb 
..
Finished in 0.00055 seconds
2 examples, 0 failures
</code>
		<p>Just one more reason to love Ruby!  We condensed six lines into one, and our tests gave us comfort that nothing got broken in the process of cleaning up our code.  Not too shabby.  </p> 
	<p>Luckily, we can get used to shortcuts like this.  Ruby has many of them and Rails makes ample use of them, as well as adding many more.</p>
		
</sect1>


		<sect1>
    <title>Implementing Surname with Attribute Accessor</title>
    <p>So far our <method>full_name</method> method returns the same thing as our <method>given_name</method> getter method.  Our goal is for <method>full_name</method> to return the person's given name and surname together, assuming they have a surname.  If they don't have a surname, then <method>full_name</method> should just return the given name.  Let's test drive implementing the <method>surname</method> method. Our first test will be an example of what happens if the person doesn't have a surname:</p>
			<code file="code/person_spec/04/person_spec.rb" part="surname1"/>
<p>We make a new object on line
<cref linkend="code.person.new.jean"/> and then we tell RSpec on line <cref linkend="code.p.surname"/> that we
expect <ic>surname</ic> to be an empty string. We call this kind of example, the <emph>null test</emph>.</p>
    
    <p>Since we haven’t written any code in our class to support a <ic>surname</ic> attribute, we expect it to fail:</p>

<code language="session">
$ rspec person_spec.rb
..F

Failures:

  1) Person surname is empty if it hasn't been set
     Failure/Error: p.surname.should == ""
     NoMethodError:
       undefined method `surname' for #<Person:0x00000100869088 @name="">
     # ./person_spec.rb:20:in `block (3 levels) in <top (required)>'

Finished in 0.00079 seconds
3 examples, 1 failures
</code>

    <p>If we want to fix just this one failure, let's use the <method>attr_reader</method> short cut for just creating a getter method:</p>

<code file="code/person_spec/04/person.rb" part="attr_reader"/>

<p>We know the return value of an empty method by now (nil), but what about an instance variable that hasn't been set?  When we run this example, the return value of our new <method>surname</method> method (generated by <ic>attr_reader :surname</ic>) will be the value of <variable>@surname</variable>.  We haven't written any code yet to set <variable>@surname</variable>, so let's take this opportunity to learn what an instance variable returns before we set it.</p>
<code language="session">
$ rspec person_spec.rb
..F

Failures:

  1) Person surname is empty if it hasn't been set
     Failure/Error: p.surname.should == ""
       expected: ""
            got: nil (using ==)
     # ./person_spec.rb:20:in `block (3 levels) in <top (required)>'

Finished in 0.00078 seconds
3 examples, 1 failure
</code>
<p>Just like an empty method, instance variables evaluate to <ic>nil</ic>. We don’t get a <ic>NameError</ic> like we do
with local variables if we use them before they are set.</p>
<p>We decided when we wrote the example in our spec that the initial value of <ic>surname</ic> should be an empty string. Let's set <variable>@surname</variable> for every object that is created from our class. We can do that in the initialize method:</p>
<code file="code/person_spec/04/person.rb" part="init"/>
<p>Now let's write a spec that tests that <ic>@surname</ic> is settable:</p>
<code file="code/person_spec/04/person_spec.rb" part="surname2"/>
<p>We expect this spec to fail because we haven't written a <method>surname=</method> method yet.  Let's watch the spec fail as we expect:</p>
<code language="session">
$ rspec person_spec.rb 
...F

Failures:

  1) Person surname can be set
     Failure/Error: p.surname = "Bartik"
     NoMethodError:
       undefined method `surname=' for #<Person:0x0000010085ef48…
     # ./person_spec.rb:26:in `block (3 levels) in <top (required)>'

Finished in 0.0007 seconds
4 examples, 1 failure
</code>
<p>Now we can make our spec pass by adding <ic>:surname</ic> to be accessible:</p>
<code file="code/person_spec/04/person.rb" part="attr"/>

<p>So far we have made a <method>surname</method> getter method using <ic>attr_reader</ic>.  Then we revised our code so that <ic>attr_accessor</ic> created <method>surname</method> and <method>surname=</method>.  We haven't had a situation yet where we only needed a setter method.  If we ever want a variable to only be writable and not readable, we can use <ic>attr_writer</ic>. In our case, we want <variable>@surname</variable> to be readable and writable just like <variable>@given_name</variable>. Now our spec passes with a complete implementation of <method>surname</method> and <method>given_name</method>, but our <method>full_name</method> is still only returning <ic>@given_name</ic>, rather than <ic>@given_name + " " + @surname</ic>.  Let's fix that next.</p>
</sect1>

		<sect1 id="hash_arguments">
			<title>Using Hash Arguments to Initialize an Object</title>
			<p>We now have all the pieces we need to complete our <method>full_name</method> method.  Let's change it so it returns a string with <method>given_name</method> and <method>surname</method> separated by a space.  Both <method>given_name</method> and <method>surname</method> contain strings, which makes this task pretty easy.  In order to do this we will need to understand a little more about strings.  Just like integers, strings can be added together using the <method>+</method> method.  We can use <commandname>irb</commandname> to demonstrate this:</p>
      
<code language="irb">
> load 'person.rb'
> p.given_name + " " + p.surname
=> "Jean Bartik"
</code>
			
		  <p>Let’s write a spec that tests <method>full_name</method>.</p>
			<code file="code/person_spec/05/person_spec.rb" part="full_name1"/>
      <p>We wrote that example using our existing APIs, but it seems a little wordy. It’s awkward to set Jean’s
      first name when calling <method>new</method> and then set her surname on the next line. Here’s one way to approach it:</p>      
			<code file="code/person_spec/05/person_spec.rb" part="full_name2"/>
      <p>We've cut our code down to two lines instead of three, while maintaining the same functionality.  Now what would we expect to happen when we run our spec? We've added a second argument to the <method>new</method> method, which will get passed in to the <method>initialize</method> method.  We might hypothesize that an ArgumentError is in our future.  Let's run our spec to find out if we are right:</p>
<code language='session'>
$rspec person_spec.rb 
...F

Failures:

  1) Person full_name it concatenates given_name and surname
     Failure/Error: p = Person.new("Jean", "Bartik")
     ArgumentError:
       wrong number of arguments (2 for 1)
     # ./person.rb:4:in `initialize'
     # ./person_spec.rb:6:in `new'
     # ./person_spec.rb:6:in `block (3 levels) in <top (required)>'

Finished in 0.00033 seconds
4 examples, 1 failure        
</code>
      <p>
        Just as we suspected, an ArgumentError.  We'll need to allow our <method>initialize</method> method to accept an additional argument for <variable>surname</variable>.  In addition, we'll need to set our <variable>@surname</variable> variable equal to our second argument.  Our code should look like this:
      </p>
      <code file="code/person_spec/05/person.rb" part="two_args"/>
			<p>Now when we run our spec, we have a passing test:</p>
<code language='session'>
$ rspec person_spec.rb 
....

Finished in 0.0003 seconds
4 examples, 0 failure
</code>
      <p> Our <method>full_name</method> method is looking great!  Of course, there is more than one way to write this code.  In our case, we might want to consider changing a few things.  For instance, when we call <ic>Person.new("Gregory", "Frank")</ic>, it isn't clear whether the given_name is the first or second argument.  Then when we call our <method>full_name</method> method, we aren't sure whether this person is named "Gregory Frank" or "Frank Gregory." In this case we would need to look at the source or the docs to determine that his name is actually “Gregory Frank”. It is a good practice to design self-documenting APIs.  We can make this API more self documenting by using Ruby <class>Hash</class> syntax:</p>
			<code file="code/person_spec/05/person_spec.rb" part="full_name3"/>
<p>Now our API is clear and easy to understand. This type of argument list is often called an <emph>options
Hash</emph> and is used a lot in Rails.</p>
<p>Writing code test first is part of our design process. We have the opportunity to get a feel for how our APIs behave
before we implement them. Now that we are happy with our API, let’s move on to the implementation by running our spec and watching it fail:</p>
<code language="session">			
  1) Person full_name it concatenates given_name and surname
     Failure/Error: p = Person.new(:given_name => "Gregory", :surname => "Frank")
     ArgumentError:
       wrong number of arguments (1 for 2)
     # ./person.rb:7:in `initialize'
     # ./person_spec.rb:47:in `new'
     # ./person_spec.rb:47:in `block (3 levels) in <top (required)>'
</code>   
<p>The failure tells us <ic> wrong number of arguments (1 for 2)</ic>, but we’re passing both a given name and a surname. Why does RSpec expect a single argument?</p>
<p>RSpec is cluing us in to another bit of Ruby's syntactic sugar.  In fact, we are only passing in one argument, a hash.  Ruby allows us to drop the curly braces around a hash when we pass it into a method.  This special syntax allows us to write <ic>Person.new({:given_name => "Gregory", :surname => "Frank"})</ic> as <ic>Person.new(:given_name => "Gregory", :surname => "Frank")</ic>.  In this case, we’re using it for the initialize method, but this syntax would work for any method.</p>
<code file="code/person_spec/05/person.rb" part="init"/>
<p>When we accept the argument, we give it a default value by setting it in the argument list. Then we can set the given_name and surname to the values in the Hash. If a value isn’t given for one key or the other, the value will be nil and we can then provide the default value of an empty string.</p>
<p>We can see that works for initialize when we run our spec:</p>
<code language="session">			
$ rspec person_spec.rb
....F

Failures:

  1) Person full_name it concatenates given_name and surname
     Failure/Error: p.full_name.should == "Gregory Frank"
       expected: "Gregory Frank"
            got: "Gregory" (using ==)
     # ./person_spec.rb:31:in `block (3 levels) in <top (required)>'

Finished in 0.00089 sec
</code>   
<p>but it still fails because we haven't finished implementing our <method>full_name</method> to use instance variables. Let’s fix that:</p>
<code file="code/person_spec/06/person.rb" part="full_name"/>
<p>Now when we run our spec:</p>
<code language="session">			
$ rspec person_spec.rb
.....

Finished in 0.00096 seconds
5 examples, 0 failures
</code>   
<p>All of the examples pass. Hooray! We have a complete implementation.</p>
<sidebar>
<title>Variations on the Hash Argument</title>
<p>Let's dig a little deeper into hash arguments.  First off, here is something we can't do: </p>
<code language="irb">
> greg = Person.new {:given_name => "Gregory", :surname => "Frank"}
SyntaxError: (irb):4: syntax error, unexpected tASSOC, expecting '}'
greg = Person.new {:given_name => "Gregory", :surname => "Frank"}
                                  ^
(irb):4: syntax error, unexpected ',', expecting '}'
greg = Person.new {:given_name => "Gregory", :surname => "Frank"}
</code>
<p>Ruby gets confused about precedence when we omit the parentheses. However, we can just provide a list the hash key-value pairs without curly braces:</p>
<code language="irb">			
> greg = Person.new :given_name => "Gregory", :surname => "Frank"
 => #<Person:0x00000100a750c0 @name="Gregory", @surname="Frank"> 
</code>
<p>We can only omit the curly braces when a method has a single Hash argument or the last argument is a Hash. Rails likes to use this kind of syntax a lot.</p>
</sidebar>
</sect1>
		<sect1>
				<title>Using String Interpolation</title>
				<p>Our code is looking pretty good, but suppose we’re experimenting with it and we see a problem:</p>
<code language="irb">			
> p = Person.new
=> #<Person:0xb7786a38>
> p.given_name = nil
=> nil 
> p.full_name
NoMethodError: undefined method `+' for nil:NilClass
</code>
<p>Suppose we want to make sure that full_name always returns a String no matter what we set for given_name and surname. What should we do? Should we look at the <method>full_name</method> implementation to see where the bug is? Not yet. Let’s first write a failing test. We use test-driven development for fixing bugs as well as when we develop new code.</p>
<code file="code/person_spec/06/person_spec.rb" part="empty"/>
<p>We’ll see the same error when we run the spec.</p>
				<p>Our <method>full_name</method> method doesn't work unless <method>given_name</method> and
        <method>surname</method> are set.  If they are not set, the <method>+</method> method throws
        an error because it is being called on nil instead of on a string.  For this reason, we usually use string interpolation instead of <ic>+</ic> to concatenate strings.</p>
<sect2>
<title>String Interpolation</title>
<p>Ruby has concise syntax for evaluating some Ruby code and inserting the result into the string. Let’s see how it
works in irb:</p>
<code language="irb">				
> name = "Gracie"
=> "Gracie" 
> "Goodnight #{name}"
=> "Goodnight Gracie" 
> name = nil
=> nil 
> "Goodnight #{name}"
=> "Goodnight " 
</code>
<p>Using this special syntax, Ruby will always call <method>to_s</method> after evaluating the expression before
concatenating it with the rest of the string. <ic>nil.to_s</ic> results in the empty string, so we never get
<ic>undefined method `+' for nil:NilClass</ic> when we’re using string interpolation. String interpolation only works for strings surrounded by double quotes. Single quotes will interpret the characters literally:</p>

<code language="irb">				
 > name = "Gracie"
 => "Gracie" 
 > puts 'Goodnight #{name}'
Goodnight #{name}
 => nil 
 > puts "Goodnight #{name}"
Goodnight Gracie
 => nil 
</code>
<p>Most of the time single and double quotes act the same, but some characters have special meaning in a double-quoted
string. In addition to string interpolation, the “\” character is used to indicate certain non-ascii characters like
“\n” for newline and 
“\t” for tab and “\u” followed by a hexadecimal number for a unicode character. </p>
</sect2>          

<p>To make our example pass, we can use interpolation. We should also use the <method>strip</method> method to remove the extra space that will be left if either <method>given_name</method> or <method>surname</method> is nil or blank.</p>
<code file="code/person_spec/06/person.rb" part="full_name2"/>
<p>By test-driving our bug fixes, we know that we will never have to fix a bug twice. Our specs also serve as documentation for our fellow developers about the expected behavior of our APIs and what kind of data is supported.</p>
		</sect1>

		
		<sect1>
    <title>What We've Learned</title>
    <p> We've worked hard in this chapter to understand RSpec's syntax and the basic concepts behind writing specs.  We saw how important it is to understand Ruby's error messages when we are test driving our code. <ic>NameError</ic>, <ic>NoMethodError</ic> and <ic>ArgumentError</ic> are becoming familiar and we are starting to know what to do when we run into one of them.</p> 
    
    <p>We are also getting a feel for making improvements to our code so that it is more readable and understandable.  We used an argument hash to clear up any confusion about which argument is the given name vs surname.  We also used string interpolation to ensure that our <method>full_name</method> method always returns a string.  We learned about Ruby's built in <method>attr_accessor</method> and used it to shorten our getter and setter methods from six lines down to one.</p>

      <p>We are still at the beginning of our exploration of Ruby and test-driven development with RSpec. We will continue to learn more about RSpec and Ruby as we move into our study of Rails. Next we'll return to exploratory development and learn about some of the Rails command line tools as we create our web application.
      </p>


 
		</sect1>
</chapter>

<?xml version="1.0" encoding="UTF-8"?>  <!-- -*- xml -*- -->
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.ruby-intro">  
  <title>An Introduction to Ruby</title>
  
    <p>
    Every excellent Rails programmer has a thorough understanding of Ruby — after all, Rails is written in Ruby.  Trying
    to write a Rails program without knowing Ruby is like trying to write a limerick in English without knowing English
    – you could do it with the help of a translator, but it would be much easier with fluency in the language.</p>
    <p>Before we dig into Rails, let's get some grounding in Ruby. Our
    goal right now is to learn Ruby basics. We won’t worry about formalized testing yet, instead we’ll start with
    interactive testing, poking around the language through its interactive console.  In the next chapter we will start
    doing test-driven development (TDD) using what we learn about Ruby in this chapter.  By the end of this chapter we
    will have created some Ruby code, but we will still have plenty to learn about it.  We will explain key Ruby
    concepts as we come to them in the following chapters</p>
    <p>In this book, you will learn just enough Ruby to build Rails
    applications, but we highly recommend diving deeper into the language with Chris Pine’s Learn to Program in Ruby or
    Programming Ruby by our very own publishers Dave and Andy,
    along with Chad Fowler<footnote><p>Chad Fowler started the very first U.S. RubyConf in 2001, which he still
    co-organizes along with RailsConf.</p></footnote>.
    Chris Pine’s book is written for non-programmers, but many experienced programmers find it a fun way to learn the
    language. Programming Ruby, also known as “the Pickaxe book” for the its cover art, is the definitive reference to the language. It was the first English-language
    book about Ruby, and has been enthusiastically kept up to date.
    </p>
    <joeasks>
    <title>What’s an Object?</title>
<p>
Objects allow us to associate data with code that acts on that data. Every object is an <firstuse>instance</firstuse>
of a class.  In other words, one class can provide a structure we use over and over again to make many objects. We make
objects from a class like we make a house from a blueprint. Each house we make has a color, a neighborhood, lights that
turn on and dishes to be cleaned.  Some houses that we make might be red, others brown, but we still need only that one
blueprint to know how to create the structure.  Once the house is built, we can perform actions like turning on the
lights or doing the dishes. When we define these actions in a class, we call them <firstuse>methods</firstuse>.</p>
<p>Ruby's built-in classes allow us to do all kinds of great things, but they provide only general-purpose
functionality.  Most of the time we need to create our own classes so that our applications can do what we need them to
do. As an object-oriented language, Ruby allows Rails to provide powerful classes that encapsulate common patterns of
  web application development. We often create our own classes or <firstuse>sublcass</firstuse> core Rails classes,
  extending them with custom behavior.<ed>THis section feels like it belongs in the "before you start" chapter. It
  doesn't fit with "who should read this book"</ed><author>Sarah: After trying it everywhere else, I think it belongs
  back here. Also re-wrote it some, so hoping it works better now.</author></p>

    </joeasks>
    <p>
      To understand Ruby and Rails we need to understand Ruby objects because they are the cornerstone of most programs we will write.  We will spend most of this chapter learning about objects and classes, along with common error messages that will become key when we start testing.  Before we get started with Ruby objects, lets begin our study of Ruby by becoming familiar with evaluating Ruby expressions and taking a little tour of Ruby's syntax.
    </p>
    <sect1 id="ruby.lang.tools.syntax">
      <title>Using <commandname>irb</commandname> to Explore the Ruby Language</title>
        <p>
             Ruby comes equipped with <commandname>irb</commandname>, which stands for &lquot;Interactive RuBy&rquot;. It allows us to see how Ruby will interpret our code and is a valuable tool in our programmer toolbox.  We will be using <commandname>irb</commandname> throughout this chapter to see our code through Ruby's eyes. 
        </p>
        <p>  
            To access <commandname>irb</commandname>, we type <commandname>irb</commandname> into the command line.  This command gives us a prompt with an angle bracket &lquot;>&rquot; where we can type in Ruby code.  Don’t worry if your command prompt looks a little different — it can be modified with configuration.
             Here’s an example of <commandname>irb</commandname> in action:
             </p>
             <code language="session">
               $ irb
               > 1 + 1
             </code>
             <p>
               Now when we click enter, Ruby will evaluate 1 + 1 and <commandname>irb</commandname> will show us what it returns:
             </p>
             <code language="session">
               => 2
             </code>
             <p>
           Every time we ask <commandname>irb</commandname> to evaluate an expression, it will tell us the result of the evaluation.  
          </p>
          <p>
            Let's move on to exploring some common Ruby idioms using <commandname>irb</commandname>
          </p>
      <sect2 id="ruby.poetry.syntax">
            <title>Poetry Syntax</title>
          <p>
          There are many reasons to love Ruby. One of them is its concise and sometimes poetic syntax. Forget about
          separating expressions with semi-colons and curly braces – we don’t need to in Ruby.   We won’t always wrap our arguments in parentheses unless we need them to indicate precedence.  Let's open up a terminal and type <commandname>irb</commandname>. Then try this out:
          </p>

          <code language="ruby">
            > def combo thing1, thing2
            ?>   thing1 + " and " + thing2
            ?>   end
             => nil
          </code>

          <code language="irb">
            > combo "peanut butter", "jelly"
            => "peanut butter and jelly" 
            > combo("pork chops", "applesauce")
            => "pork chops and applesauce"  
          </code>

          <p>
          We defined the <method>combo</method> method without parentheses around our parameters and the first time, we called
          <method>combo</method> we omitted parentheses around the arguments.  This is absolutely legal in Ruby and is
          called <emph>poetry syntax</emph>. 
          </p>
          <sidebar id="side.dsl">
            <title>Domain Specific Languages</title>
            <p>
              The flexibility of Ruby’s syntax makes it a popular language for the creation of <firstuse>domain-specific
              languages</firstuse> (DSLs).  There are <firstuse>external</firstuse> DSLs like SQL, which are
              domain-specific languages that are implemented using a different language and
              <firstuse>internal</firstuse> DSLs which sit on top of another language, extending its syntax to the
              extent that it feels like a new language.</p>
              <p>Rails is a domain-specific language for web
              application development. RSpec is a DSL for writing executable specifications that test our code. Rake is
              a DSL for executing scripts. Rails, RSpec, and Rake are all internal DSLs written in Ruby. Since they are
              not only written in Ruby, but are executed as Ruby code, they may be extended using Ruby, which gives them
              all of the power and flexibility of Ruby itself.</p>
              <p>Ruby’s poetry syntax and a few other language tricks allow Rails, RSpec and other Ruby DSLs to do a lot with
              very little code.  Understanding the difference between Ruby and DSLs written in Ruby gives us the power
              to quickly understand what code is doing. We will talk more about DSL's in our discussion of RSpec in <ref
              linkend="ch.rspec-intro"/> and Rake in <ref linkend="ch.rake"/>.
            </p>
          </sidebar>
    </sect2> 
    
    <sect2 id="ruby.objects">
     <title>Everything Is an Object</title>
     <p>
       Yep, it’s true.  Everything in Ruby is an object, unlike many other languages.   The fact that strings and numbers are objects means that Ruby can define methods on them.  For example, lets change a string to uppercase:
     </p>

     <code language="irb">
     > "too big for my britches".upcase
      => "TOO BIG FOR MY BRITCHES"
     </code>

     <p>
        The quotation marks in &lquot;too big for my britches&rquot; create an instance of the
        <class>String</class> class where the <method>upcase</method> method is defined.  In some other languages strings and
        numbers are handled specially, but with Ruby they are objects created from built-in classes like <class>String</class>,
        <class>FixNum</class> and <class>Float</class>. Ruby also has built-in collections <class>Array</class> and
        <class>Hash</class> with a wide range of methods that you might have to build yourself in some old-school languages. 
       </p>
    </sect2>
    
    <sect2 id="ruby.operators">
      <title>Ruby Operators Are Methods</title>
      <p>Ah, Ruby...always doing things with a bit of glitz.  Ruby operators are no different.  Most languages have
      operators built into the language as structures of their own.  Ruby defines methods in the <class>FixNum</class>
      and <class>Float</class> classes in order to get <method>+</method>, <method>-</method> and other operators...just
      like how <method>upcase</method> is defined on the <class>String</class> class.  This works because methods are
      just messaged in Ruby, and operators work the same way.  Let's check it out in <commandname>irb</commandname>.</p>
      <code language="session">
      > 1 + 1
      => 2
      </code>

             <p>The plus sign looks like just any old operator we might see in another programming language, but in Ruby it is a method.  Try this:</p>

             <code language="irb">
               > 1.+(1)
               => 2
             </code>

             <p>We can see that the plus symbol is actually a method called on a number object.  When we use the plus
             symbol without the dot Ruby is actually calling the <method>+</method> method behind the scenes.  Ruby gives us some syntactic sugar so that we can write code that looks like the math we learned in Kindergarten without dots.</p>

      			 <p>Other Ruby operators like <ic>-</ic>, <ic>*</ic>, and <ic>/</ic> are also methods and work similarly:</p>

<code language="irb">
> 2.* 4
=> 8 
> 9./ 3
=> 3 
</code>
             <p>Ruby operators work for other objects too.  For instance array and string objects can be added together. In our own classes, we can define methods to make operators work in any way that we want.</p>

    </sect2> 
  </sect1>

  <sect1 id="sec.ruby.class">
    <title>Building Our Own Class</title>
      <p>We've had a quick tour of Ruby concepts and syntax.  Now we are ready to build our own class and create objects
      from it.  Our goal in writing this class is to prepare us for test driven development.  The best way to prepare is
      to write our class step by step, just like how we will work once we are using tests. We’ll actually test
      interactively to understand what happens in Ruby before we’ve written our code. We’ll pay close attention to 
      each error message before learning the code that resolves the error. Knowing different errors and how to fix them
      is a crucial skill using any development methodology.
      Test driven code is first experienced as error driven code, so learning to read and understand Ruby errors will be key going forward.
     </p>    
     
     <p>
      The class we are about to build is very simple.  We are going to create a <class>Person</class> class that has a <method>full_name</method> method.  We will use this method later in Rails application that we build.  Let's get started!
     </p>
    
    <sect2 id="giving_people_full_names">
    <title>Giving People Full Names</title>
    <p>The <method>full_name</method> method of our <class>Person</class> class will
    eventually concatenate different parts of our name together. We’ll start in this chapter by building just one method
    interactively, then we’ll test drive the other methods in the class in the next chapter.  With our <class>Person</class> class, we’ll be able to make objects that respond the same way but have
       different data.
    </p> 
    
      <p>
      Before we get started writing code, we’ll need a file. Ruby files end with a &lquot;.rb&rquot;
      extension.  By convention we’ll name our file <filename>person.rb</filename> after the class we plan to write, but
      it could be called <filename>super_full_name_maker.rb</filename> and it would still work.
    </p>
    </sect2>
    
    <sect2 id="person_object">
    <title>Creating Our Person Object</title>
    <p>
      Before we write any code, let’s look at what happens if we try to use the Person class before we define it:
    </p>

    <code language="irb">
    $ irb
    > Person
    NameError: uninitialized constant Object::Person
      from (irb):1
    </code>

    <p>
      In Ruby, classes are constants.  When typing <ic>Person</ic> above, Ruby knows that there isn’t currently a
      <class>Person</class> class, so it throws a <constant>NameError</constant> telling us that the
      <class>Person</class> constant doesn’t exist. Ruby is case-sensitive and names that start with a capital
      letter are interpreted as constants. By convention, class names are camel case and all other constants are all caps.
    </p>
    
    <p>
      Let’s try again after loading <filename>person.rb</filename>.  Remember we just created the file, but it is
      still empty. We will see what happens just when we load a file in <commandname>irb</commandname>:
    </p>
    <code language="irb">
    > load 'person.rb'
     => true 
    </code>

    <p>
      Loading <filename>person.rb</filename> reports true since it was able to successfully load the file and evaluate
      the nonexistant contents of the file as Ruby code. However <class>Person</class> is still not defined:</p>
    <code language="irb">
    > Person
    NameError: uninitialized constant Person
      from (irb):2
    </code>
      
      <p>Loading the file simply evaluates the text inside it as Ruby code and reports true if there are no syntax
      errors.</p>
    
    <p>
      Next let’s add the class declaration to the file:
    </p>
    <code file="code/full_name/person.rb" part="class"/>   
    <p>
       Our code can now create <class>Person</class> objects.  We need to load the file again every time we make
       a change, and we can see that the class <class>Person</class> is defined:  
    </p>
<code language="irb">
> load 'person.rb'
=> true 
> Person
=> Person
</code>
<p>Let's
       create an object from our class with the <method>new</method> method:</p>
    <code language="irb">      
      p = Person.new
       => #<Person:0x10044c6a8>
    </code>
    
     <p>
       Our new Person object’s is returned and stored in the variable <ic>p</ic>. The whole expression evaluates to the
       value of the varable <ic>p</ic>, so <commandname>irb</commandname> displays a text representation of the object,
       which includes its class, <class>Person</class>, and an encoded version of the object’s id (0x10044c6a8).  If we make more objects of the <class>Person</class> class, each one will have a unique object id.  We haven’t defined any methods in our <class>Person</class> class, yet look at our output when we ask our <class>Person</class> object for its methods:
     </p>
<code language="irb">
> p.methods
 => [:nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, :singleton_class,
 :clone, :dup, :initialize_dup, :initialize_clone, :taint, :tainted?, 
 :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect,
 :methods, :singleton_methods, :protected_methods, :private_methods, … 
 :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__] 
</code>
<joeasks id="symbols">
		<title>What are the names with the colons?</title>
		<p>They are
    <firstuse>symbols</firstuse>.   We use
    symbols to label objects, method names or other messages in our code. Symbols are created by
    putting a colon in front of some characters.</p>
    <p>Why are symbols better than strings for labels and
    messages? Each time we evaluate a string, an new object is created — not so with symbols.  Watch this:</p> 
		
		<code language="irb">
		> "thing".object_id
		=> 2160189120 
		> "thing".object_id
		=> 2152614520 
		> :thing.object_id
		=> 370728 
		> :thing.object_id
		=> 370728
		</code>
		
		<p>Our strings and our symbol are objects since everything in Ruby is an object.  When we ask each object for its
    id, the strings gives us a different id each time, while the symbol gives us the same id.  This means if we were to
    use strings as our arguments above, and then refer to those methods again by the strings, it would create twice as
    many objects as when we use symbols.</p>

    <p> Symbols can have numbers in them, but they need to start with a letter. Like everything else in Ruby, they are
    case-sensitive:</p>
		<code language="irb">
    > :a == :A
    => false    
    </code>	  
		<p>
		 We can think of symbols as being like labels for things.  They are kind of like a cross between strings and
     integers. They are immutable, which means they can't be changed. They are similar to integers, where 5 is always 5,
     yet they are made up of textual characters like strings which is nice when reading code.</p>
</joeasks>
       <p>Our new Person object’s return value shows the class of the object, <class>Person</class>, and a unique
       reference number (0x10044c6a8).  If we make more objects of the <class>Person</class> class, each one
       will be unique. Right now each instance of the class will act exactly the same, we haven’t defined
       any methods in our <class>Person</class> class yet.
     </p>
     </sect2>
     
     <sect2>
     <title>Defining the <method>full_name</method> Method</title>
     <p>
       We’ll need to add the <method>full_name</method> method to the <class>Person</class> class in
       order for its objects to have useful functionality outside of its inherited methods.  Before we change our code,
       let’s check out what happens when we call the non-existent <method>full_name</method> method on our <class>Person</class> object:
     </p>

     <code language="irb">
     > p.full_name
     NoMethodError: undefined method `full_name` for #<Person:0x10045f0a0>
       from (irb):19
     </code>

     <p>
       This time our error message is a <constant>NoMethodError</constant>.  It tells us that currently the
       <method>full_name</method> method is not defined.  Now we can edit
       <filename>person.rb</filename> so that it has a <method>full_name</method> method. For starters, we
       won’t make the method do anything, we’ll just define an empty method to understand how it behaves:
     </p>
    <code file="code/full_name/person.rb" part="define_method"/>   
     <p>
       When we reload <filename>person.rb</filename> and call the <method>full_name</method> method, nil is returned.
     </p>
     
     <code language="irb">
     > p.full_name
      => nil
     </code>
     
     <p>Earlier we learned that everything in Ruby returns something.  Our <method>full_name</method> method
     returns nil because all empty methods return nil. <ic>Nil</ic> isn’t some special case literal, it is an
     <class>Object</class>
     just like everything in Ruby. We can see in <commandname>irb</commandname> that <ic>nil</ic> is an instance of <class>NilClass</class>
     and we can even call methods on it:</p>
<code language="irb">
>> nil
=> nil
>> nil.class
=> NilClass
>> nil.nil?
=> true
</code>     
     <p>If we want it to return a value other than nil, say the string &lquot;Jane Smith&rquot;, we can put our string inside of our method and Ruby will return the string when we call <method>full_name</method>.</p>

     <code file="code/full_name/person.rb"/>
     <p>Ruby methods return the last expression evaluated automatically so we don't need to use the
     <keyword>return</keyword> keyword (though we can if we want to).  Now our <method>full_name</method> method
     should return the string &lquot;Jane Smith&rquot; instead of <ic>nil</ic>.  Let's try it out: </p>

     <code language="irb">
      > load 'person.rb'
      => true
      > p = Person.new
      => #<Person:0xb77e5fd8>
      > p.full_name
       => "Jane Smith"
     </code>
     
     <p>We reloaded the file again so that <commandname>irb</commandname> knows about our changes.  We can see that our
     <method>full_name</method> method now returns our string as we had hoped.</p>
     </sect2>
<sect2>
<title>Object Construction</title>
<p>Our code would be working great if all of our users were named &lquot;Jane Smith&rquot;. Of course our users will have a variety of names, so we need a more intelligent solution.  We know that each person we create must have a name.  Given this knowledge, let's give each person a name when their <class>Person</class> object is first created.</p>
<p>Ruby has a special <method>initialize</method> method that allows us to execute code whenever a new object is instantiated.  Often the <method>initialize</method> method is used to set up attributes for an object.  In our case we want to put data into attributes for a person's name. Let’s add an <method>initialize</method> method to our <method>Person</method> class:</p>
     <code file="code/full_name/person_initialize.rb" part="one"/>
<p>Then let’s see it in action:</p>
<code language="irb">
> load 'person.rb'
=> true
> p = Person.new
> p = Person.new
Hello! I am being created at 2011-04-02 14:54:20 -0700.
=> #<Person:0x00000100ac1e48> 
</code>
<p>We can see that when we call <method>new</method> on any class, Ruby will call the
<method>initialize</method> method of the class, if there is one. The newly created object is always returned
from <method>new</method> and the return value from <method>initialize</method> is ignored.</p>
<p>Our plan is to make this class accept a first and last name, but for now let’s get a feel for how this works by
starting with just one name as an argument in the initialize method. After all, some people have only one name:</p>
     <code file="code/full_name/person_initialize.rb" part="two"/>
<p>and Ruby will then require an argument for new:</p>
<code language="irb">
> load 'person.rb'
=> true
>> p = Person.new
ArgumentError: wrong number of arguments (0 for 1)
	from (irb):5:in `initialize'
	from (irb):5:in `new'
	from (irb):5
</code>
<p>which we can provide just like any other method argument:</p>
<code language="irb">
>> p1 = Person.new("Sacajawea")
Sacajawea is being created.
=> #<Person:0x1011d6e18>
>> p2 = Person.new("Teller")
Teller is being created.
=> #<Person:0x1011c34f8>
</code>
<p>We've made good progress, but our <method>full_name</method> will still report “Jane Smith” for every object. What we really want to do is to save that data inside each object to reference later.  Let's do that next.</p>
</sect2>
<sect2>
<title>Storing Data with Objects</title>
<p>A core concept of object-oriented programming is data encapsulation. We hide the details of the implementation of our
objects inside classes. We make some data available externally and some data remains private. We store data inside of our
objects in <firstuse>instance variables</firstuse>.  We tell Ruby that a variable is an instance variable by putting a
<emph>@</emph> before the variable.  A variable without the <emph>@</emph> will only be available within the scope of
the method that uses it. </p>
<p>For example, if we try to just use the <ic>name</ic> variable that we have in <method>initialize</method> in
another method:</p>
     <code file="code/full_name/person_instance_variable1.rb" part="one"/>
<p>and then call that method:</p>
<code language="irb">
> load 'person.rb'
=> true
>> p1 = Person.new("Sacajawea")
Sacajawea is being created.
=> #<Person:0x101247730>
>> p1.full_name
NameError: undefined local variable or method `name' for #<Person:0x101247730>
	from ./person_instance_variable.rb:8:in `full_name'
	from (irb):3
</code>
<p>Ruby expects words that start with a lower case letter to be either a local variable or a
method. We haven’t set a local variable called <ic>name</ic> inside the <method>full_name</method> method, nor
have we defined a different method called <method>name</method>, so Ruby raises a <ic>NameError</ic>.</p>
<p>To make a variable available across methods, we can set an instance variable in one method and use its value in
another, like this:</p>
<code file="code/full_name/person_instance_variable2.rb"/>
<p>Now we can call <method>full_name</method> to get the appropriate name:</p>
<code language="irb">
> load 'person.rb'
=> true
>> p1 = Person.new("Sacajawea")
Sacajawea is being created.
=> #<Person:0x10123aa08 @name="Sacajawea">
>> p1.full_name
=> "Sacajawea"
>> p2 = Person.new("Teller")
Teller is being created.
=> #<Person:0x10120f150 @name="Teller">
>> p2.full_name
=> "Teller"
</code>
<p>Instance variables are always private, which means that they are not available by default outside of our
class:</p>
<code language="irb">
> p1.@name
SyntaxError: compile error
(irb):11: syntax error, unexpected tIVAR
	from (irb):11
> p1.name
NoMethodError: undefined method `name` for #<Person:0x10045f0a0>
  from (irb):19
</code>
<p>In Ruby, we define methods to expose the data that we want to share with the rest of the world.</p>
</sect2>
</sect1>

<sect1>
	<title>Inheritance</title>
	<p>We now have a functioning Person class and we can make as many person objects as we want, each with their own full name.  </p>
	<p>What if we want a more specialized kind of person...say a student?  Students are definitely people, but they have
  some characteristics that are unique such as major, GPA, and year in school. If we wanted to give the qualities of
  personhood to students, we would use inheritance. We could make Student a <firstuse>subclass</firstuse> of Person.</p>
  <p>In fact, we have already used inheritance. Every class, by default, is a subclass of <class>Object</class>.
  Check out some of the built-in behaviors that <class>Person</class> inherits from
  <class>Object</class>:</p>
<code language="irb">
     > p1.class
      => Person
     > p1.class.superclass
      => Object 
</code>  
   <p>
       The Ruby Object object provides many useful methods for free in any class we create, because every class in Ruby is a descendent of the <class>Object</class> class where all these methods are defined.  We can discover the methods of an object like this:
    </p>
<code language="irb">
> p1.methods
 => [:full_name, :nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, 
 :singleton_class, :clone, :dup, :initialize_dup, :initialize_clone, 
 …] 
</code>

<p>We can get the same list by calling <ic>Person.instance_methods</ic>. If we want to see just the instance methods of
the <class>Person</class> class, we can subtract the <class>Object</class> instance methods:</p>
<code language="irb">
> Person.instance_methods - Object.instance_methods
 => [:full_name] 
</code>
<p>Both <ic>Person.instance_methods</ic> and <ic>Object.instance_methods</ic> return arrays of their methods.  The Array class defines the minus operator to remove elements from a list. Ruby and <commandname>irb</commandname> makes this kind of experimentation easy.</p>
<p>Now that we understand how our <class>Person</class> class inherits behavior from the
<class>Object</class> class. Let’s make a new <class>Student</class> class that inherit from our
<class>Person</class> class and defines new behavior. We use an angle bracket to indicate inheritance.</p>
	<code file="code/full_name/person_inheritance.rb" />
	<p>Let's try out our new class in <commandname>irb</commandname>:</p>
	<code>
	> load 'person_inheritance.rb'
	=> true
	> s = Student.new("Birtha")
	=> #<Student:0xb78247ec>
	> s.full_name
	=> "Birtha"
	> s.occupation
	=> "Student"

	</code>
	
<p> We can see that even though the <method>full_name</method> method is not defined in the <class>Student</class> class, our instance of <class>Student</class> has inherited the <method>full_name</method> from it's <class>Person</class> parent.</p>
</sect1>

<sect1> 
			<title>Rails Is Ruby</title>
<p>We've learned a lot about Ruby in this chapter.  We've seen that Ruby is made of objects and we can make Ruby objects from built-in classes or from our own custom classes.  We’ve started understanding the classes that provide a blueprint for our objects and the methods that bring our objects to life.  This understanding will help us understand that the built in Rails classes provide specific blueprints that create patterns for web applications.</p>
      
			<p>We’ve introduced a few key concepts in Ruby that will make Rails syntax much more clear.  For example when we begin learning about ActiveRecord we will see model code that looks like this:
      </p>
		
      <code language="ruby">
         class Person < ActiveRecord::Base
         end
      </code>
	
      <p>We now know that this Rails model is really just a Ruby class.  The <class>Person</class> class inherits from the <class>ActiveRecord::Base</class> class. </p>
      
      <p>When we see code like:</p>
	
      <code language="ruby">
      belongs_to :user
      </code>
    <p>We might be able to guess that <method>belongs_to</method> is a Ruby method making use of Ruby’s allowance of
    omitted parentheses. The symbol <ic>:user</ic> is an argument to the method. </p>



<p>Since Ruby is an interpreted language, we have had an opportunity to play with code in the Interactive Ruby
environment, <commandname>irb</commandname>. Our <commandname>irb</commandname> exploration has given us a taste of what
testing our code will be like. We’ve learned to read and understand the error
    messages <ic>NameError: uninitialized Constant</ic> when a class doe not exists and <ic>NoMethodError</ic> if we
    call a method that doesn’t exist. We will see these errors frequently as we use RSpec to test drive Rails, and being familiar with them will help to us in our development. 


We have learned the basics of Ruby that we will need to understand RSpec in the next chapter and Rails in later chapters.  With our new understanding of the fundamentals, it’s time to move on and learn how to write Ruby code <emph>test first</emph>. </p>
    
</sect1>
</chapter>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter SYSTEM "local/xml/markup.dtd">
<chapter id="ch.ruby_calculator">
  <title>Ruby Calculator</title>
    <sect1 id="sec.ruby.lang.intro">
      <title>Ruby Language Introduction</title>
      <p>
      You might wonder why a book about Rails starts off with an   introduction to the Ruby programming language.  The reason is that every excellent Rails programmer has a thorough understanding of Ruby  - after all, Rails is written in Ruby.  Trying to write a Rails program without knowing Ruby is like trying to write a limerick in English without knowing English – you could do it with the help of a translator, but it would be much easier with fluency in the language.  
      </p>
      <p>
      YAAAAAAAYYYYYYYYAAAAYYAYAYAYAYAY
      </p>
      <p>
      There are many reasons to love Ruby.  For one, it is a concise language: forget about semi-colons and curly braces – you won’t need them in this book.   You also won’t need to wrap your arguments in parentheses if you don’t want to.  Check this out:
      </p>

      <code language="ruby">
        def combo thing1, thing2
          thing1 + " and " + thing2
        end
      </code>

      <code language="irb">
        > combo "peanut butter", "jelly"
        => "peanut butter and jelly" 
        > combo "pork chops", "applesauce"
        => "pork chops and applesauce"  
      </code>

      <p>
      I <emph>defined</emph> the <method>combo</method> method without parentheses around my parameters and I <emph>called</emph> <method>combo</method> without parentheses around the arguments.  This is totally legal in Ruby and is called &lquot;poetry syntax&rquot;.  Of course, Ruby allows you to put in parentheses if you prefer.
      </p>

      <p>
        One of my favorite things about Ruby is that the quality of your code is determined in large part by the quality of your tests.  Rubyists have developed sophisticated tools for testing Ruby code like Rspec, Cucumber and Capybara to name a few.  Abundant test coverage gives you confidence when changing old code or adding new code.  It empowers programmers with flexibility and speeds up development over the long-term life of a project.  Test driven development (TDD) is a popular testing technique among Rubyists where a test is written before the code.  Learning effective TDD can be difficult which is why we are writing this book.  Lets get started playing with Ruby!
      </p>
      <sect2 id="ruby.lang.intro.irb">
         <title>Interactive Ruby (irb)</title>    
         <p>
         Ruby comes equipped with irb, which stands for &lquot;Interactive RuBy&rquot;. It allows you to see how Ruby will interpret your code and is one of the most valuable tools in your programmer toolbox.  To access irb, simply type &lquot;irb&rquot; into your command line.  You should see a prompt with an angle bracket &lquot;>&rquot; where you can type in Ruby code.  Here’s an example:
         </p>
         <code language="session">
           $ irb
           > 1 + 1
         </code>
         <p>
           Now when you click enter, Ruby will evaluate 1 + 1 and show you what it returns:
         </p>
         <code language="session">
           => 2
         </code>
      </sect2>





      <sect2 id="ruby.lang.intro.evaluation">
         <title>Everything Evaluates to Something</title>
      <p>
       In Ruby every expression evaluates to (returns) something.  That means that every time we ask Ruby to evaluate an expression, it will tell us the result of the evaluation.  Irb will help us get a better handle on return values.  When we asked Ruby to evaluate <ic>1 + 1</ic> above, it returned 2.  The <ic>=> 2</ic> on the line that appears below our expression after we hit the enter key is what Ruby returns from the expression.  We can evaluate addition on integers like 1 + 1 above, or we can evaluate strings:
      </p>

      <code language="session">
        > "like a string of pearls, but with characters"
         => "like a string of pearls, but with characters"
      </code>
      <p>
        A string consists of quotation marks with any number of characters in between.  Strings are used for any textual information that a program needs.  Ruby can add strings as well as integers.  When we add strings, we call it &lquot;concatenation&rquot;.  Check out this example of concatenating to strings:
      </p>
      <code language="session">
        > "knock, knock." + " whose there?" +
        >   " interrupting cow." + " interrupting cow wh..." + " Moooo"
         => "knock, knock. whose there? interrupting cow. interrupting cow wh... Moooo"
      </code>
      
       <p>
          Ruby evaluates the concatenation of the five strings making up this cheesy knock knock joke and returns them all together as one string.
       </p>
     </sect2>

    </sect1>




  </chapter>
