<html>
		<h2>Table Of Contents</h2>
		<div>
		<ol class="toc">
			<li><a href="#ch.preface">Preface</a></li>
			<li><a href="#ch.intro">Why Test? And How We Test First</a></li>
			<li><a href="#ch.ruby-intro">An Introduction To Ruby</a></li>
			<li><a href="#ch.rspec-intro">Test First Ruby</a></li>
			<li><a href="#ch.firstapp">Diving Into Rails</a></li>
			<li><a href="#ch.activerecord">Exploring Active Record</a></li>
			<li><a href="#ch.activerecord-rspec">Test Driving Model Development</a></li>
			<li><a href="#ch.rake">Rake Helps Us Organize Our Ruby Scripts</a></li>
			<li><a href="#ch.migrations">Creating Our Database Schema wit Migrations</a></li>
			<li><a href="#ch.controllers">Exploring Routes and Controllers</a></li>
			<li><a href="#ch.controllers-rspec">Understanding Controllers through Testing</a></li>
		</ol>
		</div>
</html>
<!-- -*- xml -*- -->
<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.preface' number='1'>
<h2 class='chapter_title'>Come On In</h2>
<p>We’re diving into Ruby on Rails test first. We’ll be using techniques designed to create robust production code that
can be delivered quickly and adapt nimbly to new business requirements. We’ll experience testing as a software
development methodology, rather than in its traditional use in isolating and resolving defects. In most of the book,
we’ll focus on testing as an effective way to learn a new language and framework.</p>
<p>As kids we explore our world through experimentation. Researchers test hypotheses, learning about our world through
the scientific method. As programmers, we have test frameworks, originally developed for verifying defects, that can be
applied to learning.</p>
<p>Learning programming through testing has been independently discovered by dozens of engineers as a natural way to learn. We use two different kinds of testing in this book.
First we do exploratory testing: like kids exploring nature, we poke around Ruby using an
interactive console called <span class='commandname'>irb</span> (Interactive RuBy), Ruby’s own REPL (Read Eval Print Loop). Then, we use test
frameworks RSpec and Capybara.</p>
<p>Using test first development techniques, we have the opportunity to see all of the error
messages we will later see in the wild. We explore APIs in detail. We don’t just learn recipes for building an
application with Ruby on Rails – we learn the fundamentals of how the different parts of the framework fit together.
Much of time saving benefit of using a framework is created by the built-in behaviors that happen without our writing
any code at all,
and those are the hardest to learn. Using test first techniques, we can see those behaviors more
clearly and better understand what the framework does for us.
</p>
<p>A happy side benefit of a test first approach to learning is that we are learning to code using best practices. At the
end of the book, we will have written a whole application that includes tests. We will experience how testing helps us
effectively design our code and develop our software. We will see how testing goes beyond the bug find-fix cycle,
liberating us to write great code at high velocity.</p>
<sect1>
<h3 class='title'>Web Development with Rails</h3>
<p>Speaking of high velocity, Ruby on Rails is a framework for building web applications that is optimized for
programmer productivity. David Hansson who created Rails in the early 2000s says that it was <em class='emph'>extracted</em>
rather than created. He first wrote Basecamp, a popular online collaboration tool, as a web application in Ruby; then he
pulled out the code which was common to all web applications to create the Rails framework. Rails was created from a real-world use case at a time when web application design patterns were well
established. Since most web applications share a lot of common patterns and behaviors, the Rails framework speeds our
development by letting us create a lot of functionality with very little code.
</p>
<p>Rails is written in the Ruby language. When we develop Rails applications we are writing Ruby code.
First developed in the early 1990s by Japanese engineer, Yukihiro “Matz” Matsumoto, Ruby was designed not only for
programmer productivity, but also to increase programmer happiness. Matz believes that language design must follow the
same principles as user interface design, emphasizing human, rather than computer needs. Today, when time-to-market is
more often the gating factor of software development than compute power, this emphasis of Rails and Ruby on productivity
is particularly valuable.</p>
</div>
<sect1>
<h3 class='title'>Who Should Read This Book?</h3>
<p>This book is written for programmers.  You’ve been developing in Java, C++, PHP or some other language, or perhaps
you studied programming in college and are considering diving back in with web development. Total beginners might want
to consider starting with Chris Pine's <bookname>Learn to Program</bookname> before jumping into this book.</p>
</div>
<sect1>
<h3 class='title'>Software We’ll Need</h3>
<p>We recommend working through this book with the same versions of software that were used to write it. Almost
everything will be the same in the next incremental version of anything, but when you are learning, sometimes a small
difference can be confusing.</p>

  <p>Let’s first check that we have the right version of Rails and it is working, by typing <span class='ic'>rails -v</span> on the command line.
  We should see the version printed afterwards.  Throughout this book, we’ll show you command-line output where the
  <span class='ic'>$</span> is our command prompt with what we’re typing after a space on the same line. Then we’ll show you the output
  of the command, like this:</p>
<pre class='code' language='session'>
$ rails -v
Rails 3.0.3
</pre>

<p>To get the most out of this book, we should all be using the same version of Rails. Any version that starts with 3.0
is fine (like 3.0.1 or 3.0.3). If you don’t have the right
version or got an error when you tried to run the <span class='commandname'>rails</span> command or for any of the commands in
this section, check out <a class='ref' href='#sec.online-resources'></a> for online references to installation instructions.</p>
<p>To be able to run the <span class='commandname'>rails</span> command and build the most minimal application, you will need Ruby and the Ruby Gems packaging manager.</p>
<sect2>
<h3 class='title'>Ruby</h3>
<p>Great Rails developers are great Ruby developers. We need Ruby to build and run Rails applications. Check your
version:
</p>
<pre class='code' language='session'>
$ ruby -v
ruby 1.9.2p0 (2010-08-18 revision 29036) [x86_64-darwin10.4.0]
</pre>
<p>Ruby 1.8.7 or higher is required for Rails 3.  Ruby 1.9.2 or higher is recommended.</p>
</div>

<sect2>
<h3 class='title'>Ruby Gems</h3>
<p>A gem is a ruby library. Rubyists like to make up cute names for their creations. Jim Weirich was no exception when
he created Ruby Gems.  A gem is a precious bit of Ruby code that some developer has carved out for its usefulness. 
The name <em class='emph'>gem</em> speaks to the Ruby aesthetic that our code should be beautiful and bring us delight as
well as having practical uses. Ruby Gems has a fabulous packaging system that supports having different versions installed
as well as installing native code extensions. We can also easily install libraries from local or remote sources.  To see
what version of Ruby Gems we have installed:
</p>
<pre class='code' language='session'>
$ gem -v
1.3.7
</pre>
<p>To see the gems we have installed:</p>
<pre class='code' language='session'>
$ gem list
</pre>
<p> When we’re developing in Rails, we often add gems that offer functionality that is common to many web applications.
Ruby engineers are exuberant in providing open source implementations of any code that is generally useful, creating an
ecosystem of tools that adds to our velocity as Rails engineers.</p>
</div>
<sect2>
<h3 class='title'>Database</h3>
<p> In this book, we’ll use SQLite since it is easy to install and is
great for experimentation. A database is not strictly required for a web application built with Rails, but most web applications
provide a user interface on a relational database, so that’s the kind of app we’ll build. The Rails code that we will develop will be database-independent, so we can use any of the
supported databases for deployment or further development.</p>
</div>
<sect2>
<h3 class='title'>Editor or IDE</h3>
<p>There are a lot of great IDEs that work well for Rails, such as RubyMine, Aptana’s RadRails, TextMate (for the Mac)
and Komodo. Every code editor we’ve tried lately has Ruby syntax highlighting, which is essential for spotting errors. Additionally, it is handy to have a project view to see the directory hierarchy, since
when we develop a Rails application, we often switch between files to follow the flow of control or see the test and the
tested code. We highly recommend finding a IDE you love and learning its ins and outs.</p>
</div>
<sect2>
<h3 class='title'>Terminal or Command Prompt</h3>
<p>Rails development relies heavily on command-line tools. On Mac or Linux, we run these in the <em class='emph'>terminal</em>,
and on Windows, in the <em class='emph'>command prompt</em>. We like running <em class='emph'>gitbash</em> aka
<em class='emph'>msysgit</em><div class='footnote'><p><a class='url' href='http://code.google.com/p/msysgit/'>http://code.google.com/p/msysgit/</a></p></div> on Windows, which is
distributed with git by the helpful folks who create git for Windows. Gitbash allows us to use the same Unix commands for
moving and copying files as we use on and Linux.</p>
</div>
<sect2>
<h3 class='title'>Test Frameworks</h3>
<p>Throughout this book, we use RSpec, created by David Chelimsky. RSpec grew out of the behavior-driven development movement
and is focused on the idea that when we write our code test first, we are actually writing a specification of our code.
The key advantage of RSpec both for learning and for building production code is the clarity of its output. This is the
primary reason we use RSpec. When we’re learning, clear output will help us learn from the test failures. When part of
our existing test suite fails during development of new code, being able to clearly see the failure saves time fixing
it. Also, there are many smaller test framework details that work together in RSpec to make tests easier to read and
maintain once we understand the syntax. Trust us, it’s a good way to go, but if you find later that you want to switch
or find yourself in the midst of a project that uses Test::Unit, no worries – the principles and patterns we cover in
this book apply to all test frameworks.</p> 
<p>Like all of
the Ruby test frameworks, RSpec is distributed as a gem. Since we’re building a Rails application, we’ll use the
<span class='commandname'>rspec-rails</span> gem that includes RSpec and some additional helpers for Rails.</p>
<p>You don’t need these gems installed right now, but here are are the versions we’ll be using:</p>
<pre class='code' language='session'>
$ gem list rspec

*** LOCAL GEMS ***

rspec (2.5.0)
rspec-core (2.5.2, 2.5.1)
rspec-expectations (2.5.0)
rspec-mocks (2.5.0)
rspec-rails (2.5.0)
</pre>
<p>We also use Capybara for integration testing:</p>
<pre class='code' language='session'>
$ gem list capybara

*** LOCAL GEMS ***

capybara (0.4.1.2)
</pre>
<p>Now you have everything you need to build Ruby on Rails web applications test first.</p>

<p></p>

</div>


</div>
<sect1>
<h3 class='title'>What is in This Book?</h3>
<p>Throughout this book, you will learn both the Ruby language and the Rails framework. We first will explore a concept
with exploratory testing through <span class='commandname'>irb</span> and sometimes with the command line and the browser. 
Then in the following chapter, we will continue our development test first using Ruby automated test frameworks.</p>
<p>In each chapter, we will build one small part of a larger application. The application is for an imaginary
creative writing class and serves as a resource for the students in the class. The domain of the application that we
first implement when learning Rails isn’t important, since most Rails applications, like most web applications, are very
similar to each other. We have some
data that we want to store in a database and later see it again. Sometimes we want to change it or delete it. We want to
provide the user interface in HTML so anyone with a web browser connected to the Internet can access it. Whether it is
the text of a writing assignment, the name and part number of a piece of equipment or items in a product catalog, these
are all just data that we can keep in a database and display in HTML.</p>
<p>In <a class='ref' href='#ch.intro'></a>, we’ll  talk about
how testing is first and foremost about good design, how it helps the software development workflow and collaboration,
how we can write more maintainable code and how the creation of tests is a nice artifact of the process, not the
main point. We’ll also introduce how we test first with the Red-Green-Refactor pattern of test first development. We’ll
also talk more about the app we will build in the book and we’ll work through all of the tools and components we need to develop a Rails application.</p>
<p>In <a class='ref' href='#ch.ruby-intro'></a>, we’ll learn just enough of the Ruby language to get started with Rails. We’ll
start using <span class='commandname'>irb</span> and write our first class and a method that we’ll use later in our Rails
application. Then in <a class='ref' href='#ch.rspec-intro'></a>, we’ll learn how to use RSpec, the automated test framework that
we’ll use throughout the book. We’ll test drive the development of some Ruby as well as understanding how to test the
code that we already wrote.</p>
<p>In  <a class='ref' href='#ch.firstapp'></a>, we’ll start our Rails application with command line generators that we’ll
explore in the browser. We’ll gain some experience with our first Rails pattern, most importantly the
Model-View-Controller (MVC) pattern, which we will learn in more detail throughout the first half of the book. We’ll get
a feel for how views work with ERB (Embedded RuBy) templates.</p>
<p>We’ll learn about ActiveRecord, the <em class='emph'>model</em>, in the MVC pattern, interactively in <a class='ref' href='#ch.activerecord'>Exploring ActiveRecord</a> and with RSpec in <a class='ref' href='#ch.activerecord-rspec'></a>.</p>
<p> In <a class='ref' href='#ch.rake'></a> we’ll get deeper into Ruby code, which will give us a firm foundation for the rest of the book.
We’ll also learn about the command line tool <span class='commandname'>rake</span>, which is like the Unix tool
<span class='commandname'>make</span>, but for Ruby. With Rake, we’ll write a Ruby script that uses our ActiveRecord class
that we created in the previous chapters.</p>
<p>In <a class='ref' href='#ch.migrations'></a>, we’ll understand how our database schema is created and modified. We’ll learn the
mechanisms of how Rails can be database independent.</p>
<p>In <a class='ref' href='#ch.controllers'></a>, we’ll build a dynamic web page one step at a time, experimenting with how the browser
responds with the default Rails behavior and with our code. We’ll get to know how Rails handles HTTP requests. Then
we’ll continue the development of our controller by test-driving the rest of its behavior in <a class='ref' href='#ch.controllers-rspec'></a>.</p>
<p>In <a class='ref' href='#ch.integration'></a>, we’ll solidify our understand of the MVC pattern and how it is implemented in
Rails core classes by test driving new behavior with the Capybara integration test framework. </p>
<p>In <a class='ref' href='#ch.stubs'></a>, we’ll learn more about testing Ruby code, coping with uncertainty when the results of our code are
      non-deterministic and keeping our tests running fast.
</p>
<p>As we add more behavior to our application, in <a class='ref' href='#ch.helpers'></a>, we’ll learn some
techniques to keeping our code manageable and easy to read.</p>
<p>In <a class='ref' href='#ch.associations'></a>, we’ll take a closer look at ActiveRecord and learn how to leverage the power of
our relational database. Through <span class='commandname'>rails console</span>, we’ll gain experience with common association
methods in a “has many” relationship. Then, in <a class='ref' href='#ch.associations-rspec'></a> we’ll learn more about the details
by understanding how to define associations with RSpec.</p>
<p>In <a class='ref' href='#ch.has-many-through'></a>, we’ll learn how to create a many-to-many relationship using another kind of association.</p>
<p>In <a class='ref' href='#ch.auth'></a>, we’ll gain experience using a gem to extend Rails. We’ll also learn about how to lock
down controller actions, securing the entry points to our app with “before” filters. </p>
<p>At the end of the book, inn <a class='ref' href='#ch.dunno'></a>, we’ll highlight the parts of Rails that you’ll want to learn
next.</p> 
<p>
  Through testing and experimentation, we’ll have
developed a thorough understanding of Rails. You will know
enough to build an intranet application or kick-off the development of a small-scale web app, and you will have enough
of a foundation to support further learning on your own to create highly-scalable consumer-facing web applications. </p>
</div>
<div class='sect1' id='sec.online-resources'>
<h3 class='title'>Online Resources</h3>
<p>
This book has its own web page, <a class='url' href='http://pragprog.com/titles/satfr'>http://pragprog.com/titles/satfr</a>, where you can find more information about the book.
You can:</p>
<ul>
<li><p>Get links to all of the software dependencies, so you can install what you need to work through the examples.</p></li>
<li><p>Download the full source code for the application that we’ll build in the book, including code for the
intermediate stages and Ruby scripts.</p></li>
<li><p>Participate in a discussion forum with Sarah, Liah, and other readers like you.</p></li>
<li><p>Help improve the book by reporting typos and code that didn’t work the way you expected. We also welcome
suggestions for improvement.</p></li>
</ul>
<p>You are free to use the source code in your own applications in any way that you want. If you’re reading the ebook, you can also click the little gray rectangle before the code listings to download that source file directly.</p>
<p>Throughout the book, we’ll also point you to online resources where you can learn more about Ruby and Rails.</p>
</div>

<sect1>
<h3 class='title'>How to Read This Book</h3>
<p>Except for  <a class='ref' href='#ch.intro'></a>, this book is not meant to be read on the bus or leaning back on the sofa. You should have hands on the keyboard and try out each experiment. For most of the code, you’ll be able to see the expected result, but now and then we’ll
challenge you to take what you’ve learned and write some of the application on your own.</p>
<p>Let’s start by learning a bit more about why and how we write code test first.  </p>
<p></p>


</div>
</div>

<!-- -*- xml -*- -->
<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.intro' number='2'>
<h2 class='chapter_title'>Why Test? And How We Test First</h2>
 
  <p>Ever wanted to rip out an old feature and replace it with the next big thing? Well-tested code gives us the power
  of worry-free refactoring and code reuse.    
  
  Tests give us the confidence to reinvent our code to our heart's content.  Where our human brains fail at remembering
  all the details of our code's behavior, tests succeed. We can ship sooner and more often, giving us huge competitive
  advantage.</p>
  <p>In a language, like Ruby, without a compiler, changing code can be particularly dangerous. If we change a method or class name,
  and we don’t modify every piece of code that calls it, there’s no compiler to catch the error. This can lead to a
  deceptive feeling of safety with languages like Java or C++.
  Testing allow us to catch logic errors that a compiler would never recognize, in addition to flagging places where we
  changed an interface without adjusting the calling code. With testing we
can enjoy the flexibility of a language like Ruby with a safety net.
  </p>
  <div class='figure' id='fig.tdd-productivity'>
  <h3 class='title'>Figure 2.1: Test Driven Development vs. Traditional Velocity by Alex Chaffee</h3>
  <img class='imagedata' src='images/TDD-productivity-graph.png'></img>
</div>
<p>We can visualize how test-driven development increases our productivity by thinking about how much time it takes to develop
each feature, as shown in <a class='ref' href='#fig.tdd-productivity'>Figure 2.1</a>. 
With the first few features, traditional development
may be faster, because we aren’t typing test code in addition to implementing a feature. However, as features
accumulate, the tests allow us to quickly see how the addition of a new feature impacts existing features. Refactoring,
which we’ll learn about later in this chapter when we describe the test first development cycle in detail,
is key to keeping the effort per feature consistent. With an executable specification, plus well-factored tests and
implementation code, we can maintain development velocity as a codebase matures. </p>
 <sect1>
 <h3 class='title'>Testing Helps Us Create Great Software</h3>
 <p>Writing code test first isn’t just about creating tests and verifying that our code lacks defects, it’s a software development process that causes us to write
 better code with fewer bugs.</p>
  <sect2>
  
  <h3 class='title'>Effective Design</h3>
  <p>First and foremost, test first development is about design. Before we write any code, we test
  our design. In our tests we develop against APIs that don’t exist yet. We see how the code will flow and what the
  behavior would be if that code existed. We are free to change APIs and modify how methods work together without having
  to rewrite any implementation code. </p>
  <p>This design process caused the creators of RSpec and other so-called test frameworks to rename the process
  <em class='emph'>behavior driven development</em> (BDD). When we write our code test first, we are actually writing a
  <span class='firstuse'>specification</span> of our code. We are
  specifying our code by example with each test case part of an <em class='emph'>executable specification</em>.</p>
  <p>As with paper specifications, we can see the API in action; however, unlike paper specs, once all of the tests pass, 
  we know that the APIs work together to create the desired result and the test ensures that the API is used consistently across the whole specification.</p>
  <p>Verifying our design before we write our code translates into development velocity. It may take us longer to type
  the code the very first time, but the code has fewer bugs and we are more likely to develop the right solution. We
  develop production code significantly faster than traditional test last or wild west methodologies.</p>
  </div>
  <sect2>
<h3 class='title'>Easier Collaboration</h3>
  <p>A test first approach has a few different effects in the way we work that make it easier to collaborate in a team.
  The nature of an executable specification improves interaction between developers and whoever is setting the
  requirements. Also, the tests themselves and the incremental nature of development improves collaboration betwen
  developers on the team.</p>
  <p>Historically we’ll have a product manager who sets requirements and engineers who write specifications on paper. Sometimes
  the line between setting requirements and figuring out the technical solution can get a little blurry. By writing our
  specifications in code, we clearly separate the definition of requirements from the
  specification process. With test-driven development, requirements are still defined in words, but specifications are written with code (even if it is code that sounds a bit like English). Having two different activities for each phase helps separate the steps in
  the process.</p>
  <p>When we sit down to write a spec or test, it forces us to consider whether we are missing some
  information. We need to clearly understand pre- and post-conditions for the code we are about to define. Do we need to ask some questions to refine the requirements? Do we need to learn more about the
  technologies we’re using before we dive into implementation? Test first development can help improve this process and
  allow developers to work with a product manager or product owner more effectively, and also ensure that developers
  know what they are doing when they sit down to write production code.</p>
<p>In addition to helping with the product definition workflow, test first development fosters collaboration between
developers. Tests serve as documentation for other developers on the team.  If a developer comes across unfamiliar code, it is easy to go check out the spec to see the code in action.</p>   
  <p>Writing tests first encourages small, frequent commits, contributing to effective collaboration.  Once our failing test passes, we know that we are done coding a particular requirement.  A test first approach allows
  us to chunk our requirements into little bite sized pieces that can be committed to source control separately.  All the developers on our project can then commit and pull multiple times per day and the code stays synched up.</p>
</div>
<sect2>
<h3 class='title'>More Maintainable Code</h3>
<p>Less code is more easily maintained. A test first approach keeps us focused so that we only
  write necessary code. We write tests just for the new behavior we want to build, and it helps us not write redundant
  tests for the built in behavior of the underlying system.</p>
  <p>When we test drive development, we also tend to write smaller methods and write components with better separation
  of concerns. This kind of code is more flexible and easier to modify.</p>
</div>
<sect2>
<h3 class='title'>Shorter Bug Find-Fix Cycle</h3>
  <p>Test driving our code turns us into a different kind of programmer.  We focus on getting things correct from all
  angles. Once we test drive some new behavior, we run our whole test suite so we can discover if our code had some
  unintended effect or the new behavior interacted with an old feature in an unexpected way. By finding bugs quickly,
  before the code ever goes to QA or to production, we dramatically speed up the process by shortening the bug find-fix
  cycle.</p>
</div>
<sect2>
<h3 class='title'>The Creation of Tests</h3>
<p>Lastly, we end up with a test suite! Writing the tests first guarantees that. If we always write tests first, we’ll
have 100% code coverage. Of course, that doesn’t mean that every condition is tested or that the code does the right
thing, but it is certainly a great statrt.</p>
<p>We still sometimes release our code with bugs, but once a bug is found, we can write a test that exposes it by
failing. Then once the test passes, that bug will never bother us again.  We get into a rhythm of writing the test,
making it pass.  It becomes second nature.  It forces us to really know what we are doing.  It makes our brain grow and
our code solid.</p>
</div>
  </div>


<sect1>
<h3 class='title'>Red, Green, Refactor</h3>
<div class='figure' id='fig.tdd'>
  <h3 class='title'>Figure 2.2: Test Driven Development Cycle</h3>
  <img class='imagedata' src='images/tdd.svg'></img>
</div>
<p>Test first development is more than just writing the test first. The test first development cycle include series of
steps that are essential to capturing the benefits of a test first approach. We call the cycle "Red, Green, Refactor" because when we first write our test, it fails and the output is colored red.  Then once our code passes, the output is green.  Finally, we go back and <span class='firstuse'>refactor</span> our code, meaning that we make it more readable and maintainable without changing its behavior.</p>
<p>We learn to embrace failure. Every test we write starts with a failure and we check that it fails properly before we
start writing our application code.  Why would we be such sticklers about failing?  Because sometimes the behavior of
our application surprises us and it passes without any new code, or we discover that the test wasn’t written correctly
and it passes or fails because of an error in the test. This test-driven development cycle is illustrated in <a class='ref' href='#fig.tdd'>Figure 2.2</a>. We always want to start by watching our test fail to ensure that it fails the way we expect it to fail.</p>
<p>Next we write just enough code to satisfy the error that we saw. We try to write <em class='emph'>simplest code that could
possibly work</em> even if it means hard-coding some value that we’ll flesh out later as we write further tests. This
ensures that we don’t write extra code that we will have to maintain without test coverage and that might not even be
necessary for the current product requirements. </p>
<p>We continue the cycle of writing a little code and running our test again until we’ve written enough code to make our test pass.  Then we’ll go back and rework code that we want to improve for maintainability, readability or performance. We’ll also add tests to flesh out behavior so that we don’t leave hard-coded values in our final implementation.</p>


</div>

<sect1>
<h3 class='title'>Defining Our Application</h3>
<div class='figure' id='fig.mock_home_page'>
  <h3 class='title'>Figure 2.3: Mock Home Page</h3>
  <img class='imagedata' src='images/intro/mock_home_page.png'></img>
</div>
<p>Test first development dramatically changes how we define our application. Creating a specification using
tests rather than with words lets us put a stake in the ground early with the flexibility to shift our implementation as
requirements change.</p>
<p>Innovation in business
development is leading toward new processes where paper prototypes lead to working
software that implements a small fraction of the planned product. Feedback from prospective or real customers can
influence changes in direction that ultimately lead to product improvements and a better market fit. We’ll be learning
how to do test driven development, but we’ll be building an application with the goal of learning, rather than iterating
on a specific business need.</p>
<p>Throughout this book, we’ll work on a simple application that will provide many
opportunities to explore how Rails works. As we gain experience with each feature of Rails, we’ll use our knowledge to
write tests to specify new behavior and drive more development.


 
 </p>
<p>We’ll be developing an application to manage a creative writing class. Each course has a set of assignments and students are expected to submit
their writing assignments through the website. Each student has a page so that everyone in the class can read everyone
else’s work to support class discussions and peer critiques. In <a class='ref' href='#fig.mock_student_page'>Figure 2.4</a>, we can see how
it might look for each student to have a page, where students can see which assignments are
completed, can review old assignments or complete a new one.</p>
<div class='figure' id='fig.mock_student_page'>
  <h3 class='title'>Figure 2.4: Mock Student Page</h3>
  <img class='imagedata' src='images/intro/mock_student_page.png'></img>
</div>
<p>The application we’re building will have key elements which are part of almost every web application, so that you can take
what you learn in this book and build your own app.</p>
<p>Most web applications have a home page, we’ll make a simple one that links to the different parts of the application.
A mockup of the one we’ll build  is shown in <a class='ref' href='#fig.mock_home_page'>Figure 2.3</a><div class='footnote'><p>Screens were sketched using
Balsamiq Mockups: a great tool for getting a feel for the data you want to display and defining the initial interaction design.</p></div>. Most production web applications will
have fancier home pages. By the end of the book, we’ll have learned how to put additional dynamic data on a page, but we
won’t dive into additional HTML, CSS, and JavaScript that could be added to create a more effective user experience.</p> 

<p>By the time we’re done, we’ll make it so that people can log in and only students can write or edit their own
assignments and only the teacher can add courses and make create new assignments for a course.</p>
<p>The data for our application will be stored in a relational
database. We’ll have information about  students, lists of assignments and a way to keep track of the different course she has
offered in the past as well as the current one. </p>
<p>If we look at
the volume of code that it takes to build a web application, the majority of it will be common between web applications.
This a key strength of Rails. The framework implements the common behaviors, allowing us to focus on the parts
that are unique to what we want people to be able to do with our application.</p>
<p>We’ll begin with Ruby.</p>

</div>
</div>

<!-- -*- xml -*- -->
<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.ruby-intro' number='3'>  
  <h2 class='chapter_title'>An Introduction to Ruby</h2>
  
    <p>
    Every excellent Rails programmer has a thorough understanding of Ruby — after all, Rails is written in Ruby.  Trying
    to write a Rails program without knowing Ruby is like trying to write a limerick in English without knowing English
    – you could do it with the help of a translator, but it would be much easier with fluency in the language.</p>
    <p>Before we dig into Rails, let's get some grounding in Ruby. Our
    goal right now is to learn Ruby basics. We won’t worry about formalized testing yet, instead we’ll start with
    interactive testing, poking around the language through its interactive console.  In the next chapter we will start
    doing test-driven development (TDD) using what we learn about Ruby in this chapter.  By the end of this chapter we
    will have created some Ruby code, but we will still have plenty to learn about it.  We will explain key Ruby
    concepts as we come to them in the following chapters</p>
    <p>In this book, you will learn just enough Ruby to build Rails
    applications, but we highly recommend diving deeper into the language with Chris Pine’s Learn to Program in Ruby or
    Programming Ruby by our very own publishers Dave and Andy,
    along with Chad Fowler<div class='footnote'><p>Chad Fowler started the very first U.S. RubyConf in 2001, which he still
    co-organizes along with RailsConf.</p></div>.
    Chris Pine’s book is written for non-programmers, but many experienced programmers find it a fun way to learn the
    language. Programming Ruby, also known as “the Pickaxe book” for the its cover art, is the definitive reference to the language. It was the first English-language
    book about Ruby, and has been enthusiastically kept up to date.
    </p>
    <div class='ask_sidebar'>
    <h3 class='title'>What’s an Object?</h3>
<p>
Objects allow us to associate data with code that acts on that data. Every object is an <span class='firstuse'>instance</span>
of a class.  In other words, one class can provide a structure we use over and over again to make many objects. We make
objects from a class like we make a house from a blueprint. Each house we make has a color, a neighborhood, lights that
turn on and dishes to be cleaned.  Some houses that we make might be red, others brown, but we still need only that one
blueprint to know how to create the structure.  Once the house is built, we can perform actions like turning on the
lights or doing the dishes. When we define these actions in a class, we call them <span class='firstuse'>methods</span>.</p>
<p>Ruby's built-in classes allow us to do all kinds of great things, but they provide only general-purpose
functionality.  Most of the time we need to create our own classes so that our applications can do what we need them to
do. As an object-oriented language, Ruby allows Rails to provide powerful classes that encapsulate common patterns of
  web application development. We often create our own classes or <span class='firstuse'>sublcass</span> core Rails classes,
  extending them with custom behavior.</p>

    </div>
    <p>
      To understand Ruby and Rails we need to understand Ruby objects because they are the cornerstone of most programs we will write.  We will spend most of this chapter learning about objects and classes, along with common error messages that will become key when we start testing.  Before we get started with Ruby objects, lets begin our study of Ruby by becoming familiar with evaluating Ruby expressions and taking a little tour of Ruby's syntax.
    </p>
    <div class='sect1' id='ruby.lang.tools.syntax'>
      <h3 class='title'>Using <span class='commandname'>irb</span> to Explore the Ruby Language</h3>
        <p>
             Ruby comes equipped with <span class='commandname'>irb</span>, which stands for &ldquo;Interactive RuBy&rdquo;. It allows us to see how Ruby will interpret our code and is a valuable tool in our programmer toolbox.  We will be using <span class='commandname'>irb</span> throughout this chapter to see our code through Ruby's eyes. 
        </p>
        <p>  
            To access <span class='commandname'>irb</span>, we type <span class='commandname'>irb</span> into the command line.  This command gives us a prompt with an angle bracket &ldquo;&gt;&rdquo; where we can type in Ruby code.  Don’t worry if your command prompt looks a little different — it can be modified with configuration.
             Here’s an example of <span class='commandname'>irb</span> in action:
             </p>
             <pre class='code' language='session'>
               $ irb
               &gt; 1 + 1
             </pre>
             <p>
               Now when we click enter, Ruby will evaluate 1 + 1 and <span class='commandname'>irb</span> will show us what it returns:
             </p>
             <pre class='code' language='session'>
               =&gt; 2
             </pre>
             <p>
           Every time we ask <span class='commandname'>irb</span> to evaluate an expression, it will tell us the result of the evaluation.  
          </p>
          <p>
            Let's move on to exploring some common Ruby idioms using <span class='commandname'>irb</span>
          </p>
      <div class='sect2' id='ruby.poetry.syntax'>
            <h3 class='title'>Poetry Syntax</h3>
          <p>
          There are many reasons to love Ruby. One of them is its concise and sometimes poetic syntax. Forget about
          separating expressions with semi-colons and curly braces – we don’t need to in Ruby.   We won’t always wrap our arguments in parentheses unless we need them to indicate precedence.  Let's open up a terminal and type <span class='commandname'>irb</span>. Then try this out:
          </p>

          <pre class='code' language='ruby'>
            &gt; def combo thing1, thing2
            ?&gt;   thing1 + " and " + thing2
            ?&gt;   end
             =&gt; nil
          </pre>

          <pre class='code' language='irb'>
            &gt; combo "peanut butter", "jelly"
            =&gt; "peanut butter and jelly" 
            &gt; combo("pork chops", "applesauce")
            =&gt; "pork chops and applesauce"  
          </pre>

          <p>
          We defined the <span class='method'>combo</span> method without parentheses around our parameters and the first time, we called
          <span class='method'>combo</span> we omitted parentheses around the arguments.  This is absolutely legal in Ruby and is
          called <em class='emph'>poetry syntax</em>. 
          </p>
          <div class='sidebar' id='side.dsl'>
            <h3 class='title'>Domain Specific Languages</h3>
            <p>
              The flexibility of Ruby’s syntax makes it a popular language for the creation of <span class='firstuse'>domain-specific
              languages</span> (DSLs).  There are <span class='firstuse'>external</span> DSLs like SQL, which are
              domain-specific languages that are implemented using a different language and
              <span class='firstuse'>internal</span> DSLs which sit on top of another language, extending its syntax to the
              extent that it feels like a new language.</p>
              <p>Rails is a domain-specific language for web
              application development. RSpec is a DSL for writing executable specifications that test our code. Rake is
              a DSL for executing scripts. Rails, RSpec, and Rake are all internal DSLs written in Ruby. Since they are
              not only written in Ruby, but are executed as Ruby code, they may be extended using Ruby, which gives them
              all of the power and flexibility of Ruby itself.</p>
              <p>Ruby’s poetry syntax and a few other language tricks allow Rails, RSpec and other Ruby DSLs to do a lot with
              very little code.  Understanding the difference between Ruby and DSLs written in Ruby gives us the power
              to quickly understand what code is doing. We will talk more about DSL's in our discussion of RSpec in <a class='ref' href='#ch.rspec-intro'></a> and Rake in <a class='ref' href='#ch.rake'></a>.
            </p>
          </div>
    </div> 
    
    <div class='sect2' id='ruby.objects'>
     <h3 class='title'>Everything Is an Object</h3>
     <p>
       Yep, it’s true.  Everything in Ruby is an object, unlike many other languages.   The fact that strings and numbers are objects means that Ruby can define methods on them.  For example, lets change a string to uppercase:
     </p>

     <pre class='code' language='irb'>
     &gt; "too big for my britches".upcase
      =&gt; "TOO BIG FOR MY BRITCHES"
     </pre>

     <p>
        The quotation marks in &ldquo;too big for my britches&rdquo; create an instance of the
        <span class='rubyclass'>String</span> class where the <span class='method'>upcase</span> method is defined.  In some other languages strings and
        numbers are handled specially, but with Ruby they are objects created from built-in classes like <span class='rubyclass'>String</span>,
        <span class='rubyclass'>FixNum</span> and <span class='rubyclass'>Float</span>. Ruby also has built-in collections <span class='rubyclass'>Array</span> and
        <span class='rubyclass'>Hash</span> with a wide range of methods that you might have to build yourself in some old-school languages. 
       </p>
    </div>
    
    <div class='sect2' id='ruby.operators'>
      <h3 class='title'>Ruby Operators Are Methods</h3>
      <p>Ah, Ruby...always doing things with a bit of glitz.  Ruby operators are no different.  Most languages have
      operators built into the language as structures of their own.  Ruby defines methods in the <span class='rubyclass'>FixNum</span>
      and <span class='rubyclass'>Float</span> classes in order to get <span class='method'>+</span>, <span class='method'>-</span> and other operators...just
      like how <span class='method'>upcase</span> is defined on the <span class='rubyclass'>String</span> class.  This works because methods are
      just messaged in Ruby, and operators work the same way.  Let's check it out in <span class='commandname'>irb</span>.</p>
      <pre class='code' language='session'>
      &gt; 1 + 1
      =&gt; 2
      </pre>

             <p>The plus sign looks like just any old operator we might see in another programming language, but in Ruby it is a method.  Try this:</p>

             <pre class='code' language='irb'>
               &gt; 1.+(1)
               =&gt; 2
             </pre>

             <p>We can see that the plus symbol is actually a method called on a number object.  When we use the plus
             symbol without the dot Ruby is actually calling the <span class='method'>+</span> method behind the scenes.  Ruby gives us some syntactic sugar so that we can write code that looks like the math we learned in Kindergarten without dots.</p>

      			 <p>Other Ruby operators like <span class='ic'>-</span>, <span class='ic'>*</span>, and <span class='ic'>/</span> are also methods and work similarly:</p>

<pre class='code' language='irb'>
&gt; 2.* 4
=&gt; 8 
&gt; 9./ 3
=&gt; 3 
</pre>
             <p>Ruby operators work for other objects too.  For instance array and string objects can be added together. In our own classes, we can define methods to make operators work in any way that we want.</p>

    </div> 
  </div>

  <div class='sect1' id='sec.ruby.class'>
    <h3 class='title'>Building Our Own Class</h3>
      <p>We've had a quick tour of Ruby concepts and syntax.  Now we are ready to build our own class and create objects
      from it.  Our goal in writing this class is to prepare us for test driven development.  The best way to prepare is
      to write our class step by step, just like how we will work once we are using tests. We’ll actually test
      interactively to understand what happens in Ruby before we’ve written our code. We’ll pay close attention to 
      each error message before learning the code that resolves the error. Knowing different errors and how to fix them
      is a crucial skill using any development methodology.
      Test driven code is first experienced as error driven code, so learning to read and understand Ruby errors will be key going forward.
     </p>    
     
     <p>
      The class we are about to build is very simple.  We are going to create a <span class='rubyclass'>Person</span> class that has a <span class='method'>full_name</span> method.  We will use this method later in Rails application that we build.  Let's get started!
     </p>
    
    <div class='sect2' id='giving_people_full_names'>
    <h3 class='title'>Giving People Full Names</h3>
    <p>The <span class='method'>full_name</span> method of our <span class='rubyclass'>Person</span> class will
    eventually concatenate different parts of our name together. We’ll start in this chapter by building just one method
    interactively, then we’ll test drive the other methods in the class in the next chapter.  With our <span class='rubyclass'>Person</span> class, we’ll be able to make objects that respond the same way but have
       different data.
    </p> 
    
      <p>
      Before we get started writing code, we’ll need a file. Ruby files end with a &ldquo;.rb&rdquo;
      extension.  By convention we’ll name our file <span class='filename'>person.rb</span> after the class we plan to write, but
      it could be called <span class='filename'>super_full_name_maker.rb</span> and it would still work.
    </p>
    </div>
    
    <div class='sect2' id='person_object'>
    <h3 class='title'>Creating Our Person Object</h3>
    <p>
      Before we write any code, let’s look at what happens if we try to use the Person class before we define it:
    </p>

    <pre class='code' language='irb'>
    $ irb
    &gt; Person
    NameError: uninitialized constant Object::Person
      from (irb):1
    </pre>

    <p>
      In Ruby, classes are constants.  When typing <span class='ic'>Person</span> above, Ruby knows that there isn’t currently a
      <span class='rubyclass'>Person</span> class, so it throws a <span class='constant'>NameError</span> telling us that the
      <span class='rubyclass'>Person</span> constant doesn’t exist. Ruby is case-sensitive and names that start with a capital
      letter are interpreted as constants. By convention, class names are camel case and all other constants are all caps.
    </p>
    
    <p>
      Let’s try again after loading <span class='filename'>person.rb</span>.  Remember we just created the file, but it is
      still empty. We will see what happens just when we load a file in <span class='commandname'>irb</span>:
    </p>
    <pre class='code' language='irb'>
    &gt; load 'person.rb'
     =&gt; true 
    </pre>

    <p>
      Loading <span class='filename'>person.rb</span> reports true since it was able to successfully load the file and evaluate
      the nonexistant contents of the file as Ruby code. However <span class='rubyclass'>Person</span> is still not defined:</p>
    <pre class='code' language='irb'>
    &gt; Person
    NameError: uninitialized constant Person
      from (irb):2
    </pre>
      
      <p>Loading the file simply evaluates the text inside it as Ruby code and reports true if there are no syntax
      errors.</p>
    
    <p>
      Next let’s add the class declaration to the file:
    </p>
    <pre class='external'>1   class Person
2   end

</pre>   
    <p>
       Our code can now create <span class='rubyclass'>Person</span> objects.  We need to load the file again every time we make
       a change, and we can see that the class <span class='rubyclass'>Person</span> is defined:  
    </p>
<pre class='code' language='irb'>
&gt; load 'person.rb'
=&gt; true 
&gt; Person
=&gt; Person
</pre>
<p>Let's
       create an object from our class with the <span class='method'>new</span> method:</p>
    <pre class='code' language='irb'>      
      p = Person.new
       =&gt; #&#060;Person:0x10044c6a8&#062;    </Person:0x10044c6a8>
    
     <p>
       Our new Person object’s is returned and stored in the variable <span class='ic'>p</span>. The whole expression evaluates to the
       value of the varable <span class='ic'>p</span>, so <span class='commandname'>irb</span> displays a text representation of the object,
       which includes its class, <span class='rubyclass'>Person</span>, and an encoded version of the object’s id (0x10044c6a8).  If we make more objects of the <span class='rubyclass'>Person</span> class, each one will have a unique object id.  We haven’t defined any methods in our <span class='rubyclass'>Person</span> class, yet look at our output when we ask our <span class='rubyclass'>Person</span> object for its methods:
     </p>
<pre class='code' language='irb'>
&gt; p.methods
 =&gt; [:nil?, :===, :=~, :!~, :eql?, :hash, :=&gt;, :class, :singleton_class,
 :clone, :dup, :initialize_dup, :initialize_clone, :taint, :tainted?, 
 :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect,
 :methods, :singleton_methods, :protected_methods, :private_methods, … 
 :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__] 
</pre>
<div class='ask_sidebar' id='symbols'>
		<h3 class='title'>What are the names with the colons?</h3>
		<p>They are
    <span class='firstuse'>symbols</span>.   We use
    symbols to label objects, method names or other messages in our code. Symbols are created by
    putting a colon in front of some characters.</p>
    <p>Why are symbols better than strings for labels and
    messages? Each time we evaluate a string, an new object is created — not so with symbols.  Watch this:</p> 
		
		<pre class='code' language='irb'>
		&gt; "thing".object_id
		=&gt; 2160189120 
		&gt; "thing".object_id
		=&gt; 2152614520 
		&gt; :thing.object_id
		=&gt; 370728 
		&gt; :thing.object_id
		=&gt; 370728
		</pre>
		
		<p>Our strings and our symbol are objects since everything in Ruby is an object.  When we ask each object for its
    id, the strings gives us a different id each time, while the symbol gives us the same id.  This means if we were to
    use strings as our arguments above, and then refer to those methods again by the strings, it would create twice as
    many objects as when we use symbols.</p>

    <p> Symbols can have numbers in them, but they need to start with a letter. Like everything else in Ruby, they are
    case-sensitive:</p>
		<pre class='code' language='irb'>
    &gt; :a == :A
    =&gt; false    
    </pre>	  
		<p>
		 We can think of symbols as being like labels for things.  They are kind of like a cross between strings and
     integers. They are immutable, which means they can't be changed. They are similar to integers, where 5 is always 5,
     yet they are made up of textual characters like strings which is nice when reading code.</p>
</div>
       <p>Our new Person object’s return value shows the class of the object, <span class='rubyclass'>Person</span>, and a unique
       reference number (0x10044c6a8).  If we make more objects of the <span class='rubyclass'>Person</span> class, each one
       will be unique. Right now each instance of the class will act exactly the same, we haven’t defined
       any methods in our <span class='rubyclass'>Person</span> class yet.
     </p>
     </pre>
     
     <sect2>
     <h3 class='title'>Defining the <span class='method'>full_name</span> Method</h3>
     <p>
       We’ll need to add the <span class='method'>full_name</span> method to the <span class='rubyclass'>Person</span> class in
       order for its objects to have useful functionality outside of its inherited methods.  Before we change our code,
       let’s check out what happens when we call the non-existent <span class='method'>full_name</span> method on our <span class='rubyclass'>Person</span> object:
     </p>

     <pre class='code' language='irb'>
     &gt; p.full_name
     NoMethodError: undefined method `full_name` for #&#060;Person:0x10044c6a8&#062;       from (irb):19
     </Person:0x10045f0a0>

     <p>
       This time our error message is a <span class='constant'>NoMethodError</span>.  It tells us that currently the
       <span class='method'>full_name</span> method is not defined.  Now we can edit
       <span class='filename'>person.rb</span> so that it has a <span class='method'>full_name</span> method. For starters, we
       won’t make the method do anything, we’ll just define an empty method to understand how it behaves:
     </p>
    <pre class='external'>1   class Person
2     def full_name
3     end
4   end

</pre>   
     <p>
       When we reload <span class='filename'>person.rb</span> and call the <span class='method'>full_name</span> method, nil is returned.
     </p>
     
     <pre class='code' language='irb'>
     &gt; p.full_name
      =&gt; nil
     </pre>
     
     <p>Earlier we learned that everything in Ruby returns something.  Our <span class='method'>full_name</span> method
     returns nil because all empty methods return nil. <span class='ic'>Nil</span> isn’t some special case literal, it is an
     <span class='rubyclass'>Object</span>
     just like everything in Ruby. We can see in <span class='commandname'>irb</span> that <span class='ic'>nil</span> is an instance of <span class='rubyclass'>NilClass</span>
     and we can even call methods on it:</p>
<pre class='code' language='irb'>
&gt;&gt; nil
=&gt; nil
&gt;&gt; nil.class
=&gt; NilClass
&gt;&gt; nil.nil?
=&gt; true
</pre>     
     <p>If we want it to return a value other than nil, say the string &ldquo;Jane Smith&rdquo;, we can put our string inside of our method and Ruby will return the string when we call <span class='method'>full_name</span>.</p>

     <pre class='external'>1   class Person
2     def full_name
3       "Jane Smith"
4     end
5   end

</pre>
     <p>Ruby methods return the last expression evaluated automatically so we don't need to use the
     <span class='keyword'>return</span> keyword (though we can if we want to).  Now our <span class='method'>full_name</span> method
     should return the string &ldquo;Jane Smith&rdquo; instead of <span class='ic'>nil</span>.  Let's try it out: </p>

     <pre class='code' language='irb'>
      &gt; load 'person.rb'
      =&gt; true
      &gt; p = Person.new
      =&gt; #&#060;Person:0x10044c6a8&#062;      &gt; p.full_name
       =&gt; "Jane Smith"
     </Person:0xb77e5fd8>
     
     <p>We reloaded the file again so that <span class='commandname'>irb</span> knows about our changes.  We can see that our
     <span class='method'>full_name</span> method now returns our string as we had hoped.</p>
     </pre>
<sect2>
<h3 class='title'>Object Construction</h3>
<p>Our code would be working great if all of our users were named &ldquo;Jane Smith&rdquo;. Of course our users will have a variety of names, so we need a more intelligent solution.  We know that each person we create must have a name.  Given this knowledge, let's give each person a name when their <span class='rubyclass'>Person</span> object is first created.</p>
<p>Ruby has a special <span class='method'>initialize</span> method that allows us to execute code whenever a new object is instantiated.  Often the <span class='method'>initialize</span> method is used to set up attributes for an object.  In our case we want to put data into attributes for a person's name. Let’s add an <span class='method'>initialize</span> method to our <span class='method'>Person</span> class:</p>
     <pre class='external'>1     def initialize
2       puts "Hello! I am being created at #{Time.now}."
3     end

</pre>
<p>Then let’s see it in action:</p>
<pre class='code' language='irb'>
&gt; load 'person.rb'
=&gt; true
&gt; p = Person.new
&gt; p = Person.new
Hello! I am being created at 2011-04-02 14:54:20 -0700.
=&gt; #&#060;Person:0x10044c6a8&#062;
</Person:0x00000100ac1e48>
<p>We can see that when we call <span class='method'>new</span> on any class, Ruby will call the
<span class='method'>initialize</span> method of the class, if there is one. The newly created object is always returned
from <span class='method'>new</span> and the return value from <span class='method'>initialize</span> is ignored.</p>
<p>Our plan is to make this class accept a first and last name, but for now let’s get a feel for how this works by
starting with just one name as an argument in the initialize method. After all, some people have only one name:</p>
     <pre class='external'>1     def initialize(name)
2       puts name + " is being created."
3     end

</pre>
<p>and Ruby will then require an argument for new:</p>
<pre class='code' language='irb'>
&gt; load 'person.rb'
=&gt; true
&gt;&gt; p = Person.new
ArgumentError: wrong number of arguments (0 for 1)
	from (irb):5:in `initialize'
	from (irb):5:in `new'
	from (irb):5
</pre>
<p>which we can provide just like any other method argument:</p>
<pre class='code' language='irb'>
&gt;&gt; p1 = Person.new("Sacajawea")
Sacajawea is being created.
=&gt; #&#060;Person:0x10044c6a8&#062;&gt;&gt; p2 = Person.new("Teller")
Teller is being created.
=&gt; #&#060;Person:0x10044c6a8&#062;</Person:0x1011c34f8>
<p>We've made good progress, but our <span class='method'>full_name</span> will still report “Jane Smith” for every object. What we really want to do is to save that data inside each object to reference later.  Let's do that next.</p>
</Person:0x1011d6e18>
<sect2>
<h3 class='title'>Storing Data with Objects</h3>
<p>A core concept of object-oriented programming is data encapsulation. We hide the details of the implementation of our
objects inside classes. We make some data available externally and some data remains private. We store data inside of our
objects in <span class='firstuse'>instance variables</span>.  We tell Ruby that a variable is an instance variable by putting a
<em class='emph'>@</em> before the variable.  A variable without the <em class='emph'>@</em> will only be available within the scope of
the method that uses it. </p>
<p>For example, if we try to just use the <span class='ic'>name</span> variable that we have in <span class='method'>initialize</span> in
another method:</p>
     <pre class='external'>1     def full_name
2       name
3     end

</pre>
<p>and then call that method:</p>
<pre class='code' language='irb'>
&gt; load 'person.rb'
=&gt; true
&gt;&gt; p1 = Person.new("Sacajawea")
Sacajawea is being created.
=&gt; #&#060;Person:0x10044c6a8&#062;&gt;&gt; p1.full_name
NameError: undefined local variable or method `name' for #&#060;Person:0x10044c6a8&#062;	from ./person_instance_variable.rb:8:in `full_name'
	from (irb):3
</Person:0x101247730>
<p>Ruby expects words that start with a lower case letter to be either a local variable or a
method. We haven’t set a local variable called <span class='ic'>name</span> inside the <span class='method'>full_name</span> method, nor
have we defined a different method called <span class='method'>name</span>, so Ruby raises a <span class='ic'>NameError</span>.</p>
<p>To make a variable available across methods, we can set an instance variable in one method and use its value in
another, like this:</p>
<pre class='external'>1   class Person
2     def initialize(name)
3       puts name + " is being created."
4       @name = name
5     end
6   
7     def full_name
8       @name
9     end
10   end	

</pre>
<p>Now we can call <span class='method'>full_name</span> to get the appropriate name:</p>
<pre class='code' language='irb'>
&gt; load 'person.rb'
=&gt; true
&gt;&gt; p1 = Person.new("Sacajawea")
Sacajawea is being created.
=&gt; #&#060;Person:0x10044c6a8&#062;&gt;&gt; p1.full_name
=&gt; "Sacajawea"
&gt;&gt; p2 = Person.new("Teller")
Teller is being created.
=&gt; #&#060;Person:0x10044c6a8&#062;&gt;&gt; p2.full_name
=&gt; "Teller"
</pre>
<p>Instance variables are always private, which means that they are not available by default outside of our
class:</p>
<pre class='code' language='irb'>
&gt; p1.@name
SyntaxError: compile error
(irb):11: syntax error, unexpected tIVAR
	from (irb):11
&gt; p1.name
NoMethodError: undefined method `name` for #&#060;Person:0x10044c6a8&#062;  from (irb):19
</Person:0x10045f0a0>
<p>In Ruby, we define methods to expose the data that we want to share with the rest of the world.</p>
</pre>
</Person:0x101247730>

<sect1>
	<h3 class='title'>Inheritance</h3>
	<p>We now have a functioning Person class and we can make as many person objects as we want, each with their own full name.  </p>
	<p>What if we want a more specialized kind of person...say a student?  Students are definitely people, but they have
  some characteristics that are unique such as major, GPA, and year in school. If we wanted to give the qualities of
  personhood to students, we would use inheritance. We could make Student a <span class='firstuse'>subclass</span> of Person.</p>
  <p>In fact, we have already used inheritance. Every class, by default, is a subclass of <span class='rubyclass'>Object</span>.
  Check out some of the built-in behaviors that <span class='rubyclass'>Person</span> inherits from
  <span class='rubyclass'>Object</span>:</p>
<pre class='code' language='irb'>
     &gt; p1.class
      =&gt; Person
     &gt; p1.class.superclass
      =&gt; Object 
</pre>  
   <p>
       The Ruby Object object provides many useful methods for free in any class we create, because every class in Ruby is a descendent of the <span class='rubyclass'>Object</span> class where all these methods are defined.  We can discover the methods of an object like this:
    </p>
<pre class='code' language='irb'>
&gt; p1.methods
 =&gt; [:full_name, :nil?, :===, :=~, :!~, :eql?, :hash, :=&gt;, :class, 
 :singleton_class, :clone, :dup, :initialize_dup, :initialize_clone, 
 …] 
</pre>

<p>We can get the same list by calling <span class='ic'>Person.instance_methods</span>. If we want to see just the instance methods of
the <span class='rubyclass'>Person</span> class, we can subtract the <span class='rubyclass'>Object</span> instance methods:</p>
<pre class='code' language='irb'>
&gt; Person.instance_methods - Object.instance_methods
 =&gt; [:full_name] 
</pre>
<p>Both <span class='ic'>Person.instance_methods</span> and <span class='ic'>Object.instance_methods</span> return arrays of their methods.  The Array class defines the minus operator to remove elements from a list. Ruby and <span class='commandname'>irb</span> makes this kind of experimentation easy.</p>
<p>Now that we understand how our <span class='rubyclass'>Person</span> class inherits behavior from the
<span class='rubyclass'>Object</span> class. Let’s make a new <span class='rubyclass'>Student</span> class that inherit from our
<span class='rubyclass'>Person</span> class and defines new behavior. We use an angle bracket to indicate inheritance.</p>
	<pre class='external'>1   require 'person'
2   class Student &#60; Person
3     def occupation
4       "student"
5     end
6   end

</pre>
	<p>Let's try out our new class in <span class='commandname'>irb</span>:</p>
	<pre class='code'>
	&gt; load 'person_inheritance.rb'
	=&gt; true
	&gt; s = Student.new("Birtha")
	=&gt; #&#060;Person:0x10044c6a8&#062;	&gt; s.full_name
	=&gt; "Birtha"
	&gt; s.occupation
	=&gt; "Student"

	</Student:0xb78247ec>
	
<p> We can see that even though the <span class='method'>full_name</span> method is not defined in the <span class='rubyclass'>Student</span> class, our instance of <span class='rubyclass'>Student</span> has inherited the <span class='method'>full_name</span> from it's <span class='rubyclass'>Person</span> parent.</p>
</pre>

<sect1> 
			<h3 class='title'>Rails Is Ruby</h3>
<p>We've learned a lot about Ruby in this chapter.  We've seen that Ruby is made of objects and we can make Ruby objects from built-in classes or from our own custom classes.  We’ve started understanding the classes that provide a blueprint for our objects and the methods that bring our objects to life.  This understanding will help us understand that the built in Rails classes provide specific blueprints that create patterns for web applications.</p>
      
			<p>We’ve introduced a few key concepts in Ruby that will make Rails syntax much more clear.  For example when we begin learning about ActiveRecord we will see model code that looks like this:
      </p>
		
      <pre class='code' language='ruby'>
         class Person  ActiveRecord::Base
         end
      </pre>
	
      <p>We now know that this Rails model is really just a Ruby class.  The <span class='rubyclass'>Person</span> class inherits from the <span class='rubyclass'>ActiveRecord::Base</span> class. </p>
      
      <p>When we see code like:</p>
	
      <pre class='code' language='ruby'>
      belongs_to :user
      </pre>
    <p>We might be able to guess that <span class='method'>belongs_to</span> is a Ruby method making use of Ruby’s allowance of
    omitted parentheses. The symbol <span class='ic'>:user</span> is an argument to the method. </p>



<p>Since Ruby is an interpreted language, we have had an opportunity to play with code in the Interactive Ruby
environment, <span class='commandname'>irb</span>. Our <span class='commandname'>irb</span> exploration has given us a taste of what
testing our code will be like. We’ve learned to read and understand the error
    messages <span class='ic'>NameError: uninitialized Constant</span> when a class doe not exists and <span class='ic'>NoMethodError</span> if we
    call a method that doesn’t exist. We will see these errors frequently as we use RSpec to test drive Rails, and being familiar with them will help to us in our development. 


We have learned the basics of Ruby that we will need to understand RSpec in the next chapter and Rails in later chapters.  With our new understanding of the fundamentals, it’s time to move on and learn how to write Ruby code <em class='emph'>test first</em>. </p>
    
</div>
</div>
</pre></div></pre></pre></div></pre></div></div></div></div>

<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.rspec-intro' number='4'>
  <h2 class='chapter_title'>Test First Ruby</h2>
<p>We've explored enough Ruby that we are ready to learn RSpec, our key to unlocking the power of testing our code. Of course, there is always more Ruby to learn and we will also learn some more advanced Ruby concepts including attr_accessor methods, hashes, and string interpolation.</p>
<p>By the end of <a class='ref' href='#ch.ruby-intro'></a> we had a simple <span class='rubyclass'>Person</span> class that could store a name.  We&#x2019;ll continue to work on the <span class='rubyclass'>Person</span> class, but now we&#x2019;ll be building it test first with RSpec.  We will use RSpec <span class='firstuse'>specs</span> (RSpec lingo for tests) to suss out what our API should look like, and how we want to use our code. Each spec will verify one example of how we expect our code to work. We will end up with a suite of specs that describe a well thought out and detailed technical design of our <span class='rubyclass'>Person</span> objects.</p>
<sect1>
<h3 class='title'>Writing an Executable Specification</h3>
     
     <p>Our <span class='rubyclass'>Person</span> class already has a <span class='method'>full_name</span> method.  Now we need a  <span class='method'>given_name</span> method and a <span class='method'>surname</span> method that we will concatenate together in our <span class='method'>full_name</span> method. We will design our <span class='rubyclass'>Person</span> class so that <span class='method'>given_name</span> and <span class='method'>surname</span> will be set when we create the object.  We will  also be able to change them or access them at any time. </p>
     <sect2> 
<h3 class='title'>Creating an RSpec File</h3>
<p>By convention, RSpec files are named with a suffix of _spec.rb. A single RSpec file doesn&#x2019;t need to be named in any
special way, but when we have developed a lot of specs in our Rails applications, we&#x2019;ll be able to run a whole directory
full of them if we follow this naming style. In Rails, RSpec will use this suffix to know which files to run. Besides it&#x2019;s just a good idea to be able to look at a
filename and know what&#x2019;s in it.  So let&#x2019;s make a spec to test the code we wrote in
<span class='filename'>person.rb</span> by creating a file named <span class='filename'>person_spec.rb</span>.  
</p>
<p>Like Rails, RSpec is its own domain-specific language. We introduced
the idea of a DSL in <a class='ref' href='#side.dsl'></a>. The RSpec files we write are Ruby code. RSpec defines a number of methods which when used together make it feel like its own language.  The way RSpec names methods is important.  Method names such as <span class='method'>describe</span>, <span class='method'>it</span> and <span class='method'>should</span> are designed to lead us toward thinking of our application as a set of behaviors rather than as chunks of code. </p>
</div>
<sect2>
<h3 class='title'>Describing our Person Class</h3> 
<p>
  RSpec's <span class='method'>describe</span> method sets the stage for specifying part of our code.  We use it to separate
  different concepts and keep our specs organized. The <span class='method'>describe</span> method accepts either a class name or a
  string as a parameter.  Whatever parameter we pass in to the describe block is shown to us when a test fails, so it
  pays off to be thoughtful about what we pass in.  We&#x2019;ll start our spec, with a <span class='commandname'>describe</span>
  block telling RSpec that this is a specification for a <span class='rubyclass'>Person</span> class. 
</p>
     <pre class='external'>1   
<a class='label' id='code.describe_person'>2   describe Person do   
</a><a class='label' id='code.describe_name'>3     describe "name" do  
</a>4     end
5   
<a class='label' id='code.describe_surname'>6     describe "surname" do  
</a>7     end
8   end
9   
10   

</pre>
<p>Nested inside of our first describe block are two describe blocks that specify different aspects of the
<span class='rubyclass'>Person</span> class&#x2019;s behavior. Even though we aren't testing anything yet, let&#x2019;s run our spec to see how
<span class='method'>describe</span> works. We run specs using the rspec gem.  The rspec gem installs a command-line tool that has the same name as the gem. The <span class='commandname'>rspec</span> command will load our spec file and call
the gem. Here's how we run it:</p>
     <pre class='code' language='session'>
$ rspec person_spec.rb
/lib/rspec/core/backward_compatibility.rb:20:in `const_missing': 
  uninitialized constant Object::Person (NameError)
	from /code/person_spec/person_spec.rb:2:in `<top/>(required)&gt;'
	from /rspec-core-2.5.1/lib/rspec/core/configuration.rb:386:in `load'
	from /rspec-core-2.5.1/lib/rspec/core/configuration.rb:386:in `block in 
  load_spec_files'
	from /rspec-core-2.5.1/lib/rspec/core/configuration.rb:386:in `map'
	from /rspec-core-2.5.1/lib/rspec/core/configuration.rb:386:in 
  `load_spec_files'
	from /rspec-core-2.5.1/lib/rspec/core/command_line.rb:18:in `run'
	from /rspec-core-2.5.1/lib/rspec/core/runner.rb:55:in `run_in_process'
	from /rspec-core-2.5.1/lib/rspec/core/runner.rb:46:in `run'
	from /rspec-core-2.5.1/lib/rspec/core/runner.rb:10:in `block in autorun'     
     </pre>
     <p>What&#x2019;s all this? Did we do something wrong? Nope. In test-driven development, we always start with a failing test since we haven't written any code yet. </p>
     <p>This first failure is complaining about a <span class='ic'>NameError</span> for an &#x201C;uninitialized constant&#x201D;. We've seen a <span class='ic'>NameError</span> before, right? During our <span class='commandname'>irb</span> experimentation in the last chapter we got a <span class='ic'>NameError</span> because we hadn't yet defined our <span class='rubyclass'>Person</span> class (remember classes in Ruby are constants).  Our describe block is describing our <span class='rubyclass'>Person</span> class which causes RSpec to go look for that class. </p>
     <p> Whenever we pass a class name to a describe block, the class must exist in order for our tests to pass. When we pass a string into a describe block as we did with <span class='ic'>describe "name"</span>, RSpec doesn't care what characters we put in the string. On the other hand, <em class='emph'>we do care</em> about the contents of the string since it serves as documentation for our code and it will be the output we see when we run our spec.

</p>
     <p> What can we do to move past the <span class='ic'>NameError</span>?  We already wrote the code for the class, so the only thing we need to do is tell RSpec where to find it.  We've already learned one way to include the contents of a file.  Remember how we loaded our person file into irb?  We typed in <span class='ic'>load 'person.rb'</span>.  When we call <span class='ic'>load</span>, Ruby will always load the file, no matter how many times we call it. This behavior is what we want in irb when we are experimenting and loading the file again and again. On the other hand, when we have finished with experimenting, it would be better if our file was included just once.  We can achieve this behavior by calling <span class='ic'>require</span> instead of <span class='ic'>load</span>.  Here is how we use <span class='ic'>require</span> to bring our <span class='rubyclass'>Person</span> class into our spec:
</p>
     <pre class='external'>1   require '.&#47;person'

</pre>
     <p>Ruby expects that the file extension is &#x201C;.rb&#x201D; so we can leave it off. As usual,
     Ruby lets us type less and keep our code uncluttered with information that is almost always the same.
     When we write <span class='ic'>require './person'</span>, we are
     telling Ruby that we want to look for a file called <span class='filename'>person.rb</span> in the current directory.</p>
     <p>Now we can run the spec without an error:</p>
<pre class='code' language='session'>
$ rspec person_spec.rb
No examples were matched. Perhaps {:if=&gt;#&#060;Proc:0x00000100bb7e10/>@/&#x2026&#062;/gems/rspec-core-2.5.1/lib/rspec/core/configuration.rb:50 (lambda)&gt;, 
:unless=&gt;#&#060;Proc:0x00000100bb7e10/>@/&#x2026&#062;core/configuration.rb:51 (lambda)&gt;} is excluding everything?

Finished in 0.00003 seconds
0 examples, 0 failures
</pre>
<p>RSpec tells us <span class='ic'>No examples were matched</span>, which means we haven't written any tests yet.  RSpec is also trying
to be helpful by providing a solution message, but we can ignore it because it doesn&#x2019;t apply to us. We haven&#x2019;t written
any examples yet, so we expect that RSpec won't find any.  The next thing to do is begin writing examples of how we
expect our code to behave.</p>
     </div>
     <sect2>
     <h3 class='title'>Specifying by Example</h3>
     <p>RSpec uses the word <em class='emph'>example</em> to mean individual test case.  There is a good reason to call them examples: it reminds us that we are specifying our code by writing examples of our APIs in action.</p>
         <p>
     We'll start our RSpec example with the <span class='method'>it</span> method, which refers to the context from the enclosing
     <span class='method'>describe</span>. The <span class='method'>it</span> method must be called inside of a describe
     block, otherwise RSpec will
     raise an error. Ideally, each <span class='method'>it</span> block will verify just one aspect of our code.   
     </p>
     
     <p>Let&#x2019;s write our first example for our <span class='rubyclass'>Person</span> class as we defined it in <a class='ref' href='#ch.ruby-intro'></a>: </p>
     <pre class='external'>1     describe "name" do  
2       it "must be set on creation" do  
<a class='label' id='code.person.new'>3         p = Person.new("Hiawatha")   
</a><a class='label' id='code.p.full_name.should'>4         p.full_name.should == "Hiawatha"  
</a>5       end
6     end

</pre>
     <p>We are using the RSpec <span class='method'>should</span> method to assert what we expect to happen in our
       code. The syntax is designed to read a bit like English.</p>
<p>Let's take a quick tour of this code.  On line <a class='cref' href='#code.person.new'>3</a> we made a new <span class='rubyclass'>Person</span> object with an argument of "Hiawatha". We know that this argument will be passed into the <span class='method'>initialize</span> method and that our <span class='ic'>@name</span> instance variable will be set to "Hiawatha".  With this knowledge, on line <a class='cref' href='#code.p.full_name.should'>4</a> we say that we expect the <span class='method'>full_name</span> method to return the same string that we passed to <span class='ic'>Person.new</span>. We are calling the <span class='method'>should</span> method on a <span class='rubyclass'>String</span> object returned by <span class='method'>full_name</span>, but RSpec is designed so that when we are in a spec file we can call the <span class='method'>should</span> method on any object.</p>
     <p>This is actually a <em class='emph'>test last</em> approach because we have already written the code for this example.
     Testing our code last is okay on occasion when we&#x2019;re exploring how our code will work, but we always want to see our test fail first.
     We can ensure that our test fails before it passes by commenting out the implementation of the full_name method like this: </p>
     <pre class='external'>1     def full_name
2       # @name
3     end

</pre>
     <p>In Ruby, a comment starts with a <span class='ic'>#&#060;Proc:0x00000100bb7e10/>@/&#x2026&#062;which can start anywhere on a line. </p>
<p>Before we run the spec, we think about what will
happen. Remember from <a class='ref' href='#ch.ruby-intro'></a> what a method returns when it has no contents? Here's a refresher:</p>
<pre class='code' language='irb'>
$ rspec person_spec.rb 
F

Failures:

  1) Person name must be set on creation
     Failure/Error: p.full_name.should == "Hiawatha" 
       expected: "Hiawatha"
            got: nil (using ==)
     # ./person_spec.rb:11:in `block (3 levels) in <top/>(required)&gt;'

Finished in 0.00051 seconds
1 example, 1 failure
</pre>
  <p>Our answer is that an empty method returns <span class='ic'>nil</span>.  The spec fails as we expect; when we called <span class='ic'>p.full_name</span>, it returned <span class='ic'>nil</span> because we commented out
    the implementation. Let&#x2019;s look closer at the rest of what RSpec tells us. See the &#x201C;F&#x201D;
  on the very first line of the output? RSpec outputs one &#x201C;F&#x201D; per failed example (and one &#x201C;.&#x201D; per passing example). In this case, &#x201C;F&#x201D; stands for failure. This
  seems like a very small indicator now, but for a whole app concise feedback is really helpful. We&#x2019;ll
  have dozens and eventually hundreds of examples.  If one of our specs fails, RSpec will output more helpful feedback to help us correct the error.</p>
  <p>Now we can uncomment the code in our <span class='method'>full_name</span> method and watch it pass:</p>
<pre class='code' language='session'>
$ rspec person_spec.rb
.
Finished in 0.00051 seconds
1 example, 0 failures
</pre>
<p>We can see that the initial feedback for a passing test is just one dot.</p>
</div>
</div>
     <div class='sect1' id='getter_and_setter_methods'>
     <h3 class='title'>Creating Getter and Setter Methods</h3>
     <p>We&#x2019;ve developed a <span class='rubyclass'>Person</span> class that is given a name when it is created.  What
     if we want to change the name after we have already instantiated a <span class='rubyclass'>person</span> object?  That is a job for a setter method.  If we simply want to get the value of the name, we can write a getter method.  We&#x2019;ve already written a <span class='method'>full_name</span> getter method, but our plan for that method is to compose a full name out of a person's given name and surname. Let's make a method that can get just persons given name.</p>
<sect2>
	<h3 class='title'>Test Driven Getter Method</h3>
	    <p>We are about to write a method test first!  Let&#x2019;s start by specifying that our class will have a <span class='method'>given_name</span> getter method:</p>
	     <pre class='external'>1       it "can be accessed" do
2         p = Person.new("Hiawatha")
3         p.given_name.should == "Hiawatha"
4       end

</pre>
	    <p>This spec is very similar to our last one.  We are simply telling RSpec that we expect our <span class='method'>given_name</span> method to return the argument we pass in to <span class='method'>new</span>. </p>
	<pre class='code' language='session'>    
	$ rspec person_spec.rb
	.F
	  1) Person name can be accessed
	     Failure/Error: p.given_name.should == "Hiawatha"
	     NoMethodError:
	       undefined method `given_name' for #&#060;Proc:0x00000100bb7e10/>@/&#x2026&#062;	     # ./person_spec.rb:18:in `block (3 levels) in <top/>(required)&gt;'

	Finished in 0.00051 seconds
	2 examples, 1 failure
	</pre>
	<p>As expected, we see <span class='ic'>NoMethodError: undefined method given_name</span>, so we create a <span class='method'>given_name</span> method:</p>
	     <pre class='external'>1     def given_name
2     end

</pre>
	     <p>We always want to write as little code as possible to fix the error.  We know that our spec will fail again because it is empty and will return nil rather than "Hiawatha", but we want to be sure that it is failing for the right reason.  This technique of fixing only the error at hand becomes increasingly important as code becomes more complex, so it is a good habit to get into.  Let's run the spec again:</p>
	<pre class='code' language='session'>    
	$ rspec person_spec.rb
	.F
	  1) Person name can be accessed
	     Failure/Error: p.given_name.should == "Hiawatha"
	       expected: "Hiawatha"
	            got: nil (using ==)
	     # ./person_spec.rb:18:in `block (3 levels) in <top/>(required)&gt;'

	Finished in 0.00051 seconds
	2 examples, 1 failure
	</pre>
	<p>We progressed a little bit as we are no longer getting a <span class='ic'>NoMethodError</span> Our empty method is  returning <span class='ic'>nil</span> instead of the <variable>@name</variable>.  Let's go ahead and make it pass in the same way we did for <span class='method'>full_name</span>.</p>
	<pre class='external'>1     def given_name
2       @name
3     end

</pre>
	<p>Let's run our test again:</p>
	<pre class='code' language='session'>    
		$ rspec person_spec.rb 
		..

		Finished in 0.0005 seconds
		2 examples, 0 failures
	</pre>
	<p>Zero failures!  Congratulations, we just completed our first test driven method.</p>
</div>

<sect2>
<h3 class='title'>Red, Green, Refactor</h3>
<p> Now that we have some passing tests, let's work on making them readable, concise and maintainable.   Refactoring is the word we use when we rewrite our code with readability and maintainability in mind, without changing what it actually does.  It is a kind thing to do for ourselves and our coworkers.  Refactoring is a key term in test-driven development (TDD): we often hear about the &#x201C;red, green, refactor&#x201D; workflow. In the first step, &#x201C;red&#x201D; describes our failing test. We write the test first and watch it fail. The second step, &#x201C;green,&#x201D; represents the stage when we&#x2019;ve written our code and it works, so the test passes. But we don&#x2019;t stop there. After the test passes, we have the opportunity to <em class='emph'>refactor</em> the code to make it more concise and maintainable. When we refactor we are changing the code, but not the behavior of the code. </p>
<p>Let's put what we just learned into practice and refactor our spec file.</p>
</div>

<sect2>
	<h3 class='title'>Refactoring Our Spec To Use A Before Block</h3>
	<p>Before we move on to writing a setter, lets clean up our spec a
little. Both of our examples create <span class='rubyclass'>Person</span> objects.  We
can remove this repetition by moving the instantiation of our objects
into RSpec's <span class='method'>before</span> method.  The <span class='method'>before</span>
method allows us to keep all the test setup code in one place.  We can
use instance variables in our specs to store our object across all of our
examples.  Let's take a look:</p>
	     <pre class='external'>1     describe "name" do 
2       before do
3         @person = Person.new("Hiawatha")   
4       end
5   
6       it "must be set on creation" do  
7         @person.full_name.should == "Hiawatha"  
8       end
9   
10       it "can be accessed" do
11         @person.given_name.should == "Hiawatha"
12       end
13     end

</pre>
	<p>The <span class='method'>before</span> block runs before each of our
<span class='method'>it</span> blocks.  RSpec is using some advanced Ruby features to
	make the <span class='method'>it</span> method run whatever code we put into the
<span class='method'>before</span> block before the example code is run.</p>
<p>Be sure to run the spec again to make sure it still works.  We are ready to write our setter method.</p>
</div>

<sect2>
<h3 class='title'>Test Driven Setter Method</h3>
    <p>We&#x2019;ll put our setter example inside the <span class='ic'>describe "name"</span> so that we can use
    the same person object from the <span class='ic'>before</span> block.</p>
     <pre class='external'>1       it "can be set" do
2         @person.given_name = "Jean"
3         @person.given_name.should == "Jean"
4       end

</pre>
    <p>We&#x2019;re setting <span class='ic'>given_name</span>, getting its value, and then verifying that it retains the value we set. Let&#x2019;s run it:</p>
<pre class='code' language='session'>
$ rspec person_spec.rb
..F

Failures:

  1) Person name can be set
     Failure/Error: @person.given_name = "Jean"
     NoMethodError:
       undefined method `given_name=' for #&#060;Proc:0x00000100bb7e10/>@/&#x2026&#062;     # ./person_spec.rb:18:in `block (3 levels) in <top/>(required)&gt;'

Finished in 0.00067 seconds
3 examples, 1 failure
</Person:0x000001008b9d30>
<p>The spec failure tells us that when we write <span class='ic'>p.given_name = "Jean"</span>, Ruby expects that the object has a
<span class='method'>given_name=</span> method. We often refer to this as a <span class='firstuse'>setter</span>, but its just a
special case of operators as methods in Ruby. Writing <span class='ic'>p.given_name = "Jean"</span>, is just different syntax for
calling the <span class='method'>given_name=</span> method in the usual way: <span class='ic'>p.given_name=("Jean")</span>. The Ruby
language parser let&#x2019;s us put space around the operator, but in other respects, it is just a plain old method call.</p>


    <p>To fix our <span class='ic'>NoMethodError</span>, we define the <span class='ic'>given_name=</span> method:</p>
     <pre class='external'>1     def given_name=
2     end

</pre>
    <p>We still haven&#x2019;t fully implemented the method, but we want to run the spec and see the new failure:</p>
<pre class='code' language='session'>
$ rspec person_spec.rb
.F

Failures:

  1) Person name can be set
     Failure/Error: p.given_name = "Jean"
     ArgumentError:
       wrong number of arguments (1 for 0)
     # ./person.rb:13:in `given_name='
     # ./person_spec.rb:18:in `block (3 levels) in <top/>(required)&gt;'

Finished in 0.00056 seconds
2 examples, 1 
</pre>
<p>Our example now fails because of an <span class='ic'>ArgumentError</span>. When we write <span class='ic'>p.given_name = "Jean"</span>, the string
&#x201C;Jean&#x201D; is interpreted by Ruby as an argument to the <span class='ic'>given_name=</span> method. To fix this failure, we declare an
argument:</p>
     <pre class='external'>1     def given_name=(new_name)
2     end

</pre>
<p>and then run the spec:</p>
<pre class='code' language='session'>
$ rspec person_spec.rb
.F

Failures:

  1) Person name can be set
     Failure/Error: p.given_name.should == "Jean"
       expected: "Jean"
            got: "Hiawatha" (using ==)
     # ./person_spec.rb:19:in `block (3 levels) in <top/>(required)&gt;'

Finished in 0.00103 seconds
2 examples, 1 failure
</pre>
<p>Whew, we&#x2019;re onto the next line! Now we know our method is defined with the correct name and arguments, and we&#x2019;re
seeing our example fail because we&#x2019;re missing internal logic.</p>		
      <p>Our setter method is working just fine except that it doesn't actually set a variable, which is the purpose of
      setter methods.  Setter methods don't set just any variable either.  They set a variable that has a scope of our
      whole object.  As we learned in <a class='ref' href='#ch.ruby-intro'></a>, variables within the scope of the object are
      called <em class='emph'>instance variables</em> and start with an <span class='ic'>@</span> symbol. In order for the <span class='method'>given_name=</span> method to set an instance variable to a value, it will need to use the argument as the value we give to our instance variable. It will look something like this: </p>
<pre class='external'>1     def given_name=
2     end
3     def given_name=(new_name)
4     end

</pre>
<p>This is where the importance of instance variables shines.  We set the instance variable in the setter method,
    then it is available throughout our entire object, including inside of our getter method.  Let's go back to irb and
    try out our getter and setter methods working together:</p>
<pre class='code' language='irb'>
$ irb
ruby-1.9.2-p0 &gt; load 'person.rb'
 =&gt; true 
&gt; p1 = Person.new("Spock")
 =&gt; #&#060;Proc:0x00000100bb7e10/>@/&#x2026&#062;
&gt; p1.given_name
 =&gt; "Spock" 
&gt; p1.given_name = "Sarek"
 =&gt; "Sarek" 
&gt; p1.given_name
 =&gt; "Sarek" 
</Person:0x00000100a89ea8>
		<p>Works like a charm! </p>
</pre>
</pre>

<div class='sect1' id='attr_accessor'>
		<h3 class='title'>Getting and Setting Instance Variables</h3>
    <p> You could name a method anything and return any instance variable from it,
    but we get some benefits if we name getter and setter methods with the same name as the instance variable they allow us to access. For example, for our <span class='method'>given_name</span> getter and <span class='method'>given_name=</span> setter, we would want an instance variable named <variable>@given_name</variable>.  When we name our code with this convention and need conventional behavior, Ruby offers us the <span class='method'>attr_accessor</span> shortcut which we will make use of soon.  First we need to refactor our code to abide by this convention. Let's change the <variable>@name</variable> variable to <variable>@given_name</variable> so that it has the same name as our getter and setter methods:</p>
    <pre class='external'>1   class Person
2     def initialize(given_name)
3       @given_name = given_name
4     end
5   
6     def given_name
7       @given_name
8     end
9   
10     def given_name=(new_name)
11       @given_name = new_name
12     end
13   
14     def full_name
15       @given_name
16     end
17   end

</pre>
    
    
		<p>Our getter and setter methods are currently written out the long way.  Now it is time to learn the shortcut.  Ruby gives us three methods that reduce our getter and setter methods down to one line: <span class='method'>attr_reader</span>, <span class='method'>attr_writer</span> and <span class='method'>attr_accessor</span>.  If we only need the getter method, we use <span class='method'>attr_reader</span>.  If we only need the setter method, we use <span class='method'>attr_writer</span>.  If we want to create both a getter method and a setter method, we use <span class='method'>attr_accessor</span>.</p>
		
		<p>In our case, we can condense our two methods to just one line:</p>
		<pre class='external'>1   class Person
2     attr_accessor :given_name
3   
4     def initialize(given_name)
5       @given_name = given_name 
6     end
7     
8     def full_name
9       @given_name
10     end
11   end

</pre>
		<p><span class='ic'>attr_accessor :given_name</span> creates both of these methods for us, all in one line:</p>
		<pre class='external'>1   
2     def given_name
3       @given_name
4     end
5   
6     def given_name=(new_name)
7       @given_name = new_name
8     end

</pre>
		
    <p>We run our spec again which verifies that the new code has the same behavior as our initial implementation:</p>
<pre class='code' language='session'>
$ rspec person_spec.rb 
..
Finished in 0.00055 seconds
2 examples, 0 failures
</pre>
		<p>Just one more reason to love Ruby!  We condensed six lines into one, and our tests gave us comfort that nothing got broken in the process of cleaning up our code.  Not too shabby.  </p> 
	<p>Luckily, we can get used to shortcuts like this.  Ruby has many of them and Rails makes ample use of them, as well as adding many more.</p>
		
</div>


		<sect1>
    <h3 class='title'>Implementing Surname with Attribute Accessor</h3>
    <p>So far our <span class='method'>full_name</span> method returns the same thing as our <span class='method'>given_name</span> getter method.  Our goal is for <span class='method'>full_name</span> to return the person's given name and surname together, assuming they have a surname.  If they don't have a surname, then <span class='method'>full_name</span> should just return the given name.  Let's test drive implementing the <span class='method'>surname</span> method. Our first test will be an example of what happens if the person doesn't have a surname:</p>
			<pre class='external'>1     describe "surname" do 
2       it "is empty if it hasn't been set" do  
<a class='label' id='code.person.new.jean'>3         p = Person.new("Jean")    
</a><a class='label' id='code.p.surname'>4         p.surname.should == ""   
</a>5       end
6     end

</pre>
<p>We make a new object on line
<a class='cref' href='#code.person.new.jean'>3</a> and then we tell RSpec on line <a class='cref' href='#code.p.surname'>4</a> that we
expect <span class='ic'>surname</span> to be an empty string. We call this kind of example, the <em class='emph'>null test</em>.</p>
    
    <p>Since we haven&#x2019;t written any code in our class to support a <span class='ic'>surname</span> attribute, we expect it to fail:</p>

<pre class='code' language='session'>
$ rspec person_spec.rb
..F

Failures:

  1) Person surname is empty if it hasn't been set
     Failure/Error: p.surname.should == ""
     NoMethodError:
       undefined method `surname' for #&#060;Proc:0x00000100bb7e10/>@/&#x2026&#062;     # ./person_spec.rb:20:in `block (3 levels) in <top/>(required)&gt;'

Finished in 0.00079 seconds
3 examples, 1 failures
</pre>

    <p>If we want to fix just this one failure, let's use the <span class='method'>attr_reader</span> short cut for just creating a getter method:</p>

<pre class='external'>1     attr_reader :surname

</pre>

<p>We know the return value of an empty method by now (nil), but what about an instance variable that hasn't been set?  When we run this example, the return value of our new <span class='method'>surname</span> method (generated by <span class='ic'>attr_reader :surname</span>) will be the value of <variable>@surname</variable>.  We haven't written any code yet to set <variable>@surname</variable>, so let's take this opportunity to learn what an instance variable returns before we set it.</p>
<pre class='code' language='session'>
$ rspec person_spec.rb
..F

Failures:

  1) Person surname is empty if it hasn't been set
     Failure/Error: p.surname.should == ""
       expected: ""
            got: nil (using ==)
     # ./person_spec.rb:20:in `block (3 levels) in <top/>(required)&gt;'

Finished in 0.00078 seconds
3 examples, 1 failure
</pre>
<p>Just like an empty method, instance variables evaluate to <span class='ic'>nil</span>. We don&#x2019;t get a <span class='ic'>NameError</span> like we do
with local variables if we use them before they are set.</p>
<p>We decided when we wrote the example in our spec that the initial value of <span class='ic'>surname</span> should be an empty string. Let's set <variable>@surname</variable> for every object that is created from our class. We can do that in the initialize method:</p>
<pre class='external'>1     def initialize(given_name)
2       @given_name = given_name 
3       @surname = ""
4     end

</pre>
<p>Now let's write a spec that tests that <span class='ic'>@surname</span> is settable:</p>
<pre class='external'>1       it "can be set" do
2         p = Person.new("Jean")
3         p.surname = "Bartik"
4         p.surname.should == "Bartik"
5       end

</pre>
<p>We expect this spec to fail because we haven't written a <span class='method'>surname=</span> method yet.  Let's watch the spec fail as we expect:</p>
<pre class='code' language='session'>
$ rspec person_spec.rb 
...F

Failures:

  1) Person surname can be set
     Failure/Error: p.surname = "Bartik"
     NoMethodError:
       undefined method `surname=' for #&#060;Proc:0x00000100bb7e10/>@/&#x2026&#062;     # ./person_spec.rb:26:in `block (3 levels) in <top/>(required)&gt;'

Finished in 0.0007 seconds
4 examples, 1 failure
</pre>
<p>Now we can make our spec pass by adding <span class='ic'>:surname</span> to be accessible:</p>
<pre class='external'>1     attr_accessor :given_name, :surname
2     attr_reader :surname

</pre>

<p>So far we have made a <span class='method'>surname</span> getter method using <span class='ic'>attr_reader</span>.  Then we revised our code so that <span class='ic'>attr_accessor</span> created <span class='method'>surname</span> and <span class='method'>surname=</span>.  We haven't had a situation yet where we only needed a setter method.  If we ever want a variable to only be writable and not readable, we can use <span class='ic'>attr_writer</span>. In our case, we want <variable>@surname</variable> to be readable and writable just like <variable>@given_name</variable>. Now our spec passes with a complete implementation of <span class='method'>surname</span> and <span class='method'>given_name</span>, but our <span class='method'>full_name</span> is still only returning <span class='ic'>@given_name</span>, rather than <span class='ic'>@given_name + " " + @surname</span>.  Let's fix that next.</p>
</div>

		<div class='sect1' id='hash_arguments'>
			<h3 class='title'>Using Hash Arguments to Initialize an Object</h3>
			<p>We now have all the pieces we need to complete our <span class='method'>full_name</span> method.  Let's change it so it returns a string with <span class='method'>given_name</span> and <span class='method'>surname</span> separated by a space.  Both <span class='method'>given_name</span> and <span class='method'>surname</span> contain strings, which makes this task pretty easy.  In order to do this we will need to understand a little more about strings.  Just like integers, strings can be added together using the <span class='method'>+</span> method.  We can use <span class='commandname'>irb</span> to demonstrate this:</p>
      
<pre class='code' language='irb'>
&gt; load 'person.rb'
&gt; p.given_name + " " + p.surname
=&gt; "Jean Bartik"
</pre>
			
		  <p>Let&#x2019;s write a spec that tests <span class='method'>full_name</span>.</p>
			<pre class='external'>1     describe "full_name" do
2       it "it concatenates given_name and surname" do  
3         p = Person.new("Jean")   
4         p.surname = "Bartik"      
5         p.full_name.should == "Jean Bartik"  
6       end
7     end

</pre>
      <p>We wrote that example using our existing APIs, but it seems a little wordy. It&#x2019;s awkward to set Jean&#x2019;s
      first name when calling <span class='method'>new</span> and then set her surname on the next line. Here&#x2019;s one way to approach it:</p>      
			<pre class='external'>1       it "it concatenates given_name and surname" do  
2         p = Person.new("Jean", "Bartik") 
3         p.full_name.should == "Jean Bartik"  
4       end

</pre>
      <p>We've cut our code down to two lines instead of three, while maintaining the same functionality.  Now what would we expect to happen when we run our spec? We've added a second argument to the <span class='method'>new</span> method, which will get passed in to the <span class='method'>initialize</span> method.  We might hypothesize that an ArgumentError is in our future.  Let's run our spec to find out if we are right:</p>
<pre class='code' language='session'>
$rspec person_spec.rb 
...F

Failures:

  1) Person full_name it concatenates given_name and surname
     Failure/Error: p = Person.new("Jean", "Bartik")
     ArgumentError:
       wrong number of arguments (2 for 1)
     # ./person.rb:4:in `initialize'
     # ./person_spec.rb:6:in `new'
     # ./person_spec.rb:6:in `block (3 levels) in <top/>(required)&gt;'

Finished in 0.00033 seconds
4 examples, 1 failure        
</pre>
      <p>
        Just as we suspected, an ArgumentError.  We'll need to allow our <span class='method'>initialize</span> method to accept an additional argument for <variable>surname</variable>.  In addition, we'll need to set our <variable>@surname</variable> variable equal to our second argument.  Our code should look like this:
      </p>
      <pre class='external'>1   def initialize(given_name, surname)
2     @given_name = given_name
3     @surname = surname
4   end

</pre>
			<p>Now when we run our spec, we have a passing test:</p>
<pre class='code' language='session'>
$ rspec person_spec.rb 
....

Finished in 0.0003 seconds
4 examples, 0 failure
</pre>
      <p> Our <span class='method'>full_name</span> method is looking great!  Of course, there is more than one way to write this code.  In our case, we might want to consider changing a few things.  For instance, when we call <span class='ic'>Person.new("Gregory", "Frank")</span>, it isn't clear whether the given_name is the first or second argument.  Then when we call our <span class='method'>full_name</span> method, we aren't sure whether this person is named "Gregory Frank" or "Frank Gregory." In this case we would need to look at the source or the docs to determine that his name is actually &#x201C;Gregory Frank&#x201D;. It is a good practice to design self-documenting APIs.  We can make this API more self documenting by using Ruby <span class='rubyclass'>Hash</span> syntax:</p>
			<pre class='external'>1       it "it concatenates first_name and surname" do  
2         p = Person.new(:given_name =&#62; "Gregory", :surname =&#62; "Frank") 
3         p.full_name.should == "Gregory Frank"  
4       end

</pre>
<p>Now our API is clear and easy to understand. This type of argument list is often called an <em class='emph'>options
Hash</em> and is used a lot in Rails.</p>
<p>Writing code test first is part of our design process. We have the opportunity to get a feel for how our APIs behave
before we implement them. Now that we are happy with our API, let&#x2019;s move on to the implementation by running our spec and watching it fail:</p>
<pre class='code' language='session'>			
  1) Person full_name it concatenates given_name and surname
     Failure/Error: p = Person.new(:given_name =&gt; "Gregory", :surname =&gt; "Frank")
     ArgumentError:
       wrong number of arguments (1 for 2)
     # ./person.rb:7:in `initialize'
     # ./person_spec.rb:47:in `new'
     # ./person_spec.rb:47:in `block (3 levels) in <top/>(required)&gt;'
</pre>   
<p>The failure tells us <span class='ic'> wrong number of arguments (1 for 2)</span>, but we&#x2019;re passing both a given name and a surname. Why does RSpec expect a single argument?</p>
<p>RSpec is cluing us in to another bit of Ruby's syntactic sugar.  In fact, we are only passing in one argument, a hash.  Ruby allows us to drop the curly braces around a hash when we pass it into a method.  This special syntax allows us to write <span class='ic'>Person.new({:given_name =&gt; "Gregory", :surname =&gt; "Frank"})</span> as <span class='ic'>Person.new(:given_name =&gt; "Gregory", :surname =&gt; "Frank")</span>.  In this case, we&#x2019;re using it for the initialize method, but this syntax would work for any method.</p>
<pre class='external'>1     def initialize(name_attributes = {})
2       @given_name = name_attributes[:given_name]
3       @given_name = "" if @given_name.nil?
4   
5       @surname = name_attributes[:surname]
6       @surname = "" if @surname.nil?
7     end

</pre>
<p>When we accept the argument, we give it a default value by setting it in the argument list. Then we can set the given_name and surname to the values in the Hash. If a value isn&#x2019;t given for one key or the other, the value will be nil and we can then provide the default value of an empty string.</p>
<p>We can see that works for initialize when we run our spec:</p>
<pre class='code' language='session'>			
$ rspec person_spec.rb
....F

Failures:

  1) Person full_name it concatenates given_name and surname
     Failure/Error: p.full_name.should == "Gregory Frank"
       expected: "Gregory Frank"
            got: "Gregory" (using ==)
     # ./person_spec.rb:31:in `block (3 levels) in <top/>(required)&gt;'

Finished in 0.00089 sec
</pre>   
<p>but it still fails because we haven't finished implementing our <span class='method'>full_name</span> to use instance variables. Let&#x2019;s fix that:</p>
<pre class='external'>1     def full_name
2       @given_name + " " + @surname
3     end
4     def full_name
5       "#{@given_name} #{@surname}".strip
6     end

</pre>
<p>Now when we run our spec:</p>
<pre class='code' language='session'>			
$ rspec person_spec.rb
.....

Finished in 0.00096 seconds
5 examples, 0 failures
</pre>   
<p>All of the examples pass. Hooray! We have a complete implementation.</p>
<sidebar>
<h3 class='title'>Variations on the Hash Argument</h3>
<p>Let's dig a little deeper into hash arguments.  First off, here is something we can't do: </p>
<pre class='code' language='irb'>
&gt; greg = Person.new {:given_name =&gt; "Gregory", :surname =&gt; "Frank"}
SyntaxError: (irb):4: syntax error, unexpected tASSOC, expecting '}'
greg = Person.new {:given_name =&gt; "Gregory", :surname =&gt; "Frank"}
                                  ^
(irb):4: syntax error, unexpected ',', expecting '}'
greg = Person.new {:given_name =&gt; "Gregory", :surname =&gt; "Frank"}
</pre>
<p>Ruby gets confused about precedence when we omit the parentheses. However, we can just provide a list the hash key-value pairs without curly braces:</p>
<pre class='code' language='irb'>			
&gt; greg = Person.new :given_name =&gt; "Gregory", :surname =&gt; "Frank"
 =&gt; #&#060;Proc:0x00000100bb7e10/>@/&#x2026&#062;@surname="Frank"&gt; 
</pre>
<p>We can only omit the curly braces when a method has a single Hash argument or the last argument is a Hash. Rails likes to use this kind of syntax a lot.</p>
</div>
</div>
		<sect1>
				<h3 class='title'>Using String Interpolation</h3>
				<p>Our code is looking pretty good, but suppose we&#x2019;re experimenting with it and we see a problem:</p>
<pre class='code' language='irb'>			
&gt; p = Person.new
=&gt; #&#060;Proc:0x00000100bb7e10/>@/&#x2026&#062;&gt; p.given_name = nil
=&gt; nil 
&gt; p.full_name
NoMethodError: undefined method `+' for nil:NilClass
</Person:0xb7786a38>
<p>Suppose we want to make sure that full_name always returns a String no matter what we set for given_name and surname. What should we do? Should we look at the <span class='method'>full_name</span> implementation to see where the bug is? Not yet. Let&#x2019;s first write a failing test. We use test-driven development for fixing bugs as well as when we develop new code.</p>
<pre class='external'>1       it "returns a string even if given_name is nil" do
2         p = Person.new
3         p.given_name = nil
4         p.full_name.should == ""
5       end

</pre>
<p>We&#x2019;ll see the same error when we run the spec.</p>
				<p>Our <span class='method'>full_name</span> method doesn't work unless <span class='method'>given_name</span> and
        <span class='method'>surname</span> are set.  If they are not set, the <span class='method'>+</span> method throws
        an error because it is being called on nil instead of on a string.  For this reason, we usually use string interpolation instead of <span class='ic'>+</span> to concatenate strings.</p>
<sect2>
<h3 class='title'>String Interpolation</h3>
<p>Ruby has concise syntax for evaluating some Ruby code and inserting the result into the string. Let&#x2019;s see how it
works in irb:</p>
<pre class='code' language='irb'>				
&gt; name = "Gracie"
=&gt; "Gracie" 
&gt; "Goodnight #{name}"
=&gt; "Goodnight Gracie" 
&gt; name = nil
=&gt; nil 
&gt; "Goodnight #{name}"
=&gt; "Goodnight " 
</pre>
<p>Using this special syntax, Ruby will always call <span class='method'>to_s</span> after evaluating the expression before
concatenating it with the rest of the string. <span class='ic'>nil.to_s</span> results in the empty string, so we never get
<span class='ic'>undefined method `+' for nil:NilClass</span> when we&#x2019;re using string interpolation. String interpolation only works for strings surrounded by double quotes. Single quotes will interpret the characters literally:</p>

<pre class='code' language='irb'>				
 &gt; name = "Gracie"
 =&gt; "Gracie" 
 &gt; puts 'Goodnight #{name}'
Goodnight #{name}
 =&gt; nil 
 &gt; puts "Goodnight #{name}"
Goodnight Gracie
 =&gt; nil 
</pre>
<p>Most of the time single and double quotes act the same, but some characters have special meaning in a double-quoted
string. In addition to string interpolation, the &#x201C;\&#x201D; character is used to indicate certain non-ascii characters like
&#x201C;\n&#x201D; for newline and 
&#x201C;\t&#x201D; for tab and &#x201C;\u&#x201D; followed by a hexadecimal number for a unicode character. </p>
</div>          

<p>To make our example pass, we can use interpolation. We should also use the <span class='method'>strip</span> method to remove the extra space that will be left if either <span class='method'>given_name</span> or <span class='method'>surname</span> is nil or blank.</p>
<pre class='external'>1     def full_name
2       "#{@given_name} #{@surname}".strip
3     end

</pre>
<p>By test-driving our bug fixes, we know that we will never have to fix a bug twice. Our specs also serve as documentation for our fellow developers about the expected behavior of our APIs and what kind of data is supported.</p>
		</pre>

		
		<sect1>
    <h3 class='title'>What We've Learned</h3>
    <p> We've worked hard in this chapter to understand RSpec's syntax and the basic concepts behind writing specs.  We saw how important it is to understand Ruby's error messages when we are test driving our code. <span class='ic'>NameError</span>, <span class='ic'>NoMethodError</span> and <span class='ic'>ArgumentError</span> are becoming familiar and we are starting to know what to do when we run into one of them.</p> 
    
    <p>We are also getting a feel for making improvements to our code so that it is more readable and understandable.  We used an argument hash to clear up any confusion about which argument is the given name vs surname.  We also used string interpolation to ensure that our <span class='method'>full_name</span> method always returns a string.  We learned about Ruby's built in <span class='method'>attr_accessor</span> and used it to shorten our getter and setter methods from six lines down to one.</p>

      <p>We are still at the beginning of our exploration of Ruby and test-driven development with RSpec. We will continue to learn more about RSpec and Ruby as we move into our study of Rails. Next we'll return to exploratory development and learn about some of the Rails command line tools as we create our web application.
      </p>


 
		</div>
</div>

</div></div></div>

<!-- -*- xml -*- -->
<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.firstapp' number='5'>
  <h2 class='chapter_title'>Diving Into Rails</h2>
   
<p>Rails engineers are some of the speediest coders around, in part, because of the effective Rails code generators.
Rails generates just enough code to get us started, but not so much to bog us down. In this chapter, we’ll generate a
Rails app using the command-line generators. We’ll also edit a small amount of code and interact with the application in the
browser. This isn’t test first at all, but before we do any testing we need an
understanding of the tech we’re working with and the patterns we will use in creating web applications.</p>
<p>A two-word command is all we need to
create more than 70 files and directories that make up our first Rails app. These two words are: <span class='ic'>rails new</span>.
Let's use this powerfull command to make a simple application that allows a to keep track of students and their work for
a class.</p>
<p>Along with <span class='ic'>rails new</span> we need to specify an application name, in this case we'll call it <span class='ic'>class_app</span>.
The application name is for our reference as developers and for the most part won't affect the code we generate, but we
don’t want to use a Ruby keyword like <span class='ic'>class</span>. We’re also using RSpec in this book, so we’ll use the <span class='ic'>-T</span>
option to turn off the default Test::Unit code generation:</p>

<pre class='code' language='session'>
$ rails new class_app -T
</pre> 
<sidebar>
<h3 class='title'>Creating a Rails App with JRuby</h3>
<p>With most versions of Ruby, like REE, MRI and YARV, you don’t need anything extra for Rails. However, JRuby has additional dependencies. To create a Rails app with appropriate dependendencies, the JRuby team has published a handy template:</p>
<pre class='code' language='session'>
$ rails new class_app –m http://jRuby.org
</pre>
</div>
<p>Doesn't get much easier than that!  Typing this command into the command line tells Rails to make a directory full of
new files and directories that combine to make a complete framework for our code.  A framework that we call
&ldquo;opinionated&rdquo; because of its built in patterns.</p>

<p>If you see errors at this step, check <a class='ref' href='#sec.online-resources'></a> for online references to installation instructions. Assuming Ruby, Rubygems and the Rails gem are installed properly, you’ll have a
<span class='dir'>class_app</span> directory with dozens of files in it and output on the command line that looks like this: </p>
<pre class='code' language='session'>
      create  
      create  README
      create  Rakefile
      create  config.ru
      create  .gitignore
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  app/mailers
      create  app/models
      create  app/views/layouts/application.html.erb
      create  config
      create  config/routes.rb
      create  config/application.rb
        :
        :
      create  tmp/sockets
      create  tmp/cache
      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
</pre>


<p>We have just created a simple, yet complete web application. Rails prefers <em class='emph'>convention over
configuration</em> meaning that having a conventional way of
doing things is preferred to spending time configuring each new project. Rails generates its configuration files 
 with <span class='commandname'>rails new</span>. Each configuration option has a well-thought out default value, so we can
 get started without spending time on configuration.</p>

<sect1>
<h3 class='title'>Running Our Web App</h3>
<p>The whole Rails app is in our newly created <span class='dir'>class_app</span> directory.  This is convenient for a few reasons:</p>
<ul>
<li><p>There are no hidden configuration files in system directories.</p></li>
<li><p>We can delete the directory and its contents if we want to throw it away and start over.
  <div class='footnote'><p>We’re using SQLite so even the database is in this directory, but usually the database is the only part
  of our application that lives somewhere else.</p></div>
    </p></li>
<li><p>We can simply copy this directory to our server to deploy the app.</p></li>
</ul>
<p>We will add and modify many files in our <span class='dir'>class_app</span> directory during development. All of the commands that we will run on the command line will be at the root of the the application directory, so let’s be sure to change the working directory:</p>
<pre class='code' language='session'>
$ cd class_app
</pre>
<p>We have a complete boilerplate web application that has everything it needs to run.  Let’s start up our server:</p>
<pre class='code' language='session'>
$ rails server
=&gt; Booting WEBrick
=&gt; Rails 3.0.1 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-11-28 09:52:39] INFO  WEBrick 1.3.1
[2010-11-28 09:52:39] INFO  Ruby 1.8.7 (2010-08-16) [i686-darwin10.4.0]
[2010-11-28 09:52:39] INFO  WEBrick::HTTPServer#start: pid=27080 port=3000
</pre>

<p> We'll need to point our browser at <a class='url' href='http://localhost:3000'>http://localhost:3000</a> to see our running webapp. We can admire our first Rails app in action!  The default home page of the generated Rails web
app, as shown in <a class='ref' href='#fig.welcome-aboard'>Figure 5.1</a>, contains information about the app’s configuration and links to documentation.</p>
<div class='figure' id='fig.welcome-aboard'>
  <h3 class='title'>Figure 5.1: Default Home Page</h3>
  <img class='imagedata' src='images/welcome-aboard.png'></img>
</div>
<p>Our app is all set up with required boilerplate and default configuration.  Let’s make it our own by modifying the home page of the app.</p>
</div>

<sect1>
<h3 class='title'>Modifying the Home Page</h3>
<p>If this were a static HTML web site, we
would find the home page in the root directory, probably in a file called <span class='filename'>index.html</span>.  There is no
such file in our root directory. Rails will look first for static files in the <span class='dir'>public</span> directory.  Here we
keep static HTML pages and other files such as images, CSS and Javascript.</p>
<p>Rails will look for a static page before it looks for a dynamic page, so if both are available, the static page will win and be served up to the browser.  If we take a look in our <span class='dir'>public</span> directory we will find a file called <span class='filename'>index.html</span>.  This file contains the HTML that formed our home page.  We have found the code we need to modify to make our static homepage more snazzy.</p>
<p>In Rails we can modify most files without stopping and starting the server.  To stop the server, just type control-C,
but it is much easier to just keep the server running.  Let’s open another terminal window and go to the
<span class='dir'>class_app</span> directory, so we can run the server (and see the output) and keep using the command-line in our
first window. Next we’ll open the <span class='filename'>/public/index.html</span> file in an
editor to modify the web page title or some text.</p><p>For example, let’s change:</p>
<pre class='external'>1   &#60;html&#62;
2     &#60;head&#62;
3       &#60;title&#62;Ruby on Rails: Welcome aboard&#60;&#47;title&#62;

</pre>
<p>to:</p>
<div class='figure' id='fig.home-page-change'>
  <h3 class='title'>Figure 5.2: Home Page with Modified Title</h3>
  <img class='imagedata' src='images/home-page-change.png'></img>
</div>
<pre class='external'>1   &#60;html&#62;
2     &#60;head&#62;
3       &#60;title&#62;My Cool Web App&#60;&#47;title&#62;

</pre>
<p>Now we can just refresh the page at <a class='url' href='http://localhost:3000'>http://localhost:3000</a> to see that its title now reads “My Cool Web App.” <a class='ref' href='#fig.home-page-change'>Figure 5.2</a> shows a screen shot of the app in the Chrome browser, so the web page title appears as the name of the tab, but it might appear in your browser in the window title bar.
</p>
<p>Now that we know the basics of running our Rails app and understand how the <span class='dir'>public</span> directory
stores static content,  let's set up our web app for development, configuring the test framework we want to use since it
is different from the default and also look at some of the configuration that Rails has already done for us.</p>
</div>
<sect1>
 <h3 class='title'>Setting up RSpec for Rails</h3>
 <p>We’ve decided to use the RSpec test framework, instead of the default Test:Unit, so we’ll take a moment and
 configure that.</p> 
   <sidebar>
  <h3 class='title'>Rails Environments</h3>
   <p>The group names in our Gemfile
  match the names of our Rails environments. Rails starts with configuration for three environments: development, test,
  and production.</p><p>By default, when we run the server on the command line, Rails will use the development environment.
  When RSpec runs, it will set the environment to test. When we deploy our server for real people to use it, we make
  sure we are running the production environment.</p><p>The <em class='emph'>environment</em> is simply a set of configuration
  options. The general application config is kept in <span class='dir'>config/application.rb</span>, which we can override in the
  specific environment config files:</p>
<pre class='code' language='session'>
$ ls config/environments/
development.rb	production.rb	test.rb
</pre>
<p>Also, we have a different log files for each environment, in addition to the web server log file:</p>

<pre class='code' language='session'>
$ ls log
development.log		production.log		server.log		test.log
</pre>
<p>The rspec-rails gem provides a rake task,
  <span class='commandname'>rake spec</span>, which will take care of setting
  the environment to “test” when we run our specs.</p>
  </div>
  <p>
  We need to install the rspec-rails gem, which includes additional configuration and support for working with a Rails
  app.  We specify this dependency in the Gemfile, which we find in the root directory of our Rails app:</p>
<pre class='external'>1   group :development, :test do
2      gem 'rspec-rails'
3   end

</pre>  
  <p>By adding rspec-rails to the <span class='ic'>:test</span> and <span class='ic'>:development</span> groups in the Gemfile, we
  tell Rails that we are just using this gem for testing and development. We don’t want our test frameworks to be a dependency in
  production.</p>
 <p> We don’t need to specify that we need the RSpec gem in the Gemfile. Since
  rspec-rails has an
  internal dependency list, it will automatically install RSpec.</p> 
<p>After we’ve edited the Gemfile, we need to call <span class='commandname'>bundle</span> to tell Rails that we have
modified the dependencies.</p>
<pre class='code' language='session'>
$ bundle
</pre>
<p>The <span class='commandname'>bundle</span> command can take some time because it will go out to the Internet to find gems
that we haven’t installed locally. It will tell us what gems it installs and which ones it just uses from what we
already have installed with Ruby Gems.</p>
<p>
  Now that we have configured Rails to be able to use the RSpec gem, we can use RSpec’s own generator on the command
  line, to create the default configuration and other files required for running RSpec with Rails:</p>
<pre class='code' language='session'>
$ rails generate rspec:install 
      create  .rspec
      create  spec
      create  spec/spec_helper.rb
</pre>
<p>The <span class='filename'>.rspec</span> file contains the options for the <span class='commandname'>rspec</span> command when it is
called with the <span class='commandname'>rake</span> task. To see all of the options for
<span class='commandname'>rspec</span>, we can type <span class='ic'>rspec --help</span> on the command-line.</p>
<p>We’ll be keeping all of our specs for our Rails application in the <span class='dir'>spec</span> directory. Inside
<span class='dir'>spec</span>, we now also have <span class='filename'>spec_helper.rb</span>, which contains some additional
configuration needed for using RSpec with Rails. We’ll require <span class='filename'>spec_helper.rb</span> in each spec that we
write for our app.</p>
<p>The name <em class='emph'>Rails</em> is a metaphor for its philosophy. Like
 a train on a track, our development can be very fast with Rails; however, it is not a precise metaphor. Unlike with a
 train, when we follow a slightly different path, we are not immoblized. We can veer a little off the common path and
 still maintain velocity for much of our development. The power of Ruby allows Rails to be flexible. We can adapt it
 to our needs, going incredibly fast when our web app is
 very much like most other web applications in the world and needing to take more time, slowing our development only
 when developing something very unique to our application.</p>

</div>




<div class='sect1' id='database-yaml'>
<h3 class='title'>Connecting to a Database</h3>

<p>Rails excels at creating database-driven web applications. By default, Rails is configured to use a relational database, catering to the most common type of web application. The vast majority of applications on the web today are merely a thin layer of HTML and code on top of a relational database. </p>
<p>We’ll use SQLite as the database in learning Rails because it requires no additional configuration and is easy for learning and
experimenting. You can see that the default Rails configuration uses SQLite in <span class='filename'>config/database.yml</span>:</p>
<pre class='external'>1   development:
2     adapter: sqlite3
3     database: db&#47;development.sqlite3
4     pool: 5
5     timeout: 5000
6   
7   test:
8     adapter: sqlite3
9     database: db&#47;test.sqlite3
10     pool: 5
11     timeout: 5000
12   
13   production:
14     adapter: sqlite3
15     database: db&#47;production.sqlite3
16     pool: 5
17     timeout: 5000

</pre>
<p>In the <span class='filename'>database.yml</span> file there are three sets of configurations: development, test, and production. Typically we want at least these three isolated environments, each with their own database. The <em class='emph'>development</em> environment is the default environment in Rails, which acts as a
sandbox for us to work with new code. </p>


<sect2>
<h3 class='title'>The Rails MVC Pattern and REST</h3>
<p>Rails includes a default implementation of the Model-View-Controller pattern with Representational State Transfer (REST).<div class='footnote'><p>In 2000, Roy Fielding described REST as an architectural pattern well-suited to web applications.
<a class='url' href='http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm'>http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</a></p></div>  When we use the REST pattern in our websites we are piggybacking on the Web's architecture.  This makes for intuitive design that benefits us and our users.</p>
<sect3>
<h3 class='title'>REST Principals</h3>
<p>The REST architecture simplifies our web application by treating data on the server as an abstract
<em class='emph'>resource</em> with a consistent representation to the client. This allows for a separation of concerns between the user interface and data storage and for stateless communication between client and server.  The key REST principals are:</p>
<ul>
<li><p>Separation of concerns between UI and data storage</p></li>
<li><p>Uniform interface between components</p></li>
<li><p>Stateless communication</p></li>
</ul>
<p>We’ll see this pattern in action with our <span class='rubyclass'>Person</span> class, which is acts as a <em class='emph'>resource</em> in
Rails.
Rails implements REST by creating a standard set of web pages for the user interface to represent a collection of data.
We’ll start by using scaffold which creates a default representation in both HTML and XML, as well as standard URLs and HTTP actions.  </p>
</div>
<p>So, what are the models, views and controllers, exactly?. </p>
<ul>
 <li><p><em class='emph'>Model</em> represents what is in the database</p></li>
 <li><p><em class='emph'>View</em> is typically HTML, rendered from a template which mixes static content and dynamic data</p></li>
 <li><p><em class='emph'>Controller</em> receives HTTP actions (GET, POST, PUT, DELETE) and then decides what to do, typically rendering a view</p>
 </li>
</ul>
<p> In <a class='ref' href='#fig.rails-mvc'>Figure 5.3</a> you can see the HTTP request-response cycle showing the
flow-of-control through the controller, to the model, then to the view. 
The visitor types a URL into the browser which generates an HTTP request to the Rails web app. That request is handled by a class
called a <em class='emph'>controller</em>. The controller will typically use a <em class='emph'>model</em> to get data from the database which it then renders
using a <em class='emph'>view</em>. Rendering the view creates HTML which is sent to the browser and displayed. Then the visitor
may click a link, which generates a request, and the cycle begins again. </p>
<div class='figure' id='fig.rails-mvc'>
  <h3 class='title'>Figure 5.3: The MVC Request-Response Cycle</h3>
  <img class='imagedata' src='images/rails-mvc.png'></img>
</div>
<p>The easiest way to understand this is by example.  Before we create a web application of our own design, let’s use
the Rails scaffold generator to get a feel for the Rails patterns that are easy to build in our own applications. The
<span class='commandname'>rails generate scaffold</span> command creates a set of web pages and Ruby code for accessing the database and responding to HTTP requests. Rails makes it easy to develop web pages and application code for standard database operations: create, read, update, and delete. </p>
<p>Our application needs to have a list of people in a class.
We’ll specify that we want to create a <span class='ic'>person</span> object that has <span class='ic'>given_name</span> and <span class='ic'>surname</span> attributes which are both strings. </p>
<pre class='code' language='session'>
$ rails generate scaffold person given_name:string surname:string
      invoke  active_record
      create    db/migrate/20110508181731_create_people.rb
      create    app/models/person.rb
      invoke    rspec
      create      spec/models/person_spec.rb
       route  resources :people
      invoke  scaffold_controller
      create    app/controllers/people_controller.rb
      invoke    erb
      create      app/views/people
      create      app/views/people/index.html.erb
      create      app/views/people/edit.html.erb
      create      app/views/people/show.html.erb
      create      app/views/people/new.html.erb
      create      app/views/people/_form.html.erb
      invoke    rspec
      create      spec/controllers/people_controller_spec.rb
      create      spec/views/people/edit.html.erb_spec.rb
      create      spec/views/people/index.html.erb_spec.rb
      create      spec/views/people/new.html.erb_spec.rb
      create      spec/views/people/show.html.erb_spec.rb
      invoke      helper
      create        spec/helpers/people_helper_spec.rb
      create      spec/routing/people_routing_spec.rb
      invoke      rspec
      create        spec/requests/people_spec.rb
      invoke    helper
      create      app/helpers/people_helper.rb
      invoke      rspec
      invoke  stylesheets
      create    public/stylesheets/scaffold.css
</pre>
<p>Since we’re using SQLite we don’t need to do anything special to create the database that our app will use. For any
other kind of database, we would need to call <span class='ic'>rake db:create:all</span> which does nothing when we are using SQLite.</p>
<p>With three environments, specified in <span class='filename'>database.yml</span>, our application will have three databases.
When we experiment with our code interactively, we use the <em class='emph'>development</em> environment and the development database.  With Rails we create database tables and make schema changes using a <em class='emph'>migration</em>, which we'll learn more about in <a class='ref' href='#ch.migrations'></a>. Our person object will store its data in a table in the database. To create the table we call:</p>
<pre class='code' language='session'>
$ rake db:migrate
(in .../class_app)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0012s
==  CreatePeople: migrated (0.0013s) ==========================================
</pre>
<p>We can see by the output that we just created a <em class='emph'>people</em> table in the database.  </p>
</div>
<sect2>
<h3 class='title'>What’s up with these plural nouns?</h3>
<div class='figure' id='fig.pluralization'>
  <h3 class='title'>Figure 5.4: MVC Pattern with Pluralized Names</h3>
  <img class='imagedata' src='images/pluralization.png'></img>
</div>
<p>How did we get a list of <em class='emph'>people</em> when we specified that
we wanted a <em class='emph'>person</em> object? Rails prides itself in letting
programmers be human and speak in English. If we have a person object, a collection of those objects should be
grammatically correct. We should be able to call them people, both in terms of the user interface and internally in the
code. Rails follows a set of naming conventions where a single entity, such as a &ldquo;customer&rdquo; is referred to in the singular, whereas collections, like a bunch of &ldquo;customers&rdquo;  are
referred to as plural. To put it another way, the model object which refers to a single row in the database table is singular, but the
table itself which stores the data for a whole collection of models is plural. The default names in Rails take advantage of helper methods to pluralize the model name to create the
database table name and other names too.  We’ll get into the details of database tables, model and controller classes
and how they work in a bit, but first let’s look at how they are named.</p>

<div class='ask_sidebar'>
<h3 class='title'>How does Rails know about irregular nouns?</h3>
<p>Pluralization rules are controlled by the ActiveSupport::Inflector class in Rails. The <span class='commandname'>rails new</span> command generates a placeholder configuration file with comments that indicate exactly how to configure this.</p>
<p>Using <span class='ic'>rails console</span> we can see that the irregular noun "foot" is not correctly pluralized in Rails.</p>
<pre class='code' language='session'>
&gt; "foot".pluralize
 =&gt; "foots" 
</pre>
<p>To fix this, let’s edit the file <span class='filename'>config/initializers/inflections.rb</span> changing the commented out person/people line to
foot/feet:</p>
<pre class='external'>1   ActiveSupport::Inflector.inflections do |inflect|
2   #   inflect.plural &#47;^(ox)$&#47;i, 'code/class_app_new/00c_add_rspec/config/initializers/inflections.rben'
3   #   inflect.singular &#47;^(ox)en&#47;i, 'code/class_app_new/00c_add_rspec/config/initializers/inflections.rb'
4      inflect.irregular 'foot', 'feet'
5   #   inflect.uncountable %w( fish sheep )
6   end

</pre>
<p>Now when we go back to the console (after exiting and  starting again, <span class='commandname'>reload!</span> is not sufficient in this
case) we’ll  see the correct pluralization:</p>
<pre class='code' language='session'>
&gt; "foot".pluralize
 =&gt; "feet" 
</pre>
<p>Looking at <span class='filename'>inflections.rb</span>, we can see that Rails supports flexible rules for pluralization,
which are well documented in the API
reference<div class='footnote'><p><a class='url' href='http://api.rubyonrails.org/classes/ActiveSupport/Inflector/Inflections.html'>http://api.rubyonrails.org/classes/ActiveSupport/Inflector/Inflections.html</a></p></div>.

There’s also a nice interactive demonstration of Rails pluralization online<div class='footnote'><p>
<a class='url' href='http://nubyonrails.com/tools/pluralize'>http://nubyonrails.com/tools/pluralize</a></p></div>.</p>

<p>Internally, Rails uses Ruby to extend the <span class='rubyclass'>String</span> class to include a
<span class='method'>pluralize</span> method.</p>

</div>
<sect3>
<h3 class='title'>Models are Singular</h3>

<p>The model represents a single object (which maps to a single row in the corresponding database table). You’ll find
the code for the <span class='rubyclass'>Person</span> class in <span class='filename'>app/models/person.rb</span></p>
<pre class='external'>1   class Person &#60; ActiveRecord::Base
2   end

</pre>
<p>This code is explained in <a class='ref' href='#ch.activerecord'>Exploring ActiveRecord</a></p>
</div>
<sect3>
<h3 class='title'>Views Directory is Plural</h3>
<p>There are many views for a specific model, so the views sub-directory is plural. For the whole application there is a
<span class='dir'>views</span> directory. The views associated with this model and controller are kept in the
<span class='dir'>people</span> directory.</p>
</div>
<sect3>
<h3 class='title'>Database tables are Plural</h3>
<p>A database table stores the data for a collection of model objects so the table is named with a plural
noun.  We keep data in a <span class='ic'>people</span> table.</p>
<pre class='code' language='session'>
rails dbconsole
&gt;&gt; select * from people;
</pre>
<p>We'll learn more about interacting with the database console in <a class='ref' href='#ch.activerecord'>Exploring ActiveRecord</a>.</p>
</div>
<sect3>
<h3 class='title'>Controllers are Plural</h3>
<p>The controller works with a collection of models so its name is plural.  In
<span class='filename'>app/controllers/people_controller.rb</span>, we can see that <span class='rubyclass'>PeopleController</span> is a
subclass of <span class='rubyclass'>ApplicationController</span>. We have just one <em class='emph'>application</em> that provides access
to a list of <em class='emph'>people</em>.</p>
<pre class='external'>1   class PeopleController &#60; ApplicationController
2   end

</pre>
<p>This code is explained in <a class='ref' href='#ch.controllers'></a></p>
</div>
</div>
<sect2>
<h3 class='title'>What are all these files generated by scaffold?</h3>
<p>Let’s take a quick look at the files that were generated by the <span class='commandname'>rails generate
scaffold</span> command. We will focus on the core files that implement the MVC pattern.</p>
<p>The <em class='emph'>model</em>, which we’ll look at in depth in the <a class='ref' href='#ch.activerecord'>Exploring ActiveRecord</a> has two associated files. The
<span class='rubyclass'>Person</span> class that implements the model in <span class='filename'>person.rb</span> and the migration that creates the database table that we executed with the “rake db:migrate” command.</p>
<ul>
 <li><p>app/models/person.rb</p></li>
 <li><p>db/migrate/20090611073227_create_people.rb</p></li>
</ul>
<p>The <em class='emph'>controller</em>, which we’ll learn all about in <a class='ref' href='#ch.controllers'></a> is implemented in the PeopleController class in people_controller.rb. It also has a line added to the routes configuration in config/routes.rb which affects how the URL requested from the browser triggers controller actions. </p>
<ul>
 <li><p>app/controllers/people_controller.rb</p></li>
 <li><p>route map.resources :people</p></li>
</ul>
<p>The <em class='emph'>views</em> generated by scaffold are the four pages required for create, update, delete and viewing all
of the data in a table and a the details of a single record. plus a fifth file (_form.html.erb) which
contains snippet of code which is shared by two of the other views. We’ll learn a little about views in <a class='ref' href='#sec.intro-views'></a> and more
in <a class='ref' href='#ch.integration'></a>.</p>
<ul>
 <li><p>app/views/people/index.html.erb</p></li>
 <li><p>app/views/people/show.html.erb</p></li>
 <li><p>app/views/people/new.html.erb</p></li>
 <li><p>app/views/people/edit.html.erb</p></li>
 <li><p>app/views/people/_form.html.erb</p></li>
</ul>
</div>
<sect2>
<h3 class='title'>Exploring the HTML Generated with Scaffold</h3>
<p>To see our scaffold in action, we don't need to stop the server, just browse to
<a class='url' href='http://localhost:3000/people'>http://localhost:3000/people</a>.  Here we see a the listing of the <em class='emph'>people</em> in the database --
a plural noun for the default URL because the page displays a collection.</p>

<p>We have an empty list right now, as shown in <a class='ref' href='#fig.people-listing-empty'>Figure 5.5</a>, but we can see that with
just one command we have a complete web interface for adding, editing and deleting records from our database. We'll
explore it a bit to understand how different parts of Rails work together to create a compelling default implementation
of REST using the MVC pattern.</p>
<div class='figure' id='fig.people-listing-empty'>
  <h3 class='title'>Figure 5.5: Index Page with No Data</h3>
  <img class='imagedata' src='images/people-listing-empty.png'></img>
</div>
<div class='sect3' id='sec.scaffold-rest-mvc'>
<h3 class='title'>How Does Scaffold Implement REST and MVC?</h3>
<p>The <span class='commandname'>generate scaffold</span> command adds just one line to <span class='filename'>config/routes.rb</span>, which implements all of the REST
URLs: <span class='ic'>resources :people</span>. We'll explore more details about routes in <a class='ref' href='#ch.controllers'></a>.  Using
the <span class='method'>resources</span> method for 
a route allows us to specify a whole group of URLs. In just one line, we can express all of the URLs needed for the common database
interactions.</p>

<p>Under the class_app application, we can inspect our routes on
the command-line using a useful rake task:</p>
<pre class='code' language='session'>
$ rake routes     
people GET	/people(.:format)     	{:action=&gt;"index", :controller=&gt;"people"}
people POST	/people(.:format)      	{:action=&gt;"create", :controller=&gt;"people"}
new_person GET	/people/new(.:format)	{:action=&gt;"new", :controller=&gt;"people"}
edit_person GET	/people/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"people"}
person GET	/people/:id(.:format)  	{:action=&gt;"show", :controller=&gt;"people"}
person PUT	/people/:id(.:format)  	{:action=&gt;"update", :controller=&gt;"people"}
person DELETE	/people/:id(.:format)  	{:action=&gt;"destroy", :controller=&gt;"people"}
</pre>
<p>Looking at the first line, we can see that the <span class='ic'>/people</span> URL maps to the <span class='ic'>index</span> action when we type
the URL into the browser or follow a link, which results in an HTTP GET request. However, when the same URL is sent an HTTP POST request, the <span class='method'>create</span> action is triggered.</p>
<p> Let’s go back to our browser to see how this works.  When we click the <em class='emph'>New Person</em> link, we move to a page with a form where we can input data for a new Person record.  The <em class='emph'>new</em> page, as shown in <a class='ref' href='#fig.new-person'>Figure 5.6</a>, corresponds to the URL <span class='ic'>/people/new</span>.  </p>
<div class='figure' id='fig.new-person'>
  <h3 class='title'>Figure 5.6: The  “New” Page</h3>
  <img class='imagedata' src='images/new-person.png'></img>
</div>

<p>When we fill in the fields with a name, like “Fred” for the first name and “Flintstone” for the last name and click
“Create Person” the browser will send an HTTP POST to the <span class='ic'>/people</span> URL.  The <span class='method'>create</span>
action inserts a new record in the database and redirects to the <em class='emph'>show</em> page, which is <span class='ic'>/people/1</span> for
our first record.</p>

<p>We can then click the “Back” link and to see the the list of people which includes our new record, as shown in <a class='ref' href='#fig.people-listing-fred'>Figure 5.7</a>.</p>
<div class='figure' id='fig.people-listing-fred'>
  <h3 class='title'>Figure 5.7: Index Page with One Record</h3>
  <img class='imagedata' src='images/people-listing-fred.png'></img>
</div>

<p>From the people index page we now have the option to show the detail page, edit the record or destroy the record. Go ahead and create a few people for your list. Experiment with editing and deleting a record.</p>
</div>
</div>

</div>

<div class='sect1' id='sec.intro-views'>
<h3 class='title'>Editing Views</h3>
<p>View files, also known as <em class='emph'>templates</em>, ending in .erb are <em class='emph'>Embedded Ruby</em> files.  Similar to JSP, ASP and PHP, these are dynamic web pages that mix HTML and Ruby code.</p>
<p><span class='ic'>&lt;%  ... %&gt;</span>	executes Ruby code	(e.g., setting up conditionals) </p>
<p><span class='ic'>&lt;%= ... %&gt;</span>	evaluates Ruby code, inserting the result in HTML	
(e.g., displaying value returned from a method) 
</p>
<p>Let’s look at part of the code in <span class='filename'>app/views/people/index.html.erb</span>:</p>
<pre class='external'>1     &#60;tr&#62;
2       &#60;td&#62;&#60;%= person.given_name %&#62;&#60;&#47;td&#62;
3       &#60;td&#62;&#60;%= person.surname %&#62;&#60;&#47;td&#62;
4     &#60;&#47;tr&#62;

</pre>

<p>On line <cref linkend="code.people-index.each"/>, in between &lt;% and %&gt; is Ruby code, where <span class='ic'>@people</span> is an instance variable containing an array of
person objects which have a given_name and surname attribute. Calling <span class='method'>each</span> on the array
iterates over the list, each time assigning the next object to the variable <span class='ic'>person</span> which is available to the
following block of code. Notice that the loop ends on line <cref linkend="code.people-index.end"/> – you can continue a multiline
Ruby expression with HTML interspersed. For every iteration, the inner lines HTML will be output as part of the response, so we will see a table row for each person in the collection.</p>
<p>Inside the loop, the Ruby code is evaluated as part of the output stream. <span class='ic'>&lt;%= person.first_name
%&gt;</span> will evaluate <span class='ic'>(person.first_name).to_s</span> and insert the result into the given HTML. If we had Fred Flintstone and Barney Rubble in our list, we would see the following HTML response:</p>

<pre class='code' language='html'> 
<tr>
    <td>Fred</td>
    <td>Flintstone</td>
</tr>
<tr>
    <td>Barney</td>
    <td>Rubble</td>
</tr>
</pre>

<p>The key points to remember are that <span class='ic'>&lt;%</span> just lets us execute Ruby code and that <span class='ic'>&lt;%=</span> will call
<span class='ic'>to_s</span> on the result and insert it into the HTML that is generated.</p>
<sect2>
<h3 class='title'>Exercise</h3>
<p>On the main people page </p>
<ol>
<li><p>Change &ldquo;Listing people&rdquo; to &ldquo;My Class List&rdquo;</p></li>
<li><p>List people with first initial and last name in one visual column (e.g. F. Flintstone) </p></li>
</ol>
<p>When editing views, you will see some helper methods that we haven’t explained yet. Don’t worry about them for now,
you’ll need to understand models, controllers and routes first. However, you may find them fairly easy to read and
understand anyhow. The intent with Rails views is that any Ruby code is small and human readable, so that someone
familiar with HTML and the high-level functionality of the applications would be able to change the visual appearance of
the page, moving around elements generated with Ruby without necessarily understanding the code underneath. Go ahead and
try the exercise yourself before we go through it together. It’s okay. We’ll wait.</p>
</div>
<sect2>
<h3 class='title'>Solution</h3>
<p>To modify the main page, we need to edit <span class='filename'>app/views/people/index.html.erb</span>. The first challenge is changing plain
HTML. We can see “Listing people” in an <span class='ic'>&lt;h1&gt;</span> tag at the top and we can just change the text to “My Class
List”. For the second challenge, we need to
remove a visual column <span class='ic'>&lt;th&gt;Last Name&lt;/th&gt;</span> and combine the two table cells (<span class='ic'>&lt;td&gt;</span> tags) into one Ruby
expression that concatenates the first letter of the first name with the last name. Below we use string interpolation to
accomplish this the results can be seen in <a class='ref' href='#fig.people-listing'>Figure 5.8</a>.</p>
<pre class='external'>1   &#60;% @people.each do |person| %&#62;
2     &#60;tr&#62;
3       &#60;td&#62;&#60;%= "#{person.given_name.first} #{person.surname}" %&#62;&#60;&#47;td&#62;
4     &#60;&#47;tr&#62;
5   &#60;% end %&#62;

</pre>
</div>

<div class='figure' id='fig.people-listing'>
  <h3 class='title'>Figure 5.8: Modified People Index Page</h3>
  <img class='imagedata' src='images/people-listing.png'></img>
</div>
<p>We have created our first database-driven Rails application using the <span class='commandname'>rails new</span> and
<span class='commandname'>generate scaffold</span> commands.</p>
<div class='sect2' id='sec.running-tests'>
<h3 class='title'>Running Our Tests</h3>
<p>Since we configured our application to use RSpec, when we
generated our scaffold, Rails generated tests for our model, views and controller. Since we just modified the code
without test-driving it, let’s take a look at what happens when we run the tests:</p>
<pre class='code' language='session'>
$ rake spec
(in /Users/sarah/…/class_app_new_source)
...............**.........F..

Pending:
  PeopleHelper add some examples to (or delete) …/people_helper_spec.rb
    # Not Yet Implemented
    # ./spec/helpers/people_helper_spec.rb:14
  Person add some examples to (or delete) …/spec/models/person_spec.rb
    # Not Yet Implemented
    # ./spec/models/person_spec.rb:4

Failures:

  1) people/index.html.erb renders a list of people
     Failure/Error: assert_select "tr&gt;td", :text =&gt; "Given Name".to_s,…
     MiniTest::Assertion:
       "Given Name"&gt; expected but was
       "G Surname"&gt;.
     # (eval):2:in `assert'
     # ./spec/views/people/index.html.erb_spec.rb:20:in `block (2 lev…

Finished in 0.39219 seconds
29 examples, 1 failure, 2 pending
rake aborted!
</pre>
<p>RSpec will first print out one character per test. The dots are for tests that pass, <span class='ic'>*</span> for
<span class='firstuse'>pending</span> specs that are placeholders for tests we plan to write later, and <span class='ic'>F</span> for a failing
test. The RSpec framework creates some tests for us and for other parts of our code, it
leaves them for us to fill in. We can see that our change in the view introduced a test failure. We don’t want to leave our code with failing and pending tests, so let’s just delete
those files now. Later we’ll learn how to add our own test code, but for now we want to just leave this chapter with all
of our tests passing.</p>
<pre class='code' language='session'>
$ rm spec/views/people/index.html.erb_spec.rb
$ rm spec/models/person_spec.rb
$ rm spec/helpers/people_helper_spec.rb
$ rake spec
(in …/code/class_app_new_source)
…/bin/ruby -S bundle exec rspec ./spec/controllers/people_controller_spec.rb
./spec/requests/people_spec.rb ./spec/routing/people_routing_spec.rb ./spec/
views/people/edit.html.erb_spec.rb ./spec/views/people/new.html.erb_spec.rb 
./spec/views/people/show.html.erb_spec.rb
..........................

Finished in 0.34845 seconds
26 examples, 0 failures
</pre>
<p>Scaffold is rarely used in the development of production Rails applications, largely because the generated code may
or may not fit exactly what we need, and can lead to maintenance headaches if we’re not careful to delete unused code
and modify or delete broken tests as we develop our application. However, scaffold is an effective learning and
prototyping tool.</p>
</div>
<p>Through our experiments with scaffold, we have a feel for how the
Model-View-Controller pattern works in Rails and the default implementation of REST. We understand how to edit view
templates and the static files that we keep in the <span class='dir'>public</span> directory.  Next we'll dive deeper into
models, controllers and views using interactive testing with the Rails console and test first learning with RSpec. </p>

</div> 
</div>

<!-- -*- xml -*- -->
<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.activerecord' number='6'>
<h2 class='chapter_title'>Exploring ActiveRecord</h2>
<p>Remember how we created a <span class='ic'>person</span> object with the <span class='ic'>generate scaffold</span> command, in <a class='ref' href='#ch.firstapp'></a>?  Our scaffold generated a <span class='rubyclass'>Person</span> class. The <span class='rubyclass'>Person</span> class and its
corresponding <span class='ic'>people</span> table is our model. The model represents a single row in the database table.</p>

<p>ActiveRecord, the <em class='emph'>model</em> in the Rails Model-View-Controller pattern, lets us easily create, retrieve,
update and destroy database records with minimal effort. We skip writing mundane SQL statements, and if we follow
standard naming conventions, we can avoid configuration as well. We can focus on solving our application’s specific needs
rather than writing boilerplate code.</p>

<p>ActiveRecord uses naming conventions to map rows in our database tables to Ruby objects. 
In any language, we call these kinds of libraries &ldquo;Object-Relational-Mappers&rdquo; or ORMs, and we use them because they
let us write natural code in one language to create a corresponding effect in another.  In our case, we manipulate Ruby
objects to effect change in a SQL database.</p>
<p>With ActiveRecord we can: </p>
<ul>
  <li><p>work with Ruby Objects, instead of database tables and records</p></li>
  <li><p>write very concise code to fetch and store data</p></li>
  <li><p>easily write and maintain database independent code</p></li>
</ul>
<p>We’ll pick up just where we left off at the end of the last chapter.  We spent a whole chapter creating a web app,
but it was really just seven commands. Here they are all at once:</p>
<pre class='code' language='session'>
$ rails new class_app -T
$ cd class_app
# edit Gemfile to include rspec-rails
$ bundle
$ rails generate rspec:install
$ rails generate scaffold person given_name:string surname:string 
$ rake db:migrate
$ rails server
</pre>
<p>In the terminal we can see the log output for our running app. We can interact with the default HTML user interface for viewing and
modifying our <span class='ic'>person</span> objects at <a class='url' href='http://localhost:3000/people'>http://localhost:3000/people</a>.</p>
<p>We can find the code for the person model that our scaffold generated in app/models/person.rb. Our model is a subclass of <span class='rubyclass'>ActiveRecord::Base</span> and does not declare the specific attributes that
are in its associated <span class='ic'>people</span> table:  </p>
<pre class='external'>1   class Person &#60; ActiveRecord::Base
2   end

</pre>
<p>The class is declared but there isn’t any code in it. We were able to create
people records by entering names into our application’s web interface. How did we get a functional
web app with no code in the <span class='rubyclass'>Person</span> class?</p>
<p>ActiveRecord constructs attributes for us without any coding on our part.
Our <span class='rubyclass'>Person</span> class inherits behavior from <span class='rubyclass'>ActiveRecord::Base</span> that
dynamically determines what attributes it has by looking at the database structure at runtime. Later we’ll dive into how that database structure was created.  For now, let’s experiment with model objects and get a feel for how they work.</p>

<p>The Rails console is the perfect tool to begin our exploration of how ActiveRecord works. In this chapter, we'll access <span class='rubyclass'>Active
Record::Base</span> methods interactively through our <span class='rubyclass'>Person</span> class. Once we understand ActiveRecord,
we’ll learn to test-drive our model development in the next chapter.  With a firm foundation in the core ActiveRecord
APIs, we will have the confidence to test-drive our code’s unique behavior and not worry about
the built-in functionality, which is already tested by Rails itself.</p>

<div class='sect1' id='sec.explore-active-record'>
<h3 class='title'>Interacting with ActiveRecord in the Rails Console</h3>
<p>The <span class='commandname'>rails console</span> command runs irb, which we explored while learning Ruby, and it also
loads our Rails application environment.  We will have access to the
same classes that are available in our Rails application code. In the last chapter, we used
<span class='commandname'>dbconsole</span> to evaluate
SQL and talk to the database directly.  The Rails console is a completely different command-line tool, which lets us interact with our database only indirectly by evaluating Ruby.  </p>
<p>Let’s launch the console by executing the following command inside the <span class='ic'>class app</span> application main directory:  </p>
<pre class='code' language='session'>
$ rails console
</pre>
<p>As a shortcut we can instead type:</p>
<pre class='code' language='session'>
$ rails c
</pre>
<p>Our model class is available in the console without having to <span class='ic'>require</span> the file. Here we can see that Rails
is Ruby and we can create a Person object, just like any Ruby class:</p>
<pre class='code' language='irb'>
&gt; p = Person.new
=&gt; #&#060;Person/>nil&#062;given_name: nil, surname: nil, created_at: nil,
updated_at: nil&gt; 
</pre>
<p>Let's take a look at the return value of <span class='ic'>Person.new</span>.  It displays the attributes of our newly created person (id, given_name, surname, created_at, updated_at).  If we think back to when we were making new <span class='rubyclass'>Person</span> objects in <a class='ref' href='#ch.ruby-intro'></a>, We will remember that the return of <span class='ic'>Person.new</span> did not include the object's attributes. So what changed?  The answer is that the Rails ActiveRecord::Base class
overrides the built-in <span class='method'>inspect</span> method to give us extra data about its attributes.</p>

<p>Now that we have an instance of our <span class='rubyclass'>Person</span> class to play with, we can see how ActiveRecord provides methods that write directly to the database without our needing to write any SQL:</p>
<pre class='code' language='irb'>
ruby-1.9.2-p0 &gt; p = Person.new(:given_name =&gt; "Adele", :surname =&gt; "Goldstein")
 =&gt; #&#060;Person/>nil&#062;given_name: "Adele", surname: "Goldstein", created_at: 
 nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; p.save
</pre>
<p>After calling <span class='method'>save</span> on our new <span class='rubyclass'>Person</span> object, we have
actually written data to our SQL database. We can browse to <a class='url' href='http://localhost:3000/people'>http://localhost:3000/people</a> and see Adele Goldstein
in our list of people.</p>
<sect2>
<h3 class='title'>Understanding SQL Called by ActiveRecord</h3>
</div>
<p>To better understand how ActiveRecord works and which methods talk to the database directly using SQL, we can look at
SQL queries as they are logged by Rails.  </p>
<p>
We’ll use built-in Rails logging as a diagnostic tool to allow us to see the SQL commands from the log interleaved
interactively with our Ruby code. This technique is very helpful when
  first getting a feel for how ActiveRecord works and sometimes for debugging. </p>
<p>If any part of
ActiveRecord has already been accessed this won’t work. We must do this at the very beginning of a <span class='commandname'>rails console</span> session. </p>
<pre class='code' language='session'>
$ rails c
Loading development environment (Rails 3.0.1)
&gt;&gt; ActiveRecord::Base.logger = Logger.new(STDOUT)
</pre>
<p>
The ActiveRecord class <span class='ic'>logger</span> attribute references another class for logging debug
info, errors and warnings.  The <span class='rubyclass'>Logger</span> class is part of Rails and when Rails starts up, by
default, it will create a logger and pass it a file named for the environment we’re running in the
<span class='dir'>log</span> directory.  Since we’re running in development mode by default, you would normally look at the
log file with the command <span class='ic'>tail -f log/development.log</span>; however, we’re going to use STDOUT which is a Ruby
constant referencing an output stream for the console or terminal where we are running Ruby.  This will echo all of
the log output right where we can see it.</p>
<p>Let’s start by creating another instance of the <span class='rubyclass'>Person</span> class:</p>
<pre class='code' language='irb'>
&gt;&gt; bret = Person.new
</pre>
<p>This is just an in-memory representation of a <span class='rubyclass'>Person</span> object.
  All of the columns in the people database table are available as attributes of the instance, which is just shorthand
  for saying that there is a getter and a setter for each column in the database:</p>
<pre class='code' language='irb'>
&gt;&gt; bret.given_name = "Bret"
&gt;&gt; bret.surname = "Smith"
&gt;&gt; bret
=&gt; #&#060;Person/>nil&#062;given_name: "Bret", surname: "Smith", present: nil, 
created_at: nil, updated_at: nil&gt; 
</pre>
<p>
If we try to access an attribute that is not defined in the people table, Ruby will raise a NoMethodError:</p>
<pre class='code' language='irb'>
&gt;&gt; bret.xxx
NoMethodError: undefined method `xxx' for #&#060;Person/>nil&#062;	from .../attribute_methods.rb:364:in `method_missing'
</Person:0x0000010290a5d0>
<p>We commonly use the Ruby hash syntax which we learned about in <a class='ref' href='#ch.rspec-intro'></a>. The
<span class='rubyclass'>ActiveRecord</span>
constructor allows us to supplying a hash of name-value pairs for each attribute
that we want to set:</p>
<pre class='code' language='irb'>
&gt;&gt; may = Person.new(:given_name =&gt; "May", :surname =&gt; "Fong") 
 =&gt; #&#060;Person/>nil&#062;given_name: "May", surname: "Fong", present: nil, 
created_at: nil, updated_at: nil&gt; 
</pre>
<p/>
<p> We can see that
the id is <span class='ic'>nil</span>, indicating an unsaved record for the object that we created. Setting attributes on the Ruby object doesn’t commit them to the database. We have just created objects that exist only in-memory. We can also call:</p>
<pre class='code' language='irb'>
&gt;&gt; may.new_record?
=&gt; true
</pre>
<p>
<span class='rubyclass'>ActiveRecord</span> keeps track of whether a model just exists in memory or has been committed to the
database. Let’s save the model now, but this time we are logging to <span class='ic'>STDOUT</span> so we will see the SQL commands too:
</p>
<pre class='code' language='irb'>
&gt;&gt; may.save
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (11.9ms)  INSERT INTO "people" ("created_at", "given_name", "surname", 
  "present", "updated_at") VALUES ('2010-09-06 07:09:18.238744', 'May',
  'Fong', NULL, '2010-09-06 07:09:18.238744')
 =&gt; true 
bret.save
</pre>

<p><span class='rubyclass'>ActiveRecord</span> makes the conceptually simple save operation, syntactically simple as well. <span class='rubyclass'>ActiveRecord</span> generates the
appropriate SQL <span class='ic'>INSERT</span> statement for us.  The <span class='method'>save</span> method returns true if the record is successfully saved and false
if there is an error. Now we can see that <span class='method'>new_record?</span>  will return false and
  that our <span class='ic'>may</span> object now has values for id, created_at, and updated_at, which were automatically assigned when
  the record was saved.  Of course, the <span class='ic'>bret</span> record can also be saved.  Whether we create an instance of the <span class='rubyclass'>Person</span> class with attributes passed to the constructor or set them later, the instance will save the current value of that attribute.</p>
<pre class='code' language='irb'>
&gt;&gt; may.new_record?
=&gt; false
&gt;&gt; may
=&gt; #&#060;Person/>nil&#062;given_name: "May", surname: "Fong", present: nil, 
created_at: "2010-09-06 07:09:18", updated_at: "2010-09-06 07:09:18"&gt; 
</pre>
<p>
  ActiveRecord also tracks whether any attributes have been modified, so that if we call save again, it won’t actually
  call the database if we haven't modified anything. Since we’re logging to the console, we can see
  that nothing happens when we call save again without setting any attributes:</p>
<pre class='code' language='irb'>
&gt;&gt; may.save
 =&gt; true 
</pre>

<p>
  We can look at individual attributes to see which ones have changed:</p>
<pre class='code' language='irb'>
&gt;&gt; may.surname 
 =&gt; "Fong" 
&gt;&gt; may.surname_changed?
 =&gt; false 
&gt;&gt; may.surname = "Woo"
 =&gt; "Woo" 
&gt;&gt; may.surname_changed?
 =&gt; true 
&gt;&gt; may.changed?
 =&gt; true 
&gt;&gt; may.save
  SQL (40.4ms)  UPDATE "people" SET "surname" = 'Woo', 
  "updated_at" = '2010-09-06 07:14:08.497625' WHERE ("people"."id" = 1)
 =&gt; true 
</pre>

<p>
   When we modify attributes on an existing record and we save our record, <span class='method'>save</span> will call the database with an <span class='ic'>UPDATE</span> instead of the <span class='ic'>INSERT</span> that was triggered when we initially saved the new record.</p>
<p>In Rails, there is a shortcut that does both new and save in a single operation:</p>

<pre class='code' language='irb'>
&gt;&gt;john = Person.create(:given_name =&gt; "John", :surname =&gt; "Woo")
  SQL (0.4ms)  INSERT INTO "people" ("created_at", "given_name", "surname",
  "present", "updated_at") VALUES ('2010-09-06 20:46:13.660208', 'John', 
  'Woo', NULL, '2010-09-06 20:46:13.660208')
 =&gt; #&#060;Person/>nil&#062;given_name: "John", surname: "Woo", present: nil,
 created_at: "2010-09-06 20:46:13", updated_at: "2010-09-06 20:46:13"&gt; 
</pre>
<p>We can use the <span class='method'>create</span> method to set attributes and save the record in one step. Like
  <span class='method'>new</span>, it is a method on the class, rather than the instance.</p>

<sect2>
<h3 class='title'>Finding Information in the Database</h3>
<p>As with creating, updating, and saving records, if we use the built-in
ActiveRecord methods for finding records, our code will be database independent. We can find records by id, and also
quickly find first, last or all records.  Each of these methods trigger a database SELECT every time they are called. </p>
<dl>
<dt>Person.all</dt>
<dd><p>SELECT * FROM people</p></dd>
<dt>Person.first</dt>
<dd><p>SELECT * FROM people limit 1</p></dd>
<dt>Person.last</dt>
<dd><p>SELECT * FROM ORDER BY id DESC limit 1</p></dd>
</dl>
<p>To get an array of <span class='rubyclass'>Person</span> objects for all of the data in the database we can call
<span class='ic'>Person.all</span>, but the output in the rails console is a little hard to read:</p>
<pre class='code' language='session'>
&gt;&gt; Person.all
 =&gt; [#&#060;Person/>nil&#062;given_name: "May", surname: "Woo", created_at: 
 "2011-01-18 05:25:15", updated_at: "2011-01-18 05:25:15"&gt;, #&#060;Person/>nil&#062;given_name: "Bret", surname: "Smith", created_at: 
 "2011-01-18 05:25:29", updated_at: "2011-01-18 05:25:29"&gt;, #&#060;Person/>nil&#062;given_name: "John", surname: "Woo", created_at: 
 "2011-01-18 05:25:39", updated_at: "2011-01-18 05:25:39"&gt;] 
</pre>
<p>To make the output easier to read, we can display it in YAML format by using the handy  <span class='ic'>y</span>
command and passing it the array of <span class='rubyclass'>Person</span> objects resulting from the ActiveRecord call.  This not
only shows attributes that are generated from the database columns, but also other data for each object, such as the set
of <span class='ic'>changed_attributes</span> and various flags for understanding the state of the object relative to the database:</p>

<pre class='code' language='session'>
&gt;&gt; y Person.all
--- 
- !ruby/object:Person 
  attributes: 
    id: 1
    given_name: May
    surname: Woo
    created_at: 2011-01-18 05:25:15.378022
    updated_at: 2011-01-18 05:25:15.378022
  attributes_cache: {}

  changed_attributes: {}

  destroyed: false
  marked_for_destruction: false
  new_record: false
  previously_changed: {}

  readonly: false
- !ruby/object:Person 
  attributes: 
    id: 2
    …
</pre>
<p>Seeing objects as YAML gives all the data for them, which can be very useful for debugging.</p>
</div>
<sect2>
<h3 class='title'>Finding Something Specific</h3>
<p> The simplest way to find something specific in the database is to call <span class='ic'>where</span> with a hash of attributes to
match:</p>
<pre class='code' language='session'>
&gt;&gt; Person.where(:given_name =&gt; "Bret")
  SQL (0.4ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'
  Person Load (0.2ms)  SELECT "people".* FROM "people" 
  WHERE ("people"."given_name" = 'Bret')
 =&gt; [#&#060;Person/>nil&#062;given_name: "Bret", surname: 
 "Smith", created_at: "2011-01-18 05:25:29", updated_at: 
 "2011-01-18 05:25:29"&gt;] 
</pre>
<p>Check out what happens when we look for something with a single quote in it:</p>
<pre class='code' language='session'>
&gt;&gt; Person.where(:surname =&gt; "O'Henry")
  Person Load (0.2ms)  SELECT "people".* FROM "people" WHERE
  ("people"."surname" = 'O''Henry')
 =&gt; [] 
</pre>
<p>Rails automatically applies the appropriate escape characters so that the single quote doesn't cause a SQL
error.</p>
</div>
<sect2><h3 class='title'>Beware of SQL Injection Attacks</h3>
<p>Improperly escaped user input can cause much more damage than a one-time SQL error: it could potentially wipe out our database. A SQL injection attack is when a malicious person enters text that could evaulate as SQL
commands. Here's an example that shows how the built-in escapting in Rails
protects us:</p>
<pre class='code' language='session'>
&gt;&gt; Person.where(:given_name =&gt; "Bret'; DROP TABLE PEOPLE; --")
  Person Load (0.2ms)  SELECT "people".* FROM "people" 
  WHERE ("people"."given_name" = 'Bret''; DROP TABLE PEOPLE; --')
 =&gt; []   
</pre>
<p>When we specify two name-value pairs in the hash, this is interpreted as an AND operation because that is the most
common.</p>

<pre class='code' language='session'>
&gt;&gt; Person.where(:given_name =&gt; 'May', :surname =&gt; 'Woo')
  Person Load (0.3ms)  SELECT "people".* FROM "people"
  WHERE ("people"."given_name" = 'May') AND ("people"."surname" = 'Woo')
 =&gt; [#&#060;Person/>nil&#062;given_name: "May", surname: "Woo",
created_at: "2011-01-18 05:25:15", updated_at: "2011-01-18 05:25:15"&gt;] 
</pre>
<p>If we need to do other kinds of operations we need to write a snippet of SQL that will be passed in as the
<span class='ic'>WHERE</span> class of the <span class='ic'>SELECT</span> statements. When writing SQL in our code, it is just as important to escape text
that may have come from an end user. To make our
code invulnerable from a SQL injection attack, we can include a &ldquo;?&rdquo; anywhere in the string, then pass the
variables to escape and insert as additional parameters:</p>
<pre class='code' language='irb'>
&gt;&gt; first = "May"
 =&gt; "May" 
&gt;&gt; last = "Woo"
 =&gt; "Woo" 
&gt;&gt; Person.where("given_name = ? AND surname = ?", first, last)
  Person Load (0.2ms)  SELECT "people".* FROM "people" 
  WHERE (given_name = 'May' AND surname = 'Woo')
 =&gt; [#&#060;Person/>nil&#062;given_name: "May", surname: "Woo", created_at: 
 "2011-01-18 05:25:15", updated_at: "2011-01-18 05:25:15"&gt;] 
</pre>
<p>Also, when writing raw SQL, we need to be careful to avoid
database-specific SQL commands or be aware that we are introducing a dependency on our specific database. Most of the
time, we can just use the hash syntax and let Rails worry about the details of the database implementation.</p>
</div>
<sect2>
<h3 class='title'>Chaining Methods to Create Complex Queries</h3>
<p>We’ve been looking at the results of <span class='method'>where</span> right away, but ActiveRecord allows us to defer
executing SQL, so we can build complex queries with multiple Ruby method calls. The
<span class='method'>where</span> method along with other modifiers (such as
order, limit, etc.) returns an <span class='rubyclass'>ActiveRecord::Relation</span>
object.  The SQL query is not actually performed until the result is required – typically when an enumerable method,
such as <span class='method'>each</span> is called on the result or when looking as a specific record in irb or by calling
<span class='method'>first</span>, <span class='method'>last</span>, and <span class='method'>all</span>. </p>
<p>For example, we could find everyone with the surname “Woo” and sort the records by “given_name.” Even though these
are two method calls, there will be only one SQL query:</p>
<pre class='code' language='session'>
  Person.where(:surname =&gt; "Woo").order(:given_name)
</pre>
<p>In the next example we select just one record. A single SQL query which returns a single record from the database: </p>
<pre class='code' language='session'>
  Person.where(:surname =&gt; "Woo").order(:given_name).limit(1)
</pre>
<p>Order may be called with a string or a symbol for the same result:</p>
<pre class='code' language='session'>
  Person.order("given_name")
</pre>
<p>We may optionally specify ASC or DESC when calling order:</p>
<pre class='code' language='session'>
  Person.order("surname DESC").limit(2)
</pre>
<p>The ActiveRecord query methods may be called in any sequence:</p>
<pre class='code' language='session'>
  Person.order("given_name").where(:surname =&gt; "Woo")
</pre>
 
 <p>For more on detail on ActiveRecord queries, you should read the very good Rails
 Guide<div class='footnote'><p>http://guides.rubyonrails.org/active_record_querying.html</p></div>.</p>

<div class='ask_sidebar' id='sb.sidebar.irb_queries'>
<h3 class='title'>How can I experiment with combining SQL Queries in irb?</h3>
<p>
The ActiveRecord query language returns an ActiveRecord::Relation object, but when we set the ActiveRecord
logger to STDOUT we can see that the query is executed in irb.</p>
<pre class='code' language='irb'>
&gt;&gt; result = Person.where(:given_name =&gt; "May")
  Person Load (0.3ms)  SELECT "people".* FROM "people" 
  WHERE ("people"."given_name" = 'May')
 =&gt; [#&#060;Person/>nil&#062;given_name: "May", surname: "Woo", present: nil, 
 created_at: "2010-09-06 07:09:18", updated_at: "2010-09-06 07:14:08"&gt;] 
</pre>
<p>Irb always calls the <span class='method'>inspect</span> method on whatever is returned and then prints that to the console.  Inspect will trigger ActiveRelation to execute its SQL query so that it can report the results.  To see this, let’s try:</p>
<pre class='code' language='irb'>
&gt;&gt; result = Person.where(:given_name =&gt; "May"); nil
 =&gt; nil 
&gt;&gt; result.class
 =&gt; ActiveRecord::Relation 
&gt;&gt; result.limit(1)
  Person Load (0.3ms)  SELECT "people".* FROM "people" WHERE 
  ("people"."given_name" = 'May')
 =&gt; [#&#060;Person/>nil&#062;given_name: "May", surname: "Woo", present: nil, 
 created_at: "2010-09-06 07:09:18", updated_at: "2010-09-06 07:14:08"&gt;] 
</pre>
<p>By adding <span class='ic'>; nil</span> to the end of a line in irb, we avoid causing irb to call the <span class='ic'>inspect</span> method on the
result. This keeps the <span class='rubyclass'>ActiveRecord::Relation</span> object from calling the database, and allows us to
call <span class='method'>limit</span> on the object before evaluating it, and therefore, causing a SQL command to be sent
to the database.</p>
</div>
</div>
</pre>


<sect1>
<h3 class='title'>Using ActiveRecord in Our Web App</h3>
<p>
  Now that we have a better understanding of ActiveRecord, let’s look at our application again in the browser.  Start the web app:</p>
<pre class='code' language='session'>
$ rails server
</pre>
<p>When we browse to <a class='url' href='http://localhost:3000/people'>http://localhost:3000/people</a> we see a page like <a class='ref' href='#fig.people_index_with_3_records'>Figure 6.1</a></p>

<div class='figure' id='fig.people_index_with_3_records'>
  <h3 class='title'>Figure 6.1: People Index Page</h3>
  <img class='imagedata' src='images/class_app/people_index_with_3_records.png'></img>
</div>


<p>
  All of the changes that we made in the database appear in the web application, whether we made changes in Rails console by calling methods on ActiveRecord using interactive Ruby or if we made changes using SQL in dbconsole.  These are just three different ways of looking at and interacting with the same database.</p><p>
  We can click &ldquo;New Person&rdquo;, not fill in anything, click &ldquo;Create Person&rdquo; and this default Rails
  application will happily create a completely blank record. However, we typically want to set up some checks to make
  sure people add good data.  Since this is such a common part of web applications, Rails makes this easy.</p>
</div>
<div class='sect1' id='sec.validations'>  
<h3 class='title'>Validations</h3>
<p>ActiveRecord has a lot of built-in behavior around making sure data is what we want it to be. After all, this class
is all about data. Its sole purpose is to create a <em class='emph'>model</em> in code that represents one single row in our
database. ActiveRecord includes a whole swath of validation methods solely devoted to making sure our data is what we want it to
be.</p>
<p>
  For example, we may want to make sure that the given name is provided and allow the surname to be optional.  To do
  this, we can make a simple change to the model.  Let’s open <span class='filename'>app/models/person.rb</span>.  We see that
  the implementation is a simple subclass of <span class='rubyclass'>ActiveRecord::Base</span>.  All of the behavior that we’ve seen so
  far is built into ActiveRecord.  As we’ve seen the attributes are dynamically discovered from the structure of the
  corresponding database table.  If we want to require specific attributes to be present or in a specific format before
  saving, we add a validation to the model:</p>
<pre class='external'>1   class Person &#60; ActiveRecord::Base
2     validates_presence_of :given_name
3   end

</pre>
<p>With this change, if we attempt to save a blank record, it fails to save and the error will be reported in the web
interface, with a page like <a class='ref' href='#fig.given_name_cant_be_blank'>Figure 6.2</a>.</p>
<div class='figure' id='fig.given_name_cant_be_blank'>
  <h3 class='title'>Figure 6.2: Validation Error</h3>
  <img class='imagedata' src='images/class_app/given_name_cant_be_blank.png'></img>
</div>

<p>
  Rails provides a lot of behavior in just one line of code.  To understand exactly what is going on, let’s go back to
  the console. Unlike when we are running Rails as a server, in the console our code doesn’t automatically
  reload.  If you had left the console open in another window, you’ll need to restart the console or use the
  <span class='commandname'>reload!</span> command to reload the Rails app.</p>
<pre class='code' language='irb'>
&gt;&gt; person = Person.new
 =&gt; #&#060;Person/>nil&#062;given_name: nil, surname: nil, present: nil, 
 created_at: nil, updated_at: nil&gt; 
&gt;&gt; person.save
 =&gt; false 
</pre>
<p>
  The <span class='method'>save</span> method now returns false.  We can inspect what failed by looking at the errors on the person object. </p>
<pre class='code' language='irb'>
&gt;&gt; person.errors
=&gt;{:given_name=&gt;["can't be blank"]}
</pre>
   <p>We can also test for validation errors without attempting to save.  Calling <span class='ic'>valid?</span> will also set errors if one or more validations fail.</p>
<pre class='code' language='irb'>
&gt;&gt; person.valid?
=&gt; false 
</pre>
 <p>
  If a validation fails, the <span class='method'>save</span> or <span class='method'>create</span> methods will return false.  To save the person object and throw an  exception if
  there is an error, we can call the alternate methods: <span class='method'> save!</span> or
  <span class='method'>create!</span>. An exclamation point, which most people call “bang,” as the last character of a
  method name is a convention in Rails where the method will raise an exception if it fails.</p>
<pre class='code' language='irb'>
&gt; person.save!
ActiveRecord::RecordInvalid: Validation failed: given name can't be blank
...stack trace follows...
</pre>
<p>We can see that the bang version of <span class='method'>save!</span> raised an error.</p>
</div>
<sect1>
<h3 class='title'>Conquering Our Data</h3>
<p>We just learned how to create data, give it a home, and find it when we need it.  We now know about SQL injection and how to keep our data safe.  Validations have given us the tools we need to ensure that we are saving well formed data.</p> 

<p>Now that we have a solid base of ActiveRecord skills, we are ready to begin creating ActiveRecord models test first.</p>
</div>
</div>
</div>

<!-- -*- xml -*- -->
<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.activerecord-rspec' number='7'>
<h2 class='chapter_title'>Test Driving Model Development</h2>
<p>With a basic understanding of ActiveRecord and validations, let’s use a test-driven approach to
creating model behavior.  In test-driven development, we write the test first, detailing our requirements by example
with an executable specification before we write the code that implements the feature.  We’ll use RSpec, which we
learned about in <a class='ref' href='#ch.rspec-intro'></a> for test-driving Ruby code.  RSpec works well for testing Rails as well as Ruby. </p>
<p>When we generated our <span class='rubyclass'>Person</span> scaffold, the <span class='ic'>rspec-rails</span> gem created a spec for each class that
was generated. In <a class='ref' href='#sec.running-tests'></a> we used <span class='commandname'>rake spec</span> for the first time to
run the generate test files. We deleted the failing and pending specs, so we could learn about testing from a good
starting point. If we run <span class='commandname'>rake spec</span> again, everything should pass:</p>
<pre class='code' language='session'>
$ rake spec
(in …/code/class_app_new_source)
…/bin/ruby -S bundle exec rspec ./spec/controllers/people_controller_spec.rb
./spec/requests/people_spec.rb ./spec/routing/people_routing_spec.rb ./spec/
views/people/edit.html.erb_spec.rb ./spec/views/people/new.html.erb_spec.rb 
./spec/views/people/show.html.erb_spec.rb
..........................

Finished in 0.34845 seconds
26 examples, 0 failures
</pre>
<p>We’ll start by writing fresh specs to learn about test first development. Later we’ll review what RSpec generated, so
we can understand how to test-drive changes to code once we have a good foundation for the RSpec syntax and the test
first workflow.</p>
<sect1>
<h3 class='title'>Writing our First Model Spec</h3>
<p>Let’s create a blank model spec using the generator. This will also  create a <span class='dir'>spec/models</span>
directory if we didn’t have one already. Placing our tests in the same file hierarchy as our application files saves effort since
<span class='commandname'>rspec-rails</span> will automatically set up the correct load paths and make it so we don’t have to explicitly require the model source file.  </p>

<pre class='code' language='session'>
  $ rails generate rspec:model course
      create  spec/models/course_spec.rb  
</pre>
<p>Just like when we were using RSpec with Ruby, All spec files end with “_spec.rb” and by convention begin with the lower-case name of the class that is being tested with
words separated by underscores.  So the spec for the <span class='rubyclass'>Course</span> class, is in the file <span class='filename'>course_spec.rb</span></p>
<p>RSpec generates a file that looks like this:</p>
<pre class='external'><a class='label' id='code.spec_helper'>1   require 'spec_helper'   
</a>2   
<a class='label' id='code.course_describe'>3   describe Course do   
</a><a class='label' id='code.course_spec_default_pending'>4     pending "add some examples to (or delete) #{__FILE__}"   
</a>5   end

</pre> 
<p>On line <a class='cref' href='#code.spec_helper'>1</a>, the spec requires <span class='filename'>spec_helper</span> which was created with
the <span class='commandname'>rspec:install</span> generator and provides Rails-specific configuration for RSpec and our Rails
testing. We can see, on line <a class='cref' href='#code.course_describe'>3</a>, that this spec will test our
<span class='rubyclass'>Course</span> class, using the same syntax we are familiar with from testing our
<span class='rubyclass'>Person</span> class in Ruby.</p>
<p>RSpec doesn’t generate actual test code for our model – it doesn’t presume
to know what we want our model to do. Instead it provides a <span class='firstuse'>pending</span> note, 
which will remind us that we need to write examples for this spec when we run our test suite. </p>
<p>Let’s write our first example and see how it works. We want our <span class='rubyclass'>Course</span> to have a title and a description, so we’ll start
by writing an example that creates the model exactly as we expect it to work in its most normal case:</p>
<pre class='external'>1   require 'spec_helper'
2   
3   describe Course do  
4     it 'should save a valid record when created with title and description' do
5       c = Course.create!(:title =&#62; "Creative Writing", 
6                          :description =&#62; "Learn to write fiction!") 
7     end
8   end

</pre> 
<p>By calling <span class='method'>create!</span>, we know that ActiveRecord will raise an exception if it fails to create the
record in the database. As in all test frameworks, RSpec will report a failure if an exception is
raised that is not caught, so we know that if create doesn’t work our test will fail.</p>
<p>We’ve only got one spec, but let’s just use the <span class='commandname'>rake spec</span> command that runs them all:</p>
<sidebar>
<h3 class='title'>RSpec rake tasks</h3>
<p>The rspec-rails gem provides a number of rake tasks.  They are all grouped together in the “spec” namespaces, so we
can easily list them:</p>
<pre class='code' language='session'>
$ rake -T spec
(in /Users/sarah/code/class_app_source)
rake spec              # Run all specs in spec directory (excluding plugin specs)
rake spec:controllers  # Run the code examples in spec/controllers
rake spec:helpers      # Run the code examples in spec/helpers
rake spec:lib          # Run the code examples in spec/lib
rake spec:mailers      # Run the code examples in spec/mailers
rake spec:models       # Run the code examples in spec/models
rake spec:rcov         # Run all specs with rcov
rake spec:requests     # Run the code examples in spec/requests
rake spec:routing      # Run the code examples in spec/routing
rake spec:views        # Run the code examples in spec/views
</pre>
</div>

<pre class='code' language='session'>
$ rake spec
(in /Users/sarah/code/class_app_source)
/Users/sarah/.rvm/rubies/ruby-1.9.2-p0/bin/ruby -S bundle exec rspec 
./spec/models/course_spec.rb
/Users/sarah/.rvm/gems/ruby-1.9.2-p0@book/gems/rspec-core-2.5.1/lib
/rspec/core/backward_compatibility.rb:20:in `const_missing': uninitialized 
constant Course (NameError)
	from /Users/sarah/src/tfr/svn/Book/code/class_app_new_source/spec/models
/course_spec.rb:3:in `<top/>(required)&gt;'
	from /Users/sarah/.rvm/gems/ruby-1.9.2-p0@book/gems/rspec-core-2.5.1/lib
/rspec/core/configuration.rb:386:in `load'
	from /Users/sarah/.rvm/gems/ruby-1.9.2-p0@book/gems/rspec-core-2.5.1/lib
/rspec/core/configuration.rb:386:in `block in load_spec_files'
…long stack trace here…
rake aborted!
ruby -S bundle exec rspec ./spec/models/course_spec.rb failed

(See full trace by running task with --trace)

</pre>
<p>Amidst this crazy stack trace, we can see <span class='ic'> uninitialized constant Course (NameError)</span>.  We saw this same kind
of error when we were testing our <span class='rubyclass'>Person</span> class in <a class='ref' href='#ch.rspec-intro'></a>. We know from our
explorations of Ruby that classes are constants, so this error means we’re missing a
<span class='rubyclass'>Course</span> class. This is exactly what we expect since we haven’t written it yet!</p>
<p>We could just write the class from scratch in a new file, but we want to follow Rails conventions for creating not
only our model class, but also its corresponding database table. The easiest way to do that is with a generator. When we
created our <span class='rubyclass'>Person</span> model, we used <span class='commandname'>generate scaffold</span>. Scaffold is a great learning and
prototyping tool, but now that we understand the MVC pattern at a high-level and have a little experience with
<span class='rubyclass'>ActiveRecord</span>, we’ll follow a more typical workflow of building the model, controller and views step by
step. We’ll create our model with the model generator. By default, the rspec-rails gem will also create a model spec, but since we
are test-driving this code, we need to be sure not to overwrite the spec we just wrote when we generate the model:</p>
<pre class='code' language='session'>
$ rails generate model course title:string description:string
      invoke  active_record
      create    db/migrate/20110416135407_create_courses.rb
      create    app/models/course.rb
      invoke    rspec
    conflict      spec/models/course_spec.rb
    Overwrite …/spec/models/course_spec.rb? (enter "h" for help) [Ynaqdh] n
        skip      spec/models/course_spec.rb
</pre>
<p>Now that we’ve created our model class, we believe we’ve resolved our <span class='ic'>Uninitialized Constant</span> error. So let’s
run our spec again:</p>
<pre class='code' language='session'>
sarah:class_app_new_source(01b_active_record)$ rake spec
(in /Users/sarah/src/tfr/svn/Book/code/class_app_new_source)
You have 1 pending migrations:
  20110416135407 CreateCourses
Run "rake db:migrate" to update your database then try again.
</pre>
<p>Cool. The <span class='commandname'>rake spec</span> command reminds us that we need to run our migration before running
our tests. In fact, it does a whole lot more than that.</p>
<sect2>
<h3 class='title'>Understanding <span class='commandname'>rake spec</span></h3>
<p>There are a whole bunch of best practices rolled in this one
command. To see exactly what is going on, we can run <span class='commandname'>rake spec</span> with the <span class='ic'>--trace</span>
option:</p>
<pre class='code' language='session'>
$ rake spec --trace
(in /Users/sarah/src/tfr/svn/Book/code/class_app_new_source)
** Invoke spec (first_time)
** Invoke db:test:prepare (first_time)
** Invoke db:abort_if_pending_migrations (first_time)
** Invoke environment (first_time)
** Execute environment
** Execute db:abort_if_pending_migrations
** Execute db:test:prepare
** Invoke db:test:load (first_time)
** Invoke db:test:purge (first_time)
** Invoke environment 
** Execute db:test:purge
** Execute db:test:load
** Invoke db:schema:load (first_time)
** Invoke environment 
** Execute db:schema:load
** Execute spec
</pre>
<p>When it says <span class='ic'>invoke</span> it is calling a particular rake task, but then it will call its dependencies. To really
see what is happening in what order, check out the <span class='ic'>execute</span> commands. The commands
<span class='commandname'>db:test:prepare</span> and <span class='commandname'>db:test:load</span> don’t do
much themselves, aside from setting up the environment and executing another task or two.  We can see from the output that it is
actually executing the following steps:</p>
<ol>
<li><p>
Don’t run the specs if there are pending migrations in the development database:
<span class='commandname'>db:abort_if_pending_migrations</span>
</p></li>
<li><p>
Drop the test database: <span class='commandname'>db:test:purge</span>
</p></li>
<li><p>
Load the schema into the test database: <span class='commandname'>db:schema:load</span> in environment “test”
</p></li>
</ol>
<p>These steps make sure that we are always testing in a clean environment, so we know exactly what we’re testing when
we run our specs.</p>
</div>
<p>Now that we understand what’s going on. Let’s call <span class='ic'>rake db:migrate</span> to set up our development database and
then call <span class='ic'>rake spec</span> again:</p>
<pre class='code' language='session'>
$ rake db:migrate
(in …/code/class_app_new_source)
==  CreateCourses: migrating ==================================================
-- create_table(:courses)
   -&gt; 0.0010s
==  CreateCourses: migrated (0.0011s) =========================================

$ rake spec
(in /Users/sarah/src/tfr/svn/Book/code/class_app_new_source)
/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby -S bundle…
...........................

Finished in 0.62362 seconds
27 examples, 0 failures
</pre>
<p>Great! We’ve added one more spec to our test suite and they all pass. We’ve confirmed that we generated a model that
matches our expectations. Let’s can step into <span class='ic'>rails console</span> for a quick
look interactively and double-check:</p>

<pre class='code' language='session'>
$ rails c
Loading development environment (Rails 3.0.3)
&gt; c = Course.create!(:title =&gt; "Creative Writing",
&gt;     :description =&gt; "Learn to write fiction!")
 =&gt; #&#060;Course/>1&#062;title: "Creative Writing", description: "Learn to write..."
</pre>

<p>Sometimes, when doing something particularly tricky or using an unfamiliar Ruby class or method, we still test
interactively to get a good feel for how the underlying code works; then, once we have an rspec example for that test
case, we know that we never have to check that behavior again. Also if we forget how some section of my code is supposed to
behave, we can just look at the spec.</p>
</div>
<sect1>
<h3 class='title'>Test Driving Validations</h3>
<p>We want to make sure our <span class='rubyclass'>Course</span> model always has a title, just like we validated that our
<span class='rubyclass'>Person</span> model always had its <span class='ic'>given_name</span> filled in. To write a test for that, we need to think
about what it would be like if our code was already working the way we want it to and then we testing for the correct
behavior. The trick is to do this <em class='emph'>before</em> we’ve written any code to implement that behavior.</p>
<p>Let’s apply what we learned in
<a class='ref' href='#sec.validations'>Validations</a> when we experimented with our <span class='rubyclass'>Person</span> model in the console. We can set up
our model with invalid attributes, then call <span class='ic'>valid?</span> and verify that it returns false. When we’re testing we are
always thinking about what effects our code should have and how would we know if it worked or didn’t work. We’re
defining our model API in a very precise way.</p>
<p>The way we would write these expectations in RSpec is:</p>
<pre class='external'>1     it "should not be valid if it has no title" do
2       c = Course.new(:description =&#62; "Learn to write fiction!") 
3       c.should_not be_valid
4     end

</pre> 
<p>Any method that ends in
a “?” like <span class='commandname'>valid?</span> can be handled specially in RSpec. These methods, called <em class='emph'>predicates</em>, can be used automatically with RSpec in a way that sounds a bit like English.  Above we see that <span class='method'>valid?</span> can be tested with <span class='ic'>p.should be_valid</span>.</p>
<p>RSpec provides this for all predicates. If the matcher begins with &ldquo;be_&rdquo;, RSpec removes the &ldquo;be_&rdquo;, appends a &ldquo;?&rdquo;, and
sends the resulting message to the given object.  In fact, RSpec will do the same for <span class='ic'>be_a_</span> or <span class='ic'>be_an_</span> to support some
predicates where the example reads better with an article, such as <span class='ic'>should be_an_instance_of</span> to call
<span class='method'>instance_of?</span> or <span class='ic'>should be_a_kind_of</span> which will call <span class='method'>kind_of?</span>.</p>
<p>Let’s watch how this example fails by calling <span class='ic'>rake spec</span> again after editing the
<span class='filename'>spec/models/course_spec.rb</span> to include our new example:</p>
<pre class='code' language='session'>
................F...........

Failures:

  1) Course should not be valid if it has no title
     Failure/Error: c.should_not be_valid
       expected valid? to return false, got true
     # ./spec/models/course_spec.rb:11:in `block (2 levels) in <top/>(required)&gt;'

Finished in 0.41685 seconds
28 examples, 1 failure
</pre>
<p>RSpec tells us that we’re checking on the results of <span class='ic'>valid?</span> when we call the <span class='ic'>be_valid</span> Rspec method.
RSpec has a lot of helpful <span class='firstuse'>matchers</span> which are special methods that provide more specific
output for verifying specific behavior.</p>
<p>We could have written our example like <span class='ic'>c.valid?.should == false</span>, however that is a little weird to read with the
question mark followed by a dot, and, more importantly, by using more specific RSpec syntax we get a more specific error
when our test fails. If we call <span class='ic'>.should</span> on the result of <span class='ic'>c.valid?</span> then all RSpec knows is that we
expected <span class='keyword'>true</span> to be <span class='keyword'>false</span>. When we use more specific matchers, RSpec can tell us better information about the failure.</p>
<sect2>
<h3 class='title'>Adding Tests to Our Existing Person Model</h3>
<p>Now that we understand how to use RSpec, we want to go back and add tests for our <span class='rubyclass'>Person</span> model. It’s
okay to write exploratory code without test-driving it – sometimes we need to do that to really understand what’s
possible; however, to keep our code maintainable and make sure the code matches our requirements we want to put some
specs in place.</p>
<p>To get started, we can generate a spec file:</p>
<pre class='code' language='session'>
$ rails g rspec:model person
      create  spec/models/person_spec.rb
</pre>
<p>Edit the file <span class='filename'>spec/models/person_spec.rb</span> so that it has the following contents:  </p>
<pre class='external'>1   require 'spec_helper'
2   
3   describe Person do
4   
5     it 'should save a valid record with first_name and last name' do
6       p = Person.new(:given_name =&#62; "Eve", :surname =&#62; "Smith")
7       p.should be_valid
8     end
9   
10     it 'should not save a record without a name' do
11       p = Person.new
12       p.should_not be_valid
13       p.errors[:given_name].should include("can't be blank")
14     end
15   end
16   
17   

</pre> 
<p>
We can focus on this one new spec by passing the filename as an option to <span class='ic'>rake spec</span>:</p>

<pre class='code' language='session'>
$ rake spec SPEC="spec/models/person_spec.rb"
..

Finished in 0.04756 seconds
2 examples, 0 failures
</pre>

<p>Even though the spec passes, it doesn’t give us confidence since we never saw it fail. In the strictest application
of TDD, we should delete our whole model class and migration, but for now, let’s focus on the additional model code
we’re learning to write. Let’s find our Person model
comment out the validator and see at least one example fail. We can find the source code for our model in
<span class='filename'>app/models/person.rb</span> and comment out the validator:</p>
<pre class='external'>1   class Person &#60; ActiveRecord::Base
2     #validates_presence_of :given_name
3   end

</pre> 
<p>Then when we run the spec, we can see that we get the error we expected:</p>
<pre class='code' language='session'>
$ rake spec SPEC="spec/models/person_spec.rb"
.F

Failures:

  1) Person should not save a record without a name
     Failure/Error: p.should_not be_valid
       expected valid? to return false, got true
     # ./spec/models/person_spec.rb:13:in `block (2 levels) in <top/>(required)&gt;'

Finished in 0.04394 seconds
2 examples, 1 failure
</pre>
<p>Now we can uncomment our validation in the Person model class to make the spec pass. The Rails reference documentation for
validations<div class='footnote'><p>http://ar.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html</p></div> is
quite good and worth reading to be familiar with the built-in validators.</p>
<p>Rails has a concise, declarative syntax that appears like configuration for validators, but with our knowledge of Ruby
we can see that these are just class method calls. Some people call this the Rails DSL, a <em class='emph'>Domain Specific
Language</em> written in Ruby. Of course, that's just a fancy name for a library of classes with methods that are so
well-named and elegantly structured that they feel like a new language. </p>
</div>
</div>
<sect1>
<h3 class='title'>Creating Custom Model Behavior</h3>
<p> We can add
any behavior that we want to our model class by adding class or instance methods with custom behavior.  Remember
that when we are developing a Rails application, we are writing Ruby code. All of the capabilities of the Ruby language
are available to us within our Rails application. Rails gives us a lot of built-in functionality common to web
applications, but we can use it in powerful and flexible ways because of Ruby.    Your model is just a Ruby class which may be extended in standard ways to have its own methods. It is considered a best practice to add logic to the model when possible, so that you can keep your views and controllers small.  </p><p>
Suppose we commonly refer to people with their full name
  (concatenating given and surname). We want this available elsewhere in the code, we can add a
  <span class='method'>full_name</span> method to our model just like we did with our plain old Ruby class when we were learning
  about Ruby. This may seem like a very simple example, but simple, useful methods added to our models can be very
  powerful in keeping our view code clean. Later if we decided to add a middle name, we could just change this one
  method in our model, rather than everywhere in our code. Let’s add this example to the spec for the <span class='ic'>Person</span>
  model by editing spec/models/person_spec.rb:  </p>
<pre class='external'>1     it 'should construct a full name' do
2       p = Person.new(:given_name =&#62; "Eve", :surname =&#62; "Smith")
3       p.full_name.should == "Eve Smith"
4     end

</pre>
<p>Then run <span class='ic'>rake spec</span> to see the following error.</p>
<pre class='code' language='session'>
1)
NoMethodError in 'Person should construct a full name'
undefined method `full_name' for #&#060;Course/>1&#062;.../lib/active_record/attribute_methods.rb:264:in `method_missing'
./spec/models/person_spec.rb:12:
</Person:0x1036ff5f0>
<p>You can see that Ruby reports a <span class='ic'>NoMethodError</span>, since we are sending a full_name message to
the person object “p” where there is no method definition (or corresponding table column for ActiveRecord to dynamically evaluate).  To make this example pass, we can simply define a method:</p>
<pre class='external'>1     def full_name
2       "#{given_name} #{surname}"
3     end

</pre>


<p>
We’ve written specs for validations and a custom model method, only verifying the custom behavior we’ve added to our
model. We can rely on the tests of ActiveRecord in
Rails itself to ensure that the built-in functionality  works.  In our
spec, we focus on what is special in our own app. As much as we can, we want to put behavior in the model, since it is
easiest to isolate the model’s behavior and test it effectively, rather than testing that behavior as it ripple out to
various parts of the application. Understanding
the basics of models, the <em class='emph'>M</em> in the MVC pattern, gives us a firm foundation as we continue to explore Rails.</p>
</pre>
</div>
</div>

<!-- -*- xml -*- -->
<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.rake' number='8'>
  <h2 class='chapter_title'>Rake Helps us Organize Our Ruby Scripts</h2>
  <p>Remember how we created our database back in the ActiveRecord chapter?  It went something like this: <span class='ic'>rake db:create</span> and then <span class='ic'>rake db:migrate</span>. These commands are called rake tasks.  Rake is a build program written in Ruby.  It is also another example of a Domain Specific Language (DSL), meaning that it is a new language that sits on top of Ruby with the sole purpose of building files and running scripts. Rake tasks are great because they make our lives easier.  How would we have created our database without rake?  We could have used a sql console to create the database, add the tables and indexes.  Sounds much more time consuming and error prone than using our two rake commands, right?</p>
  
  <p>
    We've seen first hand how powerful rake can be.  Would you believe that when Jim Wierich came up with the idea for rake, he wasn't convinced it would be of use to Ruby programmers?  It's true.  Read all about it yourself and have a good giggle: http://rake.rubyforge.org/files/doc/rational_rdoc.html.  In this document Jim concedes that he's not sure that anyone would be interested in it.  Thankfully, Jim went ahead and built rake anyway.  Without rake (or something like it), we would need to worry about xml files or finicky Make syntax. Perhaps the most brilliant thing about rake is that we get to continue using Ruby.  With Rake we can use the basic DSL syntax for most tasks.  When tasks are more complex and the rake DSL doesn't have a solution, we can easily use Ruby from within Rake to accomplish our goal. 
  </p>
  <p>
    Let's get ready to learn all about rake.  We'll start off by understanding the basic syntax of common rake tasks.  Later we'll have a chance to talk about Ruby <span class='firstuse'>blocks</span> and <span class='firstuse'>method missing</span>.  First, let's start off learning about the rake tasks we've already used.
  </p>

<sect1>
  <h3 class='title'>ActiveRecord Built In Rake Tasks</h3>
  <p>
    We can see all of the rake tasks that are built into our installed gems by running <span class='ic'>rake -T</span> on the command line.  If we type <span class='ic'>rake -T db</span>, we see a list of our tasks that include the characters <span class='ic'>db</span>.  We see several familiar tasks that we've run before such as <span class='ic'>rake db:create</span> and <span class='ic'>rake db:migrate</span>.  Let's take a moment to dig into how rake tasks do what they do.
  </p>
  <p>
    Let's start off by understanding a task we've used before, <span class='ic'>rake db:create</span>.  We can find this task inside of the activerecord gem.  We can see where the activerecord gem is installed with the following command: <span class='ic'>bundle show activerecord</span>.  The output of this command should be a path to the gem directory.  Now here's a fancy trick: <span class='ic'>cd `bundle show activerecord`</span>.  The code inside of the tic marks is executed so that we move into the directory where the activerecord gem is installed.  When doing Rails development we often need to get a better understanding of how a gem works.  Knowing how to navigate to each gem will make this easy.  Once we open up a gem, we can even put debugging information into the gem's code to inspect variables and make sure the right methods are getting called.
  </p>
  <sect2>
    <h3 class='title'>Namespaces in Rake Files</h3>
      <p>
        To see how <span class='ic'>rake db:create</span> works, let's open this file: lib/active_record/railties/databases.rake in a text editor. Check out that first line, <span class='ic'>namespace :db do</span>.  The <span class='method'>namespace</span> method is defined in the rake gem and does exactly what it sounds like it would do. It allows us to create namespaces for our tasks, putting different tasks into different categories.  The <span class='ic'>rake db:create</span> command is put into the namespace of <span class='ic'>db</span>, short for database.  When we run the command we put a colon after the namespace and then type the name of the task, in this case our task is <span class='ic'>create</span>.    
        
          

        explain rake db:create, rake db:migrate, rake db:seed
        rake -T
    </p>
  </div>
</div>

<sect1>
  <h3 class='title'>Test Driving A Custom Rake Task</h3>
  <p>
    create a rake db:seed task (test first)
  getting rails environment to be loaded in the task
  task :add_students =&gt; :environment do; #code; end
  also, if you want to specify the environment to run the code in, you can do rake add_students RAILS_ENV=production
  eager loading
(http://stackoverflow.com/questions/4300240/rails-3-rake-task-cant-find-model-in-production) 
  could maybe go into method missing
too(http://stackoverflow.com/questions/4017069/correct-rails-3-replacement-for-envrails-env-production)
 </p>
</div>

<sect1>
  <h3 class='title'>Ruby Blocks</h3>
  <p>
    explain blocks - show that you can use rake without a block too if your task just consolidates other tasks
 </p>
</div>

<sect1>
  <h3 class='title'>Rake Features</h3>
  <p>namespaces</p>
  <p>accepting arguments </p>
  <p>desc method for documentation - shows up in rake -T</p>
  <p>default task </p>
</div>

<sect1>
  <h3 class='title'>Ruby Blocks</h3>
  <p>
    explain blocks - show that you can use rake without a block too if your task just consolidates other tasks
 </p>
</div>

<sect1>
  <h3 class='title'>Test Driving Importing Students</h3>
  <p>
  rake task that imports students from a csv file
  File, i/o
  open the csv file
  read/write/play with it
  Rake dependencies &amp; methods
  explain task method vs file method
  show how the file rake method works by having a directory that the csv file is in.  (show how dependencies work.)
  Arrays &amp; Hashes
  manipulate the csv data...maybe only insert some of the students into the db?  
 </p>
</div>

    
 </div>

<!-- -*- xml -*- -->
<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.migrations' number='9'>
  <h2 class='chapter_title'>Creating Our Database Schema with Migrations</h2>
  <p>We will learn about where the database schema
  in our application came from and how a model is created and modified with a migration.</p>
</div>

<!-- -*- xml -*- -->
<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.controllers' number='10'>
  <h2 class='chapter_title'>Exploring Routes and Controllers</h2>

     <p>When we create a web application, we craft a unified experience from a series of web pages. 
  Sometimes a single interaction takes place across multiple HTTP requests. The Model-View-Controller pattern helps us wrangling these disjoint pages into manageable code.</p>
  <p>In <a class='ref' href='#ch.firstapp'></a>, we learned
  about views, how Embedded Ruby templates let us declare the visual part of our web user interface. Then we learned about the model, in  <a class='ref' href='#ch.activerecord'>Exploring ActiveRecord</a> and <a class='ref' href='#ch.activerecord-rspec'></a>.  Now we’ll learn about how routes and
  controllers string our views together, letting us specify the
  interactive part of our user interface.</p><p> As we did with ActiveRecord, we’ll start by exploring interactively,
  but now we can use the browser to see how our code responds. Let’s take another look at the pages
  that scaffold made for our <span class='rubyclass'>Person</span> model. Making sure we’re in our
  <span class='dir'>class_app</span> directory, we
  type <span class='commandname'>rails s</span> to run the server. The index page shows a list of people:</p>
  <p><a class='url' href='http://localhost:3000/people'>http://localhost:3000/people</a></p>
  <p>From there, we can click the “New Person” link to go to a web form to fill in data for a
  new person to add to our database:</p>
  <p><a class='url' href='http://localhost:3000/people/new'>http://localhost:3000/people/new</a></p>
  <p>Then when we fill in the name fields and click “Create” to submit the form, which sends an HTTP POST to:
  <span class='ic'>http://localhost:3000/people</span> and then redirects to:</p>  
  <p><a class='url' href='http://localhost:3000/people/4'>http://localhost:3000/people/4</a></p>
  <p>The database record was created and then the browser was redirected to display a page that showed the details of
  the person. That’s four HTTP requests and three web pages, but it feels like a unified experience because we’re used
  to interacting with web applications in this way.</p>

    <p>In Rails, a <em class='emph'>route</em> specifies how an incoming URL calls our code. Routes are like street signs that point to destinations.  When someone accesses a URL of a Rails web
    application, Rails uses the routes specified in <span class='filename'>config/routes.rb</span>.  This file
    contains a mapping of each URL to our Ruby code which decides what to do. </p>
<p>When we created our app with <span class='commandname'>rails new</span> the <span class='filename'>routes.rb</span> file was created with no
routes defined. The routes file looks almost like a configuration file — it is even kept in the config directory;
however, it is
executable Ruby code. At first glance the file seems lengthy because Rails includes some in-line documentation in the
form of comments that show different example routes, but there is really just a single method call with a
configuration block. When we ran the scaffold generator, it modified this file to add
just one <span class='ic'>resources</span> declaration: </p>
<pre class='external'>1   
2   ClassApp::Application.routes.draw do
3     resources :people
4   end

</pre>
<p>From that one line, we defined 7 routes which we explored interactively in <a class='ref' href='#sec.scaffold-rest-mvc'></a>.
The <span class='ic'>resources</span> method provides a nice shortcut for defining all of the standard REST routes; however, to use Rails effectively we need to understand what’s really going on. We’ll build a similar set of routes and corresponding controller behavior for our
<span class='rubyclass'>Course</span> model one step at a time.</p>
<sect1>
<h3 class='title'>Responding to a URL Request</h3> 
 
  <p>When we go to <a class='url' href='http://localhost:3000/people'>http://localhost:3000/people</a>, the browser sends the HTTP
  request <span class='ic'>GET /people</span> to the server running at <span class='ic'>localhost</span> (listening on port 3000). If the server were a plain old web server, it
  would just respond with the contents of the default file in the
  <span class='dir'>people</span> directory, usually
  <span class='filename'>index.html</span>. Our Rails app dynamically
  determines what page to send back to the browser.</p>
<p>We’ll follow an HTTP request from typing an URL into the browser
through a route to learn about the code we need to write to make it work, starting with a page to display a single
<span class='rubyclass'>Course</span> model. Let’s start by browsing to the URL we haven’t
built yet and see what happens. Let’s point our browser to a new, arbitrary url:
<a class='url' href='http://localhost:3000/my_course'>http://localhost:3000/my_course</a>. We see the routing
error shown in <a class='ref' href='#fig.routing-error'>Figure .1</a>. Go ahead and try it. </p>
<div class='figure' id='fig.routing-error'>
  <h3 class='title'>Figure 10.1: We Have Not Yet Specified Where the URL Goes</h3>
  <img class='imagedata' src='images/controllers/routing-error.png'></img>
</div>
<p>This error tells us that the URL <span class='ic'>/my_course</span> is not hooked up to anything. There is no <em class='emph'>route</em> into the app
that matches that string.</p>
<sect2>
<h3 class='title'>Let’s Create a Route</h3>
<p>A route maps an external URL to internal code, so the route has two parts. The first is the path section of the URL, the part after the hostname and port, in our example
it’ll just be <span class='ic'>my_course</span>. The second part references what code it calls, which is usually a method of a controller class.
We’ll hook up <a class='url' href='http://localhost:3000/my_course'>http://localhost:3000/my_course</a> to the <span class='method'>show</span> method of our not yet written
<span class='rubyclass'>CoursesController</span> class. We’re using the standard Rails naming convention for the controller action that
displays a single record. Later we’ll learn how to implement the standard URL name with a parameter, but we’ll focus first on how a very simple
route works.
Let’s comment out the <span class='ic'>resources</span> line so we can focus on our new
route:</p>
<pre class='external'>1   
2   ClassApp::Application.routes.draw do
3     #resources :people
4     match "my_course" =&#62; "courses#show"
5   end

</pre>
<div class='ask_sidebar'>
<h3 class='title'>How does the Match Method Work?</h3>
<p>Let’s learn a little more Ruby to understand how the match method works.</p>
<pre class='code' language='irb'>
$ rails c
&gt; result = "courses#show".split('#')                        
 =&gt; ["courses", "show"] 
&gt; controller_name = result[0].camelize + "Controller"
 =&gt; "CoursesController" 
</pre>
<p>First we call <span class='method'>split</span>, which is a Ruby <span class='rubyclass'>String</span> method, to get the two components. Then
we took the first component and call <span class='method'>camelize</span> which is a <em class='emph'>Rails</em> <span class='rubyclass'>String</span> method. Rails
adds a lot of useful methods to the core Ruby classes. </p>
</div>

<p>The routes syntax is chock full of shortcuts, so it looks more like a config file than source code. Remembering our Ruby syntax, we can see that it is actually calling the <span class='ic'>match</span> method
and passing it a <span class='ic'>Hash</span> parameter that has a single key-value pair with <span class='ic'>"my_course"</span> as the key and
<span class='ic'>"courses#show"</span> as the value.</p>
<p>Rails applies a
naming convention that many programmers already know — the Rails routing
syntax of “class#method” is also used in Ruby’s RDoc and ri documentation tools, as well as
Javadocs and documentation tools for other languages.  So, <span class='ic'>courses#show</span> means
that we’ll be creating a <span class='rubyclass'>CoursesController</span> with a <span class='method'>show</span> method to be called when someone browses to
<span class='ic'>/my_course</span>.</p>
<sect3>
<h3 class='title'>Routes Automatically Define Methods</h3>
<p>In addition to defining as entry point for our app and referring to a controller method,  we automatically get methods that we can call from our
controller or views based on the names in the path. Let’s run <span class='commandname'>rake routes</span> to interactively inspect how our route is set up:</p>
<pre class='code' language='session'>
$ rake routes
my_course  /my_course(.:format) {:action=&gt;"show", :controller=&gt;"courses"}
</pre>
<p>This little diagnostic script<div class='footnote'><p><span class='commandname'>rake routes</span> was added to Rails in 2007 by Josh Susser, inspired by Rick
Olson’s routing navigator plugin which was turned in a rake task by Chris Wanstrath, founder of github.com.
<a class='url' href='http://blog.hasmanythrough.com/2007/7/3/check-out-your-routes'>http://blog.hasmanythrough.com/2007/7/3/check-out-your-routes</a>. If you find yourself wanting a debugging tool,
you might consider experimenting in Ruby, making something useful and adding it to Rails yourself.</p></div> originally shows some of the built-in features along with the controller and
action names that we specified explicitly. As part of the URL, we can see the <span class='ic'>:format</span> option.
By default, a request will be assumed to be of <span class='ic'>html</span> format, but this request will respond to <span class='ic'>/my_course.html</span>
explicity or an alternate format like <span class='ic'>/my_course.xml</span> or <span class='ic'>/my_course.txt</span>. Our controller action can provide alternate behavior,
based on the format of the request.</p>
<p>At the beginning of the line is an internal method name that has been defined for us — actually it’s just part
of a method name. The command <span class='commandname'>rake routes</span> prints <span class='ic'>my_course</span>,
but there are actually two methods <span class='ic'>my_course_path</span> and <span class='ic'>my_course_url</span>. Let’s hop into <span class='commandname'>rails
console</span>
and check that out:</p>
<pre class='code' language='irb'>
$ rails c
Loading development environment (Rails 3.0.1)
&gt;&gt; app.my_course_path
 =&gt; "/my_course" 
&gt;&gt; app.my_course_url
 =&gt; "http://www.example.com/my_course" 
</pre>
<p> In <span class='commandname'>rails console</span> we use the <span class='ic'>app</span> object to call these helper methods
interactively, but we can call them directly in our views and controllers.</p>
</div>
<p>We can change the name of the method by annotating the route. In our case, we’re using a non-standard name for the
route to our show page, so let’s annotate it with the standard path “course” which is just the model name:</p>
<pre class='external'>1   
2   ClassApp::Application.routes.draw do
3     #resources :people
4     match "my_course" =&#62; "courses#show", :as =&#62; "course"
5   end

</pre>
<p>We can see the change when we call <span class='commandname'>rake routes</span>:</p>
<pre class='code' language='session'>
$ rake routes
course  /my_course(.:format) {:action=&gt;"show", :controller=&gt;"courses"}
</pre>
<p>By using a standard name, we can now use another Rails URL helper that is built to help us
manage a <em class='emph'>resource</em>, which just means that we can think about and interact with a model rather than
remembering the specific URLs that we’ve set up for it.  Check this out:</p>
<pre class='code' language='irb'>
$ rails c
Loading development environment (Rails 3.0.3)
&gt;&gt; c = Course.first
 =&gt; #&#060;Course/>1&#062;title: "Creative Writing", description: "Learn to write…
&gt;&gt; app.url_for(c)
 =&gt; "http://www.example.com/my_course.1" 
</pre>
<p>We can call <span class='ic'>app.url_for</span> with a model and it automatically plucks the id from the model and creates a path
from the route that maps to the name of the model. We haven’t yet told it how we want to accept the id as a parameter,
so it just tacks it on the end. When we learn more about where routes lead to and to work with parameters,
we’ll come back and fix up our route.</p>

<div class='figure' id='fig.missing-courses-controller'>
  <h3 class='title'>Figure 10.2: We Have a Route but no Controller</h3>
  <img class='imagedata' src='images/controllers/missing-courses-controller.png'></img>
</div>

<p>When we refresh our browser, we see the error shown
in <a class='ref' href='#fig.missing-courses-controller'>Figure 10.2</a>: <span class='ic'>uninitialized constant CoursesController</span>. We know that
classes are constants in Ruby, so when the <span class='rubyclass'>CoursesController</span> can’t be found, we
get a general error that the <em class='emph'>constant</em> is not initialized. Ruby is actually telling us that we have not yet defined
a <span class='rubyclass'>CoursesController</span> class.</p>
</div>
</div>
<sect1>
<h3 class='title'>Creating our First Controller</h3>
  <p> We put code that connects one web page to the next in the controller, defining the flow of our application. The controller is like a policeman directing traffic across an intersection.  It receives HTTP requests and decides
  what to do with them. People in the right turn lane should be waved right.  Those in the left turn lane should be
  waved left.  The cop knows where to wave the cars based on which lane they arrive in, but also might make exceptions
  to direct trucks to the larger street or cars to the side in the case of an emergency.</p>
  <p>If we think about what we created with scaffold, we have a <span class='rubyclass'>PeopleController</span> class with a <span class='method'>create</span> method
  which redirects to the <span class='method'>show</span> page if the <span class='rubyclass'>Person</span> was successfully
  created, but renders the <span class='ic'>new</span> view if validation failed and the data in
  the form needs to be corrected and re-submmitted. That small amount of direction is at the heart of a controller
  action – one destination for success and a
  different destination for failure. Many controller actions aren’t even that complex and just handle setting up data
  to render a single page.</p>
  <p>Our first controller method for the <span class='ic'>show</span> action will be a simple one with no conditional logic that
  renders a single page. We’ll be displaying a single course by applying what learned about ActiveRecord along with our
  Ruby coding skills to fetch our model and then display its data.  We’ll start with the basics by rendering a dynamic view.</p>
<p>First to fix our latest error, we’ll use the <span class='commandname'>rails generate</span> script to create a controller. We use the short form of the
controller name, <span class='ic'>courses</span>, to
create our <span class='rubyclass'>CoursesController</span> class:</p>
<pre class='code' language='session'>
$ rails generate controller courses
      create  app/controllers/courses_controller.rb
      invoke  erb
      create    app/views/courses
      invoke  rspec
      create    spec/controllers/courses_controller_spec.rb
      invoke  helper
      create    app/helpers/courses_helper.rb
      invoke    rspec
      create      spec/helpers/courses_helper_spec.rb
</pre>
<p>The generator creates a controller and a <em class='emph'>helper</em> along with a directory for the views and corresponding
tests.  Rails generates not only the controller, but the other files and directories we will usually need: a directory
for our views and a helper module where we keep code shared by our controller and views. Our focus right now is on the
  controller, since the error we needed to resolve is about a missing <span class='rubyclass'>CoursesController</span>. By
  defining the controller class in <span class='filename'>app/controllers/courses_controller.rb</span>, we have addressed the
  error.</p>
  <p>When we refresh the browser at
<a class='url' href='http://localhost:3000/my_course'>http://localhost:3000/my_course</a>, we see an “Unknown Action” error shown in <a class='ref' href='#fig.unknown-action'>Figure .3</a>.
The error reports that “the action ‘show’ could not be found.”</p>
<div class='figure' id='fig.unknown-action'>
  <h3 class='title'>Figure 10.3: We need to define a Controller action</h3>
  <img class='imagedata' src='images/controllers/unknown-action.png'></img>
</div>

</div>

<sect1>
<h3 class='title'>What’s a Controller Action?</h3>
<p>A controller action may take several forms:</p>
<ul>
<li><p>a view template, implemented with EmbeddedRuBy (ERB)</p></li>
<li><p>a controller method that sets up instance variables for a default view template</p></li>
<li><p>a controller method that explicitly calls <span class='method'>render</span> or <span class='method'>redirect</span></p></li>
</ul>
<p>We’ll start with the simplest controller action by creating a view template with no additional code in our
controller class.</p> 
</div>
<sect1>
<h3 class='title'>Creating a View Template</h3>
<p>Rails expects view templates for
the <span class='rubyclass'>CoursesController</span> to be found in the <span class='dir'>/app/views/courses</span> directory. 
This directory was created when we generated the <span class='rubyclass'>CoursesController</span>. The views are visual
presentation of the human interface to our application, and like URLs, are kept separate from the code in our controller
which will determine the interaction that happens when someone clicks a link or a button.</p>
<p>When Rails matches a route, it will look
for a file with name of the action and “.html.erb” appended.  For the route <span class='ic'>courses#show</span> we’ll create a file
  <span class='filename'>/app/views/courses/show.html.erb</span> with some basic html, such as:</p>
<pre class='external'>1   &#60;h1&#62;Here I am&#60;&#47;h1&#62;

</pre>
<p>Now when we point our browser to: <a class='url' href='http://localhost:3000/my_course'>http://localhost:3000/my_course</a> we see &ldquo;Here I am!&rdquo; in large text as shown in <a class='ref' href='#fig.here-i-am'>Figure .4</a>. 
</p>
<div class='figure' id='fig.here-i-am'>
  <h3 class='title'>Figure 10.4: A simple view</h3>
  <img class='imagedata' src='images/controllers/here-i-am.png'></img>
</div>
<p>Let’s take another look at the Rails log, which is output in the terminal window where we are running <span class='ic'>rails
server</span>. We can now understand what is happening in the text that is spewed out for every request:</p>
<pre class='code' language='session'>
Started GET "/my_course" for 127.0.0.1 at 2011-05-01 15:12:40 -0700
  Processing by CoursesController#show as HTML
Rendered courses/show.html.erb within layouts/application (59.7ms)
Completed 200 OK in 100ms (Views: 99.3ms | ActiveRecord: 0.0ms)
</pre>

<p>The server received a <span class='ic'>GET</span> request for <span class='ic'>/my_course</span> which was then processed by the
<span class='rubyclass'>CoursesController</span> <span class='ic'>show</span> action rendering <span class='ic'>courses/show.html.erb</span> as HTML. When
starting with a new framework, it is easy to let our eyes glaze over as pages of unfamiliar text scroll by, but if we
pay close attention to what the log output looks like normally, it helps us track down what is going on the first time
that our app starts doing something unexpected.</p>
<p>Whew! We wrote a <em class='emph'>route</em> and created a <em class='emph'>controller</em> and saw how Rails automatically called a
<em class='emph'>view template</em> with the same name as the controller action without our needing to write any code in the
controller. That’s pretty cool, but at the moment we have nothing more exciting than we would have with a plain old web page
hosted on a plain old web site. But wait! We have everything in place to write some code for some dynamic content. The
file we made isn’t just a plain old html file, it’s called a view template because we  can add <em class='emph'>embedded
Ruby</em> code to create a different presentation depending on circumstance.</p>
<sect2>
<h3 class='title'>Accepting Parameters in Our View</h3>
<p>Let’s look at the parameters that are already built into Rails. These parameters are available to us in a <span class='rubyclass'>Hash</span> called <span class='ic'>params</span>, which is
accessible from our view or our controller. We usually don’t access parameters directly in our view, but sometimes doing
so is handy for debugging. For now, let’s explore by displaying them in html. We’ll use Ruby in our view to iterate over
the <span class='ic'>params Hash</span> and display each key-value pair:</p>
<pre class='external'>1   &#60;h1&#62;Here are my parameters:&#60;&#47;h1&#62;
2   &#60;ul&#62;
3   &#60;% params.each do |key, value| %&#62;
4   &#60;li&#62;&#60;%= "#{key} ... #{value}" %&#62;&#60;&#47;li&#62;
5   &#60;% end %&#62;
6   &#60;&#47;ul&#62;
</pre>
<p>We can see in <a class='ref' href='#fig.params'>Figure 10.5</a> that the controller and action names are passed as parameters. URL query
arguments are passed the same way. In HTTP we can pass name-value pairs as part of the URL like
<url>http://localhost:3000/my_course.html?id=4</url>. These are parsed by Rails and turned into a
<span class='rubyclass'>Hash</span>, which we can see in the log:</p>
<pre class='code' language='session'>
Started GET "/my_course.html?id=4" for 127.0.0.1 at 2011-05-01 17:52:43 -0700
  Processing by CoursesController#show as HTML
  Parameters: {"id"=&gt;"4"}
Rendered courses/show.html.erb within layouts/application (1.7ms)
Completed 200 OK in 5ms (Views: 5.0ms | ActiveRecord: 0.0ms)
</pre>
<p>The log only shows the parameters that come from the browser. Any query argument we add to the URL will be added to
the <span class='ic'>params Hash</span> along with the internal parameters of controller and action name. Try
it. <a class='ref' href='#fig.params-query'>Figure 10.6</a> shows an example with the query arguments <span class='ic'>foo=barnum=1</span> but they
could, of course, be anything.</p>
<div class='figure' id='fig.params'>
  <h3 class='title'>Figure 10.5: Default parameters</h3>
  <img class='imagedata' src='images/controllers/params.png'></img>
</div>
<div class='figure' id='fig.params-query'>
  <h3 class='title'>Figure 10.6: Query arguments foo=barnum=1</h3>
  <img class='imagedata' src='images/controllers/params-query.png'></img>
</div>

</div>
<sect2>
<h3 class='title'>Parsing View Parameters from the URL String</h3>
<p>These days it is common to use part of the URL to parameterize the view, largely because search engines will ignore
everything after the <span class='ic'>?</span> in a URL and only index a single page, but also because plain URLs are easier to read
when people bookmark them. Rails gives us tremendous flexibility with how we define URLs and map them to our code. This is easy to do in Rails. We just specify
a symbol as part of the URL pattern in our routes and that is automatically parsed and assigned a value in the <span class='ic'>params
Hash</span>. In fact we’ve already seen this with the format extension, as shown in <a class='ref' href='#fig.params-with-format'>Figure 10.7</a></p>
<div class='figure' id='fig.params-with-format'>
  <h3 class='title'>Figure 10.7: Default parameters with format in URL</h3>
  <img class='imagedata' src='images/controllers/params-with-format.png'></img>
</div>
<p>Now that we understand how URL parameters work, as well as custom routes, let’s change our route to use the standard
naming convention for a show page. The URL would be <span class='ic'>/courses/4</span> to display the detailed data of a <span class='rubyclass'>Course</span>
with id 4. We can just make up any name we want, preface it with a colon (:), put it in the route and it will be added
to the <span class='ic'>params Hash</span>. We’ll just use the name “id” because that’s what it is, and unsurprisingly, it matches the
Rails the naming convention.</p>
<pre class='external'>1   
2   ClassApp::Application.routes.draw do
3     #resources :people
4     match "courses&#47;:id" =&#62; "courses#show", :as =&#62; "course"
5   end

</pre>
<p>In <span class='commandname'>rake routes</span>, we can see that the invisible default format param is still there, even if
we specify other params in the URL:</p>
<pre class='code' language='session'>
$ rake routes
course  /courses/:id(.:format) {:controller=&gt;"courses", :action=&gt;"show"}
</pre>
<p>We can look in <span class='commandname'>rails console</span> to see that <span class='ic'>url_for</span> will now return a standard URL:</p>
<pre class='code' language='irb'>
$ rails c
Loading development environment (Rails 3.0.3)
&gt;&gt; c = Course.first
 =&gt; #&#060;Course/>1&#062;title: "Creative Writing", description: "Learn to write…
&gt;&gt; app.url_for(c)
 =&gt; "http://www.example.com/courses/1" 
</pre>
<p>Later we’ll use <span class='ic'>url_for</span> in our views to link to pages without embedding literal strings which makes our code
harder to maintain.</p>
<p>We’ve learned about routes and how they pass information to views and controllers through the <span class='ic'>params Hash</span> using old fashioned query arguments
as well as new-fangled parameterized URLs. We created a controller, which was
required to route a URL to a view, but we haven’t written any code for a controller yet. We’re now using standard naming
for our <span class='rubyclass'>Course</span> “show” page, but we have not yet implemented the standard behavior of displaying the model
  data in the show page. We want to keep our view code lean and focused on pure visual layout as much as possible, so
  we’ll put the next bit of code into a controller method.</p>
</div>
<sect2>
<h3 class='title'>How do Controller Methods fit in?</h3>
<p>Now that we understand routes fairly well, let’s take a look at our controller in <span class='filename'>app/controllers/messages_controller.rb</span>:</p>
<pre class='external'>1   class CoursesController &#60; ApplicationController
2   end

</pre>
<p>We can see there is no code in our subclass of ApplicationController.  So far we’ve been relying on the built-in
Rails behavior where the controller will render the html template with the same name as our action. To see how it works,
let’s use the Rails logger to make an instance method of the same name that just prints out
something we can easily see:</p>
<pre class='external'>1   class CoursesController &#60; ApplicationController
2     def show
3       logger.info "==================&#62; show method!"
4     end
5   end

</pre>
<p>and also add some output when the view is rendered, and we can remove the displaying of params now:</p>
<pre class='external'>1   &#60;h1&#62;This is my course view&#60;&#47;h1&#62;
2   &#60;% logger.info "------------------------&#62; show view!" %&#62;
</pre>
<p>Then when we browse to <a class='url' href='http://localhost:3000/courses/4'>http://localhost:3000/courses/4</a>, we can see the output of <span class='ic'>Rails.logger</span> in
our terminal window. <span class='ic'>Rails.logger</span> does not affect the HTML that is rendered in the view.</p>
<sidebar>
<h3 class='title'>Why use Rails.logger instead of puts?</h3>
<p>When we first experimented with Ruby code, we sometimes used <span class='method'>puts</span> to see what was going on outside
our program. Let’s see what happens to the output if we use <span class='method'>puts</span> instead of <span class='ic'>Rails.logger</span>:</p>
<pre class='code' language='session'>
==================&gt; show method
------------------------&gt; show view


Started GET "/courses/4" for 127.0.0.1 at 2011-05-01 19:15:42 -0700
  Processing by CoursesController#show as HTML
  Parameters: {"id"=&gt;"4"}
Rendered courses/show.html.erb within layouts/application (1.8ms)
Completed 200 OK in 8ms (Views: 6.6ms | ActiveRecord: 0.0ms)
</pre>
<p>The server log looks out of sequence here.  The output of the show method happens before the view, but it
appears that the <span class='ic'>GET</span> request started <em class='emph'>after</em> the method and view were called. How could this be? This happens because the Rails
logger saves up its data and writes it once when it completes the HTTP response. Both the <span class='method'>puts</span>
method and the Rails logger are printing to the terminal window.</p>
<p>The controller method is called first and then the view is rendered and our statements are
interspersed in the sequence we expect with the built-in logger info. There are various logger methods which correspond
to level <em class='emph'>levels</em>. The output
methods in order of level are: <span class='ic'>debug</span>, <span class='ic'>info</span>, <span class='ic'>warn</span>, <span class='ic'>error</span>, and <span class='ic'>fatal</span>.</p>
<p> By default, Rails will log all levels in every environment except production, where
<span class='ic'>info</span> and higher is logged.  We can set the log level in the environment-specific config files.  Usually we’ll
just leave the log levels as the defaults. In
<span class='dir'>app/environments/production.rb</span>, Rails provides a handy comment <span class='ic'>config.log_level = :debug</span>
which we occasionally turn on in the rare case that we need to debug an issue in production.</p>
</div>
<p>The controller <span class='method'>show</span> happens before the view is rendered:</p>
<pre class='code' language='session'>
Started GET "/courses/4" for 127.0.0.1 at 2011-05-01 19:20:56 -0700
  Processing by CoursesController#show as HTML
  Parameters: {"id"=&gt;"4"}
==================&gt; show method!
------------------------&gt; show view!
Rendered courses/show.html.erb within layouts/application (1.6ms)
Completed 200 OK in 5ms (Views: 5.1ms | ActiveRecord: 0.0ms)
</pre>
<p>Our controller method gets called before our view is rendered, letting us handle the interaction logic of
what to show to the person using our web app.</p>
</div>
</div>
<sect1>
<h3 class='title'>Writing a Controller Method</h3>
<p>Our controller method decides what to do in response to an HTTP request, usually it renders a view, but it can respond
with an HTTP redirect which will cause the browser to request another URL and the cycle will start all over again.  If a
controller method does not explicitly render a view or redirect, then the implicit behavior, as we saw with
<span class='method'>show</span>, is for the
Controller to render a view of the same name. Our controller method is the right place to set up data for our
view. Let’s experiment a bit in Rails console to get a better feel for the Ruby code we’ll need to write.</p>

<p>If our <span class='ic'>show</span> method is called from <span class='ic'>/courses/1</span>, then we’ll want to display the data for the record
with id 1:</p>
<pre class='code' language='irb'>
$ rails c
Loading development environment (Rails 3.0.1)
&gt;&gt; Course.find(1)
 =&gt; #&#060;Course/>1&#062;title: "Creative Writing", description: "Learn to write…
</pre>
<p>The id arrives inside our controller as <span class='ic'>params</span>. We saw before that <span class='ic'>params</span> is a <span class='rubyclass'>Hash</span>.
Is is actually a special subclass of <span class='rubyclass'>Hash</span>, called <span class='rubyclass'>HashWithIndifferentAccess</span> that allows us
to treat hash keys the same whether they are a string or a symbol. This is helpful since they key-value pairs of HTTP
query arguments are always strings, yet it is more efficient in Ruby to use symbols. In <span class='ic'>rails console</span>, we can
see this in action:</p>
<pre class='code' language='irb'>
$ rails c
Loading development environment (Rails 3.0.1)
&gt;&gt; params = {}
 =&gt; {} 
&gt;&gt; params["id"] = "4"
 =&gt; "4" 
&gt;&gt; params[:id]
 =&gt; nil 
&gt;&gt; params = HashWithIndifferentAccess.new
 =&gt; {} 
&gt;&gt; params["id"] = "4"
 =&gt; "4"  
&gt;&gt; params[:id]
 =&gt; "4" 
</pre>
<p>Now we know that we’ll be able to find the data we want using the <span class='rubyclass'>ActiveRecord</span> method
<span class='method'>find</span> and pass it the id from the query args:</p>
<pre class='code' language='irb'>
&gt;&gt; Course.find(params[:id])
 =&gt; #&#060;Course/>1&#062;title: "Creative Writing", description: "Learn to write…
</pre>
<p>To allow us to pass data to the view, Rails sets up another shortcut: whatever instance variables we set in the
controller are then available to us in the view.</p>
<pre class='external'>1   class CoursesController &#60; ApplicationController
2     def show
3       @course = Course.find(params[:id])
4     end
5   end
</pre>
<p>The return value of the method is ignored. We’re not seeing exactly how views are created because Rails does that
internally. Part of the strength of the MVC pattern is to keep separate parts of our implementation in separate classes.
When the view is rendered we’re in a completely different context, so we need to specify which data we want sent to the
view and Rails implements this data passing with instance variables that we define in our controller method and can
later access in our view.</p>
<pre class='external'>1   &#60;h1&#62;&#60;%= @course.title %&#62;&#60;&#47;h1&#62;
2   &#60;p&#62;&#60;%= @course.description %&#62;&#60;&#47;p&#62;

</pre>
<p>After our <span class='method'>show</span> controller method executes, the
<span class='rubyclass'>ActionController</span> superclass looks through its own instance variables to see which ones have been added. It then
copies them into a <span class='rubyclass'>Hash</span> which the view uses to set its own instance variables.  This temporary
storage is called <span class='ic'>assigns</span>, which we’ll use when we’re testing.</p>

<div class='ask_sidebar'>
<h3 class='title'>Aren’t instance variables private?</h3>
<p>The way that Rails passes data via instance variables between controller and a view is concise, but makes it seem
like instance variables aren’t really private. The view, which exists in the context of an entirely
different class <span class='rubyclass'>ActionView</span>, seems to have access
to the private instance variables of the controller. However, in reality, the view doesn’t directly access to the controller
instance variables. Whew, isn’t that a relief?  </p>
<p>In Ruby, instance variables <em class='emph'>are private</em> to an instance of a class. This is no different inside of Rails.
However, in Ruby we can get a list of our instance variables and see what they are. Check this out inside of irb:</p>
<pre class='code' language='irb'>
$ irb
&gt;&gt; instance_variables
 =&gt; [:@prompt] 
&gt;&gt; old = instance_variables
 =&gt; [:@prompt] 
&gt;&gt; @foo = 1
 =&gt; 1 
&gt;&gt; @bar = "something"
 =&gt; "something" 
&gt;&gt; instance_variables
 =&gt; [:@prompt, :@foo, :@bar] 
&gt;&gt; new = instance_variables - old
 =&gt; [:@foo, :@bar] 
</pre>
<p>With the model and view, Rails appears to mix together two separate
concern, but it is merely an unusual message passing convention.</p>
</div>

<p>Through exploration in the browser and Rails console, we have worked through the creation of a route, controller
method and a corresponding view. We’ve learned a few variations on the <span class='method'>match</span> for declaring routes. We
built a controller action, both with just a view and by setting up data for the view with a controller method.
Later in the book, we’ll learn more ways to declare routes and understand more about the <span class='method'>resources</span> method, which was
originally added to our routes with scaffold for our <span class='rubyclass'>PeopleController</span>.  In the next chapter, we will test drive more of our <span class='rubyclass'>CourseController</span> development using the REST pattern and Rails
conventions.</p>



</div>

</div>

<!-- -*- xml -*- -->
<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
<head><link href='rubyBook.css' rel='stylesheet' type='text/css'></head>
<div class='chapter' id='ch.controllers-rspec' number='11'>
<h2 class='chapter_title'>Understanding Controllers through Testing</h2>
<p>In the most common controller tests, we use the <span class='ic'>assigns Hash</span> to verify that a
controller method has correctly set up data for the view and we check that the correct template is rendered. Let’s write a controller for the <span class='rubyclass'>Person</span>
model in our class app using a test first
approach. </p>

<sect1>
<h3 class='title'>Writing a Controller Spec</h3>
<p>We can use an RSpec generator to create our people controller spec file. Remember the
<span class='rubyclass'>Controller</span> works with multiple <span class='rubyclass'>Person</span> models, so it is plural:</p>
<pre class='code' language='session'>
  $ rails generate rspec:controller people
</pre>
<p>Let’s first make sure that when we browse to the <span class='ic'>people/index</span> page the
<span class='rubyclass'>PeopleController</span> renders the <span class='ic'>index</span> template: </p>
<pre class='external'>1   require 'spec_helper'
2   
<a class='label' id='code.people_controller_context'>3   describe PeopleController do   
</a><a class='label' id='code.people_index_context'>4     describe "GET index" do   
</a>5       it "renders" do
<a class='label' id='code.get_index'>6         get :index        
</a><a class='label' id='code.should_render'>7         response.should render_template(:index) 
</a>8       end
9     end
10   end
11   
12   

</pre>
<p>When we’re testing controllers, we’ll use a <em class='emph'>nested describe</em> to group each request. In this spec, we’ve got
an overall context for the <span class='rubyclass'>PeopleController</span> on line <a class='cref' href='#code.people_controller_context'>3</a> and
within that another context for <span class='ic'>"GET index"</span> on line <a class='cref' href='#code.people_index_context'>4</a>  which is
just a string that tells us which request we’re testing.</p>
<p>Now that we’ve set up the example, we’re on to the interesting part! On line <a class='cref' href='#code.get_index'>6</a> we’re calling the
<span class='method'>index</span> method of the controller as if it came from a <span class='ic'>GET</span> request. We’re not 
really performing an <span class='ic'>HTTP GET</span> — we’re calling the controller using some testing
helpers which call into Rails the same way the web server will. Those same testing helpers create a <span class='ic'>response</span> object to store the result. We then verify on line <a class='cref' href='#code.should_render'>7</a> that the
controller method rendered the template <span class='filename'>index.html.erb</span>. </p>
<p>Whew! At first glance, it seems
like we’re learning a lot of extra stuff just for testing. But as we dig in, we find out that this extra stuff is just part
of how controllers work. By learning to test controllers, we understand them.</p>

<p>So, let’s run the spec!</p>
<pre class='code' language='session'>
$ rake spec
(in /Users/sarah/class_app)
/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby -S bundle exec 
rspec ./spec/controllers/people_controller_spec.rb ./spec/models/assignment_spec.rb 
./spec/models/person_spec.rb
/Library/Ruby/Gems/1.8/gems/rspec-core-2.5.1/lib/rspec/core/backward_compatibility
.rb:20:in `const_missing': uninitialized constant PeopleController (NameError)
	from /Users/sarah/class_app/spec/controllers/people_controller_spec.rb:5
  …
  …long stack trace here…
  …
rake aborted!
ruby -S bundle exec rspec ./spec/controllers/people_controller_spec.rb 
./spec/models/assignment_spec.rb ./spec/models/person_spec.rb failed
</pre>

<p></p>
<p>Here’s our old friend, the <span class='ic'>uninitialized constant</span> error, telling us that we have not yet
defined our <span class='rubyclass'>PeopleController</span> class. We’ll generate one, being careful not to overwrite our spec
when prompted: </p>
<pre class='code' language='session'>
$ rails generate controller people
      create  app/controllers/people_controller.rb
      invoke  erb
      create    app/views/people
      invoke  rspec
    conflict    spec/controllers/people_controller_spec.rb
  Overwrite /Users/sarah/class_appplt 
  (enter "h" for help) [Ynaqdh] n
        skip    spec/controllers/people_controller_spec.rb
      invoke  helper
      create    app/helpers/people_helper.rb
      invoke    rspec
      create      spec/helpers/people_helper_spec.rb    
</pre>
<p>Defining the <span class='rubyclass'>PeopleController</span> class in <span class='filename'>app/controller/people_controller.rb</span>
should address our first spec error. We don’t expect to be done yet, but we still run the spec again to see that our test
fails in the way we expect:</p>

<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb
(in /Users/sarah/src/satfr/Book/code/message_app)
F
Failures:

  1) PeopleController GET index renders
     Failure/Error: get :index      
     ActionController::RoutingError:
       No route matches {:controller=&gt;"people"}
     # ./spec/controllers/people_controller_spec.rb:8:in `block (3 levels)
     in <top/>(required)&gt;'

Finished in 0.10692 seconds
1 example, 1 failure
</pre>
<p>We’re seeing the same kinds of errors we saw interactively when we were experimenting with the web app, so we know we
are on the right track.  This error is similar to the one we saw in <a class='ref' href='#fig.routing-error'>Figure .1</a> except we’re
looking at it from the other direction. Instead of a URL that has no route connecting it to a controller action, we have
a controller action with no route leading to it.</p>
<p>Of course, to fix this we need to a add route. Looking in <span class='filename'>config/routes.rb</span>, we see a lot of
comments generated as inline documentation for Rails. Let’s just delete those and add a simple route that matches our
people index page to our people index action:</p>
<pre class='external'>1   ClassApp::Application.routes.draw do
2   	match "people&#47;index" =&#62; "people#index"  
3   end

</pre>
<p>That looks a little redundant, but for now let’s do <em class='emph'>the simplest thing that could possibly work</em>. We’ll
worry about code prettiness later, because we know we’re still not done. Let’s run the spec again and expect to watch it fail:</p>

<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb
F

Failures:

  1) PeopleController GET index renders
     Failure/Error: get :index       
     AbstractController::ActionNotFound:
       The action 'index' could not be found for PeopleController
     # ./spec/controllers/people_controller_spec.rb:8:in `block (3 levels) 
     in <top/>(required)&gt;'

Finished in 0.0427 seconds
1 example, 1 failure
</pre>
<p>Now the failure points to a missing action <span class='ic'>index</span> for our <span class='rubyclass'>PeopleController</span>. We have
multiple options for how to create a controller action: write a controller method, create a view template or both. Let’s
do the simplest thing:</p>
<pre class='code' language='session'>
$ touch app/views/people/index.html.erb
</pre>
<p>Um… huh?  We just used the Unix command <span class='commandname'>touch</span> which will create an empty file if it doesn’t
already exist  In our controller spec, we’re verifying that the response is set up to render a specific template, but
we’re not yet checking to see if the view has anything interesting in it. We’re just making sure it is all hooked up. Let’s run the spec and see how that works:
</p>
<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb
.

Finished in 0.07397 seconds
1 example, 0 failures
</pre>
<p>Woo hoo! Our spec passes!</p>
<p>Time for a beer? Not yet! It is now time for us to reflect on our code and make it better if we see room for
improvement. This is the third step of TDD’s red-green-refactor mantra. Let’s take a look at the route we created, from
two angles. Here’s the declaration:</p>
<pre class='external'>1   ClassApp::Application.routes.draw do
2   	match "people&#47;index" =&#62; "people#index"  
3   end

</pre>
<p>The other way we can look at our routes is with <span class='commandname'>rake routes</span>:</p>
<pre class='code' language='session'>
$ rake routes
people_index  /people/index(.:format) {:controller=&gt;"people", :action=&gt;"index"}
</pre>
<p>Now there are are two things that aren’t lovely about this route. First we’re using a non-standard name for the
route — usually we simply call the route the main people page <span class='ic'>people_path</span> rather than
<span class='ic'>people_index_path</span>. The second bit is actually the cause of this. We can specify the index page more concisely
since that is the default page for any route:</p>
<pre class='external'>1   ClassApp::Application.routes.draw do
2   	match "people" =&#62; "people#index"  
3   end

</pre>
<p>Now when we look at our routes, we see:</p>
<pre class='code' language='session'>
$ rake routes
people  /people(.:format) {:action=&gt;"index", :controller=&gt;"people"}
</pre>
<p>Ah. Lovely. Go grab yourself a beverage!</p>


<sect2>
<h3 class='title'>Testing More Controller Action</h3>
<p>Controller tests are all about the details of the <em class='emph'>controller</em> — we’re not testing the contents of
the view. Still we are going to want our “people/index” page to show a list of people and the controller is where we
fetch models and lay the foundation for the view. We want to have an array of all of the people models which we can send
to the view by referencing it with an instance variable.  Yep, that’s just how it is.</p>
<p>We’ll write the test first and check the <span class='ic'>assigns Hash</span> to make sure our controller method set up the data
correctly, but first we need some fake data to test. There are a lot of fancy gems to help us create fake data for
tests, but we’ll start by simply creating some sample data with an ActiveRecord method we already know and love: 
<span class='ic'>Person.create!</span>. We like to use <span class='ic'>!</span> methods in our tests because if for some unexpected reason the
creation of the object were to fail, the method would raise an exception and any uncaught exception will cause our test
to fail.</p>
<p>At the beginning of our <span class='rubyclass'>PeopleController</span> spec, we’ll add this:</p>
<pre class='external'>1     before do
2       @emmy = Person.create! :first_name =&#62; "Emmy", :last_name =&#62; "Noether"
3       @marie = Person.create! :first_name =&#62; "Marie", :last_name =&#62; "Curie"
4       @lise = Person.create! :first_name =&#62; "Lise", :last_name =&#62; "Meitner"   
5     end

</pre>
<p>At the beginning of each test we’ll create records for three of our favorite Nobel laureates to our test database.
This is why rspec tests are called <em class='emph'>examples</em>.  We’re testing just one example case at a time. For this one,
we’ll write our example like this:</p>
<pre class='external'>1       it "sets up the whole list of people" do
2         get :index 
3         assigns[:people].should == [@emmy, @marie, @lise]
4       end

</pre>
<p>We first <span class='ic'>get</span> the index page, then we test the <span class='ic'>assigns Hash</span>, checking the value at <span class='ic'>:people</span>
to see if it contains an Array of the three specific records we added to the database. We’re just making up the fact that we expect our controller method to set the instance variable <span class='ic'>@people</span>.  It’s
a good design though — we’re following the Rails conventions on naming since we want to display a whole list of Person
objects, we name our variable with the plural noun, people.</p>
<p>Now let’s run the spec and see how it fails</p>

<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb 
.F

Failures:

  1) PeopleController GET index sets up the whole list of people
     Failure/Error: assigns[:people].should == [@emmy, @marie, @lise]
       expected: [#&#060;Person/>1&#062;first_name: "Emmy", last_name: "Noether", 
       created_at: "2011-02-27 22:39:59", updated_at: "2011-02-27 22:39:59"&gt;, 
       #&#060;Person/>1&#062;first_name: "Marie", last_name: "Curie", created_at: 
       "2011-02-27 22:39:59", updated_at: "2011-02-27 22:39:59"&gt;, #&#060;Person/>1&#062;first_name: "Lise", last_name: "Meitner", created_at: 
       "2011-02-27 22:39:59", updated_at: "2011-02-27 22:39:59"&gt;]
            got: nil (using ==)
     # ./spec/controllers/people_controller_spec.rb:21:in `block (3 levels) 
     in <top/>(required)&gt;'

Finished in 0.22362 seconds
2 examples, 1 failure
</pre>
<p>We can see that the new example fails because <span class='ic'>assigns[:people]</span> has a value of nil, which is exactly how we
would expect it to fail since we haven’t written any code to give it a value.</p>
<p>To make the example pass, we need to modify our controller to have an index method that sets the value of its
<span class='ic'>@people</span> instance variable to all of the people records:</p>
<pre class='external'>1   class PeopleController &#60; ApplicationController
2     def index
3       @people = Person.all
4     end
5   end

</pre>
<p>Behind the scenes, the Rails Controller superclass will take the contents of the <span class='ic'>@people</span> instance variable
and stuff it into <span class='ic'>assigns[:people]</span>. Just like that! Now we can watch the whole spec pass:</p>

<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb
..

Finished in 0.18329 seconds
2 examples, 0 failures
</pre>
<p>Are done yet? Nope. Time to reflect upon our code. Now it is hard to imagine something simpler than our 5 line
<span class='rubyclass'>PeopleController</span> class, but that’s not everything we’ve done. We also need to look at our specs.
Now is a good time to refactor tests as well as production code. There’s just one change we might make: </p>
<pre class='external'>1   require 'spec_helper'
2   
3   describe PeopleController do
4     before do
5       @emmy = Person.create! :first_name =&#62; "Emmy", :last_name =&#62; "Noether"
6       @marie = Person.create! :first_name =&#62; "Marie", :last_name =&#62; "Curie"
7       @lise = Person.create! :first_name =&#62; "Lise", :last_name =&#62; "Meitner"   
8     end
9   
10     describe "GET index" do 
11       before do
12         get :index
13       end
14   
15       it "renders" do
16         response.should render_template(:index) 
17       end
18   
19       it "sets up the whole list of people" do
20         assigns[:people].should == [@emmy, @marie, @lise]
21       end
22     end
23   end
24   
25   

</pre>
<p>We’ve moved the repeated code <span class='ic'>get :index</span> into a <span class='ic'>before</span> block. This reads a little clearer, even
though arguably we’ve replaced two lines of code with three – they are shorter lines and they don’t repeat themselves.
The code is fresh, airy and light.</p>
</div>
<sect2>
<h3 class='title'>Let’s Make a Person!</h3>
<p>Controller actions aren’t just for displaying data in views, we can also use them to create objects. Following the
REST convention, HTTP POST requests are used for object creation. Following Rails convention, we POST to <span class='ic'>/people</span> to create a
<span class='rubyclass'>Person</span> object.  Let’s write the test to show how a RESTful
controller expects to be called to create a new <span class='rubyclass'>Person</span> object. In a web application, an HTTP POST
typically <em class='emph'>redirects</em> to another URL, which means that the web application will return a 302 status code and
the browser is responsible for making an HTTP GET request to the URL given in the Location field of the HTTP Header.  In
a RESTful web application, when an object is created, the address of that object is returned.  In Rails, we call the
page that displays the object the <span class='firstuse'>show</span> page and the URL is something like
<span class='ic'>/people/1</span>.</p>
<p>Let’s start by making our HTTP POST to <span class='ic'>/people</span> do a redirect to an action that we’ve already defined, instead of the default
render</p>
<pre class='external'>
</pre>
<p>
The parameters to a create action are conventionally given as a nested hash. There are Rails helpers to create forms
that generate POSTs just this way.  For now our focus is on the controller.  Let’s see how our example fails:</p>
<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb
..F

Failures:

  1) PeopleController POST create redirects
     Failure/Error: post :create, :person =&gt; {:first_name =&gt; "Barbara", 
                                              :last_name =&gt; "Liskov"}
     ActionController::RoutingError:
       No route matches {:person=&gt;{:first_name=&gt;"Barbara", :last_name=&gt;"Liskov"}, 
       :controller=&gt;"people", :action=&gt;"create"}
     # ./spec/controllers/people_controller_spec.rb:27:in `block (3 levels) 
     in <top/>(required)&gt;'

Finished in 0.21168 seconds
3 examples, 1 failure
</pre>
<p>Hmmm… we’re missing a route.  We’ve got one that connects to <span class='ic'>/people</span> to the <span class='ic'>index</span> action, but we
need that to only happen for a GET request and we need the POST to go somewhere else. Well, as it turns out, the
<span class='method'>match</span> method will match any kind of
request that comes in for that URL which can be convenient for implementing certain kinds of APIs, but it’s not a good
fit for what we want to do here.</p>
<p>Let’s change our routes so the two HTTP actions map to two different controller actions:</p>
<pre class='external'>1   ClassApp::Application.routes.draw do
2   	get "people" =&#62; "people#index"  
3   	post "people" =&#62; "people#create"  
4   end

</pre>
<p>Now let’s check out our routes:</p>

<pre class='code' language='session'>
$ rake routes
people GET  /people(.:format) {:action=&gt;"index", :controller=&gt;"people"}
       POST /people(.:format) {:action=&gt;"create", :controller=&gt;"people"}
</pre>
<p>If we run our spec again, we see…</p>
<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb
..F

Failures:

  1) PeopleController POST create redirects
     Failure/Error: post :create, :person =&gt; {:first_name =&gt; "Barbara", 
                                              :last_name =&gt; "Liskov"}
     AbstractController::ActionNotFound:
       The action 'create' could not be found for PeopleController
     # ./spec/controllers/people_controller_spec.rb:27:in `block (3 levels) 
     in <top/>(required)&gt;'

Finished in 0.22273 seconds
3 examples, 1 failure
</pre>
<p>Now our example is failing since we don’t yet have a <span class='method'>create</span> action in our
<span class='rubyclass'>PeopleController</span>.  We’ll start by fixing just this error:</p>
<pre class='external'>1   class PeopleController &#60; ApplicationController
2     def index
3       @people = Person.all
4     end
5   
6     def create
7     end
8   end

</pre>
<p>Then let’s run the spec again.  We still expect it to fail, but we want to make sure it fails the way we expect:</p>


<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb
..F

Failures:

  1) PeopleController POST create redirects
     Failure/Error: post :create, :person =&gt; {:first_name =&gt; "Barbara", 
                                              :last_name =&gt; "Liskov"}
     ActionView::MissingTemplate:
       Missing template people/create with {:handlers=&gt;[:erb, :rjs, :builder, 
       :rhtml, :rxml], :formats=&gt;[:html], :locale=&gt;[:en, :en]} in view paths 
       "#&#060;Person/>1&#062;     # ./spec/controllers/people_controller_spec.rb:27:in `block (3 levels) 
     in <top/>(required)&gt;'
</RSpec::Rails>
<p>Well, we’re not even getting to our check for redirect before the <span class='ic'>post</span> to the <span class='ic'>create</span> action fails.
Our empty create method is doing a render by default and then finding that it has no template – to fix that, let’s add
in the redirect: </p>
<pre class='external'>1   class PeopleController &#60; ApplicationController
2     def index
3       @people = Person.all
4     end
5   
6     def create
7       redirect_to people_path
8     end
9   
10   end

</pre>
<p>Now we expect our example to pass:</p>
<pre class='code' language='session'>
$rspec spec/controllers/people_controller_spec.rb
...

Finished in 0.13336 seconds
3 examples, 0 failures
</pre>
<p>and it does pass.  Good stuff, but we’re not done yet. Our create action successfully redirects, but it doesn’t yet
create a record in the database.  Let’s add another example for that:</p>
<pre class='external'>
</pre>
<p>and watch it fail:</p>
<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb
...F

Failures:

  1) PeopleController POST create creates a person record
     Failure/Error: Person.where(:first_name =&gt; "Barbara", 
                                  :last_name =&gt; "Liskov").should_not be_empty
       expected empty? to return false, got true
     # ./spec/controllers/people_controller_spec.rb:35:in `block (3 levels) 
     in <top/>(required)&gt;'

Finished in 0.46923 seconds
4 examples, 1 failure
</pre>
<p>We need to actually create the <span class='rubyclass'>Person</span> object from the given attributes from the nested Hash
that we called with the <span class='ic'>post</span> action:</p>
<pre class='external'>1   class PeopleController &#60; ApplicationController
2     def index
3       @people = Person.all
4     end
5   
6     def create
7       Person.create(params[:person])
8       redirect_to people_path
9     end
10   
11   end

</pre>
<p>When we run the spec again, it passes:</p>
<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb
....

Finished in 0.22511 seconds
4 examples, 0 failures
</pre>
<p>Are we done yet?  With a passing spec, it is once again time for reflection.  Our code is nice and concise. Our tests
are readable, but we’re not testing all of the cases we want the code to handle. In <a class='ref' href='#ch.activerecord'>Exploring ActiveRecord</a>
we added validations, so we know that we could provide an empty first or last name and the record will fail to save, but
what will happen with our code? Let’s write an example for that and find out.</p>
<pre class='external'>
</pre>
<p>We put the first set of examples into their own context for “valid data” and then put our new examples into a context
for “invalid data.” Now when we run the specs:</p>
<pre class='code' language='session'>
rspec spec/controllers/people_controller_spec.rb
.....F

Failures:

  1) PeopleController with invalid data should render new template
     Failure/Error: response.should render_template(:new)
       expecting "new"&gt; but rendering with ""&gt;.
       Expected block to return true value.
     # ./spec/controllers/people_controller_spec.rb:49:in `block (3 levels) 
     in <top/>(required)&gt;'

Finished in 0.2994 seconds
6 examples, 1 failure
</pre>  
<p>Our invalid person object is not saved, because of the model validation, but it is still redirecting to the people
index page instead of re-rendering the “new” form.  To fix that, we can use <span class='ic'>Person.new</span> and the
<span class='method'>save</span> method so that we can check if the save was successful or not:</p>
<pre class='external'>
</pre>
<p>Now when we run the spec:</p>


<pre class='code' language='session'>
$ rspec spec/controllers/people_controller_spec.rb
....FF

Failures:

  1) PeopleController with invalid data does not create a person
     Failure/Error: post :create, :person =&gt; {:first_name =&gt; "Barbara"}
     ActionView::MissingTemplate:
       Missing template people/new with {:handlers=&gt;[:erb, :rjs, :builder, 
       :rhtml, :rxml], :formats=&gt;[:html], :locale=&gt;[:en, :en]} in view paths 
       "#&#060;Person/>1&#062;     # ./app/controllers/people_controller.rb:11:in `create'
     # ./spec/controllers/people_controller_spec.rb:43:in `block (3 levels) 
     in <top/>(required)&gt;'

  2) PeopleController with invalid data should render new template
     Failure/Error: post :create, :person =&gt; {:first_name =&gt; "Barbara"}
     ActionView::MissingTemplate:
       Missing template people/new with {:handlers=&gt;[:erb, :rjs, :builder, 
       :rhtml, :rxml], :formats=&gt;[:html], :locale=&gt;[:en, :en]} in view paths 
       "#&#060;Person/>1&#062;     # ./app/controllers/people_controller.rb:11:in `create'
     # ./spec/controllers/people_controller_spec.rb:43:in `block (3 levels) 
     in <top/>(required)&gt;'

Finished in 0.31349 seconds
6 examples, 2 failures
</RSpec::Rails::ViewRendering::PathSetDelegatorResolver:0x000001011faf98>
<p>We can see that both “invalid data” examples fail because we’re missing the new template. Let’s do the simplest thing
that could possibly work: </p>
<pre class='code' language='session'>
$ touch app/views/people/new.html.erb
$ rspec spec/controllers/people_controller_spec.rb
......

Finished in 0.31042 seconds
6 examples, 0 failures
</pre>
<p>Now we understand the basics of controllers, how they act as traffic directors for the web interface. Each controller
action either renders a view or re-directs. If a view is rendered, information may be passed to the view by assigning
instance variables. For very simple controller actions, we’ll often rely on integration tests rather than testing
controller actions in isolation. However, in understanding how to test controllers, we understand exactly how they work
and can make good decisions about where to apply testing in practice.</p>
<p>We also learned about routes and how to include parameters in a URL and specify which controller and action
should be called. We know how to <span class='ic'>match</span> any kind of HTTP request or <span class='ic'>get</span>, <span class='ic'>post</span>,
<span class='ic'>put</span> or
<span class='ic'>delete</span> specifically.</p>

<p></p>

<p>In our development we work hard to keep our controller methods to be small and clearly written. Controllers should do
as little as possible, so that all they are doing is directing traffic: fetching a model, then rendering a view or
redirecting. When our controller actions are small, we can see the whole implementation of a controller on a page or two
which helps us follow the interaction across multiple web requests in our heads as we read the code. It make debugging
easier and makes it easier to work together on a team and modify each other’s code.</p>
</RSpec::Rails::ViewRendering::PathSetDelegatorResolver:0x000001013011a8>
</pre>
</pre>
</div></div></div>
